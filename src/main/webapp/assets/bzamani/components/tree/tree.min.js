/*
Product Name: dhtmlxSuite
Version: 4.1.2
Edition: Standard
License: content of this file is covered by GPL. Usage outside GPL terms is prohibited. To obtain Commercial or Enterprise license contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/* dhtmlx.com */

if (typeof(window.dhx4) == "undefined") {

    window.dhx4 = {

        version: "4.1.2",

        skin: null, // allow to be set by user

        skinDetect: function(comp) {
            return {10:"dhx_skyblue",20:"dhx_web",30:"dhx_terrace"}[this.readFromCss(comp+"_skin_detect")]||null;
        },

        // read value from css
        readFromCss: function(className, property) {
            var t = document.createElement("DIV");
            t.className = className;
            if (document.body.firstChild != null) document.body.insertBefore(t, document.body.firstChild); else document.body.appendChild(t);
            var w = t[property||"offsetWidth"];
            t.parentNode.removeChild(t);
            t = null;
            return w;
        },

        // id manager
        lastId: 1,
        newId: function() {
            return this.lastId++;
        },

        // z-index manager
        zim: {
            data: {},
            step: 5,
            first: function() {
                return 100;
            },
            last: function() {
                var t = this.first();
                for (var a in this.data) t = Math.max(t, this.data[a]);
                return t;
            },
            reserve: function(id) {
                this.data[id] = this.last()+this.step;
                return this.data[id];
            },
            clear: function(id) {
                if (this.data[id] != null) {
                    this.data[id] = null;
                    delete this.data[id];
                }
            }
        },

        // string to boolean
        s2b: function(r) {
            return (r == true || r == 1 || r == "true" || r == "1" || r == "yes" || r == "y");
        },

        // string to json
        s2j: function(s) {
            var obj = null;
            dhx4.temp = null;
            try { eval("dhx4.temp="+s); } catch(e) { dhx4.temp = null; }
            obj = dhx4.temp;
            dhx4.temp = null;
            return obj;
        },

        // absolute top/left position on screen
        absLeft: function(obj) {
            if (typeof(obj) == "string") obj = document.getElementById(obj);
            return this.getOffset(obj).left;
        },
        absTop: function(obj) {
            if (typeof(obj) == "string") obj = document.getElementById(obj);
            return this.getOffset(obj).top;
        },
        _aOfs: function(elem) {
            var top = 0, left = 0;
            while (elem) {
                top = top + parseInt(elem.offsetTop);
                left = left + parseInt(elem.offsetLeft);
                elem = elem.offsetParent;
            }
            return {top: top, left: left};
        },
        _aOfsRect: function(elem) {
            var box = elem.getBoundingClientRect();
            var body = document.body;
            var docElem = document.documentElement;
            var scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop;
            var scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;
            var clientTop = docElem.clientTop || body.clientTop || 0;
            var clientLeft = docElem.clientLeft || body.clientLeft || 0;
            var top  = box.top +  scrollTop - clientTop;
            var left = box.left + scrollLeft - clientLeft;
            return { top: Math.round(top), left: Math.round(left) };
        },
        getOffset: function(elem) {
            if (elem.getBoundingClientRect) {
                return this._aOfsRect(elem);
            } else {
                return this._aOfs(elem);
            }
        },

        // copy obj
        _isObj: function(k) {
            return (k != null && typeof(k) == "object" && typeof(k.length) == "undefined");
        },
        _copyObj: function(r) {
            if (this._isObj(r)) {
                var t = {};
                for (var a in r) {
                    if (typeof(r[a]) == "object" && r[a] != null) t[a] = this._copyObj(r[a]); else t[a] = r[a];
                }
            } else {
                var t = [];
                for (var a=0; a<r.length; a++) {
                    if (typeof(r[a]) == "object" && r[a] != null) t[a] = this._copyObj(r[a]); else t[a] = r[a];
                }
            }
            return t;
        },

        // screen dim
        screenDim: function() {
            var isIE = (navigator.userAgent.indexOf("MSIE") >= 0);
            var dim = {};
            dim.left = document.body.scrollLeft;
            dim.right = dim.left+(window.innerWidth||document.body.clientWidth);
            dim.top = Math.max((isIE?document.documentElement:document.getElementsByTagName("html")[0]).scrollTop, document.body.scrollTop);
            dim.bottom = dim.top+(isIE?Math.max(document.documentElement.clientHeight||0,document.documentElement.offsetHeight||0):window.innerHeight);
            return dim;
        },

        // input/textarea range selection
        selectTextRange: function(inp, start, end) {

            inp = (typeof(inp)=="string"?document.getElementById(inp):inp);

            var len = inp.value.length;
            start = Math.max(Math.min(start, len), 0);
            end = Math.min(end, len);

            if (inp.setSelectionRange) {
                try {inp.setSelectionRange(start, end);} catch(e){}; // combo in grid under IE requires try/catch
            } else if (inp.createTextRange) {
                var range = inp.createTextRange();
                range.moveStart("character", start);
                range.moveEnd("character", end-len);
                try {range.select();} catch(e){};
            }
        },
        // transition
        transData: null,
        transDetect: function() {

            if (this.transData == null) {

                this.transData = {transProp: false, transEv: null};

                // transition, MozTransition, WebkitTransition, msTransition, OTransition
                var k = {
                    "MozTransition": "transitionend",
                    "WebkitTransition": "webkitTransitionEnd",
                    "OTransition": "oTransitionEnd",
                    "msTransition": "transitionend",
                    "transition": "transitionend"
                };

                for (var a in k) {
                    if (this.transData.transProp == false && document.documentElement.style[a] != null) {
                        this.transData.transProp = a;
                        this.transData.transEv = k[a];
                    }
                }
                k = null;
            }

            return this.transData;

        },

        // xml parser
        _xmlNodeValue: function(node) {
            var value = "";
            for (var q=0; q<node.childNodes.length; q++) {
                value += (node.childNodes[q].nodeValue!=null?node.childNodes[q].nodeValue.toString().replace(/^[\n\r\s]{0,}/,"").replace(/[\n\r\s]{0,}$/,""):"");
            }
            return value;
        }

    };

    // browser
    window.dhx4.isIE = (navigator.userAgent.indexOf("MSIE") >= 0 || navigator.userAgent.indexOf("Trident") >= 0);
    window.dhx4.isIE6 = (window.XMLHttpRequest == null && navigator.userAgent.indexOf("MSIE") >= 0);
    window.dhx4.isIE7 = (navigator.userAgent.indexOf("MSIE 7.0") >= 0 && navigator.userAgent.indexOf("Trident") < 0);
    window.dhx4.isIE8 = (navigator.userAgent.indexOf("MSIE 8.0") >= 0 && navigator.userAgent.indexOf("Trident") >= 0);
    window.dhx4.isOpera = (navigator.userAgent.indexOf("Opera") >= 0);
    window.dhx4.isChrome = (navigator.userAgent.indexOf("Chrome") >= 0);
    window.dhx4.isKHTML = (navigator.userAgent.indexOf("Safari") >= 0 || navigator.userAgent.indexOf("Konqueror") >= 0);
    window.dhx4.isFF = (navigator.userAgent.indexOf("Firefox") >= 0);
    window.dhx4.isIPad = (navigator.userAgent.search(/iPad/gi) >= 0);
};


if (typeof(window.dhx4.template) == "undefined") {

    // trim
    window.dhx4.trim = function(t) {
        return String(t).replace(/^\s{1,}/,"").replace(/\s{1,}$/,"");
    };

    // template parsing
    window.dhx4.template = function(tpl, data, trim) {

        // tpl - template text, #value|func:param0:param1:paramX#
        // data - object with key-value
        // trim - true/false, trim values
        return tpl.replace(/#([a-z0-9_-]{1,})(\|([^#]*))?#/gi, function(){

            var key = arguments[1];

            var t = window.dhx4.trim(arguments[3]);
            var func = null;
            var args = [data[key]];

            if (t.length > 0) {

                t = t.split(":");
                var k = [];

                // check escaped colon
                for (var q=0; q<t.length; q++) {
                    if (q > 0 && k[k.length-1].match(/\\$/) != null) {
                        k[k.length-1] = k[k.length-1].replace(/\\$/,"")+":"+t[q];
                    } else {
                        k.push(t[q]);
                    }
                }

                func = k[0];
                for (var q=1; q<k.length; q++) args.push(k[q]);

            }

            // via inner function
            if (typeof(func) == "string" && typeof(window.dhx4.template[func]) == "function") {
                return window.dhx4.template[func].apply(window.dhx4.template, args);
            }

            // value only
            if (key.length > 0 && typeof(data[key]) != "undefined") {
                if (trim == true) return window.dhx4.trim(data[key]);
                return String(data[key]);
            }

            // key not found
            return "";

        });

    };

    window.dhx4.template.date = function(value, format) {
        // Date obj + format	=> convert to string
        // timestamp + format	=> convert to string
        // string		=> no convert
        // any other value	=> empty string
        if (value != null) {
            if (value instanceof Date) {
                return window.dhx4.date2str(value, format);
            } else {
                value = value.toString();
                if (value.match(/^\d*$/) != null) return window.dhx4.date2str(new Date(parseInt(value)), format);
                return value;
            }
        }
        return "";
    };

    window.dhx4.template.maxlength = function(value, limit) {
        return String(value).substr(0, limit);
    };

    window.dhx4.template.number_format = function(value, format, group_sep, dec_sep) {
        var fmt = window.dhx4.template._parseFmt(format, group_sep, dec_sep);
        if (fmt == false) return value;
        return window.dhx4.template._getFmtValue(value, fmt);
    };

    window.dhx4.template.lowercase = function(value) {
        if (typeof(value) == "undefined" || value == null) value = "";
        return String(value).toLowerCase();
    };
    window.dhx4.template.uppercase = function(value) {
        if (typeof(value) == "undefined" || value == null) value = "";
        return String(value).toUpperCase();
    };

    // number format helpers
    window.dhx4.template._parseFmt = function(format, group_sep, dec_sep) {

        var t = format.match(/^([^\.\,0-9]*)([0\.\,]*)([^\.\,0-9]*)/);
        if (t == null || t.length != 4) return false; // invalid format

        var fmt = {
            // int group
            i_len: false,
            i_sep: (typeof(group_sep)=="string"?group_sep:","),
            // decimal
            d_len: false,
            d_sep: (typeof(dec_sep)=="string"?dec_sep:"."),
            // chars before and after
            s_bef: (typeof(t[1])=="string"?t[1]:""),
            s_aft: (typeof(t[3])=="string"?t[3]:"")
        };

        var f = t[2].split(".");
        if (f[1] != null) fmt.d_len = f[1].length;

        var r = f[0].split(",");
        if (r.length > 1) fmt.i_len = r[r.length-1].length;

        return fmt;

    };

    window.dhx4.template._getFmtValue = function(value, fmt) {

        var r = String(value).match(/^(-)?([0-9]{1,})(\.([0-9]{1,}))?$/); // r = [complete value, minus sign, integer, full decimal, decimal]

        if (r != null && r.length == 5) {
            var v0 = "";
            // minus sign
            if (r[1] != null) v0 += r[1];
            // chars before
            v0 += fmt.s_bef;
            // int part
            if (fmt.i_len !== false) {
                var i = 0; var v1 = "";
                for (var q=r[2].length-1; q>=0; q--) {
                    v1 = ""+r[2].charAt(q)+v1;
                    if (++i == fmt.i_len && q > 0) { v1=fmt.i_sep+v1; i=0; }
                }
                v0 += v1;
            } else {
                v0 += r[2];
            }
            // dec part
            if (fmt.d_len !== false) {
                if (r[4] == null) r[4] = "";
                while (r[4].length < fmt.d_len) r[4] += "0";
                eval("dhx4.temp = new RegExp(/\\d{"+fmt.d_len+"}/);");
                var t1 = (r[4]).match(dhx4.temp);
                if (t1 != null) v0 += fmt.d_sep+t1;
                dhx4.temp = t1 = null;
            }
            // chars after
            v0 += fmt.s_aft;

            return v0;
        }

        return value;
    };

};

if (typeof(window.dhx4.dateLang) == "undefined") {

    window.dhx4.dateLang = "en";
    window.dhx4.dateStrings = {
        en: {
            monthFullName:	["January","February","March","April","May","June","July","August","September","October","November","December"],
            monthShortName:	["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],
            dayFullName:	["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],
            dayShortName:	["Su","Mo","Tu","We","Th","Fr","Sa"]
        }
    };
    window.dhx4.dateFormat = {
        en: "%Y-%m-%d"
    };

    window.dhx4.date2str = function(val, format, strings) {

        if (format == null || typeof(format) == "undefnied") format = window.dhx4.dateFormat[window.dhx4.dateLang];
        if (strings == null || typeof(strings) == "undefnied") strings = window.dhx4.dateStrings[window.dhx4.dateLang];

        if (val instanceof Date) {
            var z = function(t) {
                return (String(t).length==1?"0"+String(t):t);
            }
            var k = function(t) {
                switch(t) {
                    case "%d": return z(val.getDate());
                    case "%j": return val.getDate();
                    case "%D": return strings.dayShortName[val.getDay()];
                    case "%l": return strings.dayFullName[val.getDay()];
                    case "%m": return z(val.getMonth()+1);
                    case "%n": return val.getMonth()+1;
                    case "%M": return strings.monthShortName[val.getMonth()];
                    case "%F": return strings.monthFullName[val.getMonth()];
                    case "%y": return z(val.getYear()%100);
                    case "%Y": return val.getFullYear();
                    case "%g": return (val.getHours()+11)%12+1;
                    case "%h": return z((val.getHours()+11)%12+1);
                    case "%G": return val.getHours();
                    case "%H": return z(val.getHours());
                    case "%i": return z(val.getMinutes());
                    case "%s": return z(val.getSeconds());
                    case "%a": return (val.getHours()>11?"pm":"am");
                    case "%A": return (val.getHours()>11?"PM":"AM");
                    case "%%": return "%";
                    case "%u": return val.getMilliseconds();
                    case "%P":
                        if (window.dhx4.temp_calendar != null && window.dhx4.temp_calendar.tz != null) return window.dhx4.temp_calendar.tz;
                        var ofs = val.getTimezoneOffset();
                        var h = Math.abs(Math.floor(ofs/60));
                        var m = Math.abs(ofs)-h*60;
                        return (ofs>0?"-":"+")+z(h)+":"+z(m);
                    default: return t;
                }
            }
            var t = String(format||window.dhx4.dateFormat).replace(/%[a-zA-Z]/g, k);
        }

        return (t||String(val));

    };

    window.dhx4.str2date = function(val, format, strings) {

        if (format == null || typeof(format) == "undefnied") format = window.dhx4.dateFormat[window.dhx4.dateLang];
        if (strings == null || typeof(strings) == "undefnied") strings = window.dhx4.dateStrings[window.dhx4.dateLang];

        // escape custom chars
        format = format.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\\:|]/g, "\\$&");

        var v = [];
        var f = [];

        // escape required chars
        format = format.replace(/%[a-z]/gi, function(t){
            switch (t) {
                case "%d": case "%m": case "%y": case "%h": case "%H": case "%i": case "%s": f.push(t); return "(\\d{2})"; // 2 digits
                case "%D": case "%l": case "%M": case "%F": f.push(t); return "([a-zéûä\u0430-\u044F\u0451]{1,})"; // chars
                case "%j": case "%n": case "%g": case "%G": f.push(t); return "(\\d{1,2})"; // 1-2 digits
                case "%Y": f.push(t); return "(\\d{4})"; // 4 digits
                case "%a": f.push(t); return "([am|pm])"; // am/pm
                case "%A": f.push(t); return "([AM|PM])"; // AM/PM
                case "%u": f.push(t); return "(\\d{1,6})"; // 1-6 digits, micro/milliseconds
                case "%P": f.push(t); return "([+-]\\d{1,2}:\\d{1,2})"; // zone offset
            }
            return t;
        });

        var re = new RegExp(format, "i");
        var e = val.match(re);

        if (e == null || e.length-1 != f.length) return "Invalid Date";

        // sorting
        /*
		Year	y,Y	1
		Month	n,m,M,F	2
		Day	d,j	3
		AM/PM	a,A	4
		Hours	H,G,h,g	5
		Minutes	i	6
		Seconds	s	7
		MSec	u	7
		Zone 	P	7
		*/

        for (var q=1; q<e.length; q++) v.push(e[q]);

        var p = {"%y":1,"%Y":1,"%n":2,"%m":2,"%M":2,"%F":2,"%d":3,"%j":3,"%a":4,"%A":4,"%H":5,"%G":5,"%h":5,"%g":5,"%i":6,"%s":7,"%u":7,"%P":7};
        var v2 = {};
        var f2 = {};
        for (var q=0; q<f.length; q++) {
            if (typeof(p[f[q]]) != "undefined") {
                var ind = p[f[q]];
                if (!v2[ind]){v2[ind]=[];f2[ind]=[];}
                v2[ind].push(v[q]);
                f2[ind].push(f[q]);
            }
        }
        v = [];
        f = [];
        for (var q=1; q<=7; q++) {
            if (v2[q] != null) {
                for (var w=0; w<v2[q].length; w++) {
                    v.push(v2[q][w]);
                    f.push(f2[q][w]);
                }
            }
        }

        // parsing date
        var r = new Date();
        r.setDate(1); // fix for 31th
        r.setHours(0);
        r.setMinutes(0);
        r.setSeconds(0);
        r.setMilliseconds(0);

        // get index by value
        var getInd = function(val, ar) {
            for (var q=0; q<ar.length; q++) if (ar[q].toLowerCase() == val) return q;
            return -1;
        }

        for (var q=0; q<v.length; q++) {
            switch (f[q]) {
                case "%d": case "%j": case "%n": case "%m": case "%Y": case "%H": case "%G": case "%i": case "%s": case "%u":
                    if (!isNaN(v[q])) r[{"%d":"setDate","%j":"setDate","%n":"setMonth","%m":"setMonth","%Y":"setFullYear","%H":"setHours","%G":"setHours","%i":"setMinutes","%s":"setSeconds","%u":"setMilliseconds"}[f[q]]](Number(v[q])+(f[q]=="%m"||f[q]=="%n"?-1:0));
                    break;
                //
                case "%M": case "%F":
                    var k = getInd(v[q].toLowerCase(),strings[{"%M":"monthShortName","%F":"monthFullName"}[f[q]]]);
                    if (k >= 0) r.setMonth(k);
                    break;
                //
                case "%y":
                    if (!isNaN(v[q])) {
                        var v0 = Number(v[q]);
                        r.setFullYear(v0+(v0>50?1900:2000));
                    }
                    break;
                //
                case "%g": case "%h":
                    if (!isNaN(v[q])) {
                        var v0 = Number(v[q]);
                        if (v0 <= 12 && v0 >= 0) r.setHours(v0+(getInd("pm",v)>=0?(v0==12?0:12):(v0==12?-12:0))); // 12:00 AM -> midnight, 12:00 PM -> noon
                    }
                    break;
                //
                case "%P":
                    if (window.dhx4.temp_calendar != null) {
                        window.dhx4.temp_calendar.tz = v[q];
                    }
                    break;
            }
        }
        return r;
    };

};

if (typeof(window.dhx4.ajax) == "undefined") {

    window.dhx4.ajax = {

        // if false - dhxr param will added to prevent caching on client side (default),
        // if true - do not add extra params
        cache: false,

        // default method for load/loadStruct, post/get allowed
        // get - since 4.1.1, this should fix 412 error for macos safari
        method: "get",

        parse: function(data) {
            data = data.replace(/^[\s]+/,"");
            if (window.DOMParser && !dhx4.isIE) { // ff,ie9
                var obj = (new window.DOMParser()).parseFromString(data, "text/xml");
            } else if (typeof(window.ActiveXObject) != "undefined") {
                var obj = new window.ActiveXObject("Microsoft.XMLDOM");
                obj.async = "false";
                obj.loadXML(data);
            }
            return obj;
        },
        xmltop: function(tagname, xhr, obj) {
            if (typeof xhr.status == "undefined" || xhr.status < 400) {
                xml = (!xhr.responseXML) ? dhx4.ajax.parse(xhr.responseText || xhr) : (xhr.responseXML || xhr);
                if (xml && xml.documentElement !== null && !xml.getElementsByTagName("parsererror").length)
                    return xml.getElementsByTagName(tagname)[0];
            }

            dhx4.callEvent("onLoadXMLError",["Incorrect XML", arguments[1], obj ]);
            return document.createElement("DIV");
        },
        xpath: function(xpathExp, docObj) {
            if (dhx4.isIE)
                return docObj.selectNodes(xpathExp)||[];
            else {
                var rows = [], first;
                var col = (docObj.ownerDocument||docObj).evaluate(xpathExp, docObj, null, XPathResult.ANY_TYPE, null);
                while (first = col.iterateNext())
                    rows.push(first);
                return rows;
            }
        },
        query:function(config){
            dhx4.ajax._call(
                (config.method || "GET"),
                config.url,
                config.data || "",
                (config.async || true),
                config.callback,
                null,
                config.headers
            );
        },
        get: function(url, onLoad) {
            this._call("GET", url, null, true, onLoad);
        },
        getSync: function(url) {
            return this._call("GET", url, null, false);
        },
        put: function(url, postData, onLoad) {
            this._call("PUT", url, postData, true, onLoad);
        },
        del: function(url, postData, onLoad) {
            this._call("DELETE", url, postData, true, onLoad);
        },
        post: function(url, postData, onLoad) {
            if (arguments.length == 1) {
                postData = "";
            } else if (arguments.length == 2 && (typeof(postData) == "function" || typeof(window[postData]) == "function")) {
                onLoad = postData;
                postData = "";
            } else {
                postData = String(postData);
            }
            this._call("POST", url, postData, true, onLoad);
        },
        postSync: function(url, postData) {
            postData = (postData == null ? "" : String(postData));
            return this._call("POST", url, postData, false);
        },
        getLong: function(url, onLoad) {
            this._call("GET", url, null, true, onLoad, {url:url});
        },
        postLong: function(url, postData, onLoad) {
            if (arguments.length == 2 && (typeof(postData) == "function" || typeof(window[postData]))) {
                onLoad = postData;
                postData = "";
            }
            this._call("POST", url, postData, true, onLoad, {url:url, postData:postData});
        },
        _call: function(method, url, postData, async, onLoad, longParams, headers) {

            var t = (window.XMLHttpRequest && !dhx4.isIE ? new XMLHttpRequest() : new ActiveXObject("Microsoft.XMLHTTP"));
            var isQt = (navigator.userAgent.match(/AppleWebKit/) != null && navigator.userAgent.match(/Qt/) != null && navigator.userAgent.match(/Safari/) != null);

            if (async == true) {
                t.onreadystatechange = function() {
                    if ((t.readyState == 4) || (isQt == true && t.readyState == 3)) { // what for long response and status 404?
                        if (t.status != 200 || t.responseText == "")
                            if (!dhx4.callEvent("onAjaxError", [t])) return;

                        window.setTimeout(function(){
                            if (typeof(onLoad) == "function") {
                                onLoad.apply(window, [{xmlDoc:t}]); // dhtmlx-compat, response.xmlDoc.responseXML/responseText
                            }
                            if (longParams != null) {
                                if (typeof(longParams.postData) != "undefined") {
                                    dhx4.ajax.postLong(longParams.url, longParams.postData, onLoad);
                                } else {
                                    dhx4.ajax.getLong(longParams.url, onLoad);
                                }
                            }
                            onLoad = null;
                            t = null;
                        },1);
                    }
                }
            }

            if (method == "GET" && this.cache != true) {
                url += (url.indexOf("?")>=0?"&":"?")+"dhxr"+new Date().getTime()+"=1";
            }

            t.open(method, url, async);

            if (headers){
                for (var key in headers)
                    t.setRequestHeader(key, headers[key]);
            } else if (method == "POST") {
                t.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
            } else if (method == "GET") {
                postData = null;
            }

            t.setRequestHeader("X-Requested-With", "XMLHttpRequest");

            t.send(postData);

            if (!async) return {xmlDoc:t}; // dhtmlx-compat, response.xmlDoc.responseXML/responseText

        }
    };

};

if (typeof(window.dhx4._enableDataLoading) == "undefined") {

    window.dhx4._enableDataLoading = function(obj, initObj, xmlToJson, xmlRootTag, mode) {

        if (mode == "clear") {

            // clear attached functionality

            for (var a in obj._dhxdataload) {
                obj._dhxdataload[a] = null;
                delete obj._dhxdataload[a];
            };

            obj._loadData = null;
            obj._dhxdataload = null;
            obj.load = null;
            obj.loadStruct = null;

            obj = null;

            return;

        }

        obj._dhxdataload = { // move to obj.conf?
            initObj: initObj,
            xmlToJson: xmlToJson,
            xmlRootTag: xmlRootTag,
            onBeforeXLS: null
        };

        obj._loadData = function(data, loadParams, onLoad) {

            if (arguments.length == 2) {
                onLoad = loadParams;
                loadParams = null;
            }

            var obj = null;

            // deprecated from 4.0, compatability with version (url, type[json|xml], onLoad)
            if (arguments.length == 3) onLoad = arguments[2];

            if (typeof(data) == "string") {

                var k = data.replace(/^\s{1,}/,"").replace(/\s{1,}$/,"");

                var tag = new RegExp("^<"+this._dhxdataload.xmlRootTag);

                // xml
                if (tag.test(k.replace(/^<\?xml[^\?]*\?>\s*/, ""))) { // remove leading <?xml ...?> if any, \n can be also presenе
                    obj = dhx4.ajax.parse(data);
                    if (obj != null) obj = this[this._dhxdataload.xmlToJson].apply(this, [obj]); // xml to json
                }

                if (obj == null && (k.match(/^\{.*\}$/) != null || k.match(/^\[.*\]$/) != null)) {
                    obj = dhx4.s2j(k);
                }

                if (obj == null) {

                    this.callEvent("onXLS",[]);

                    var params = [];

                    // allow to modify url and add params
                    if (typeof(this._dhxdataload.onBeforeXLS) == "function") {
                        var k = this._dhxdataload.onBeforeXLS.apply(this,[data]);
                        if (k != null && typeof(k) == "object") {
                            if (k.url != null) data = k.url;
                            if (k.params != null) { for (var a in k.params) params.push(a+"="+encodeURIComponent(k.params[a])); }
                        }
                    }

                    var t = this;
                    var callBack = function(r) {

                        var obj = null;

                        if ((r.xmlDoc.getResponseHeader("Content-Type")||"").search(/xml/gi) >= 0 || (r.xmlDoc.responseText.replace(/^\s{1,}/,"")).match(/^</) != null) {
                            obj = t[t._dhxdataload.xmlToJson].apply(t,[r.xmlDoc.responseXML]);
                        } else {
                            obj = dhx4.s2j(r.xmlDoc.responseText);
                        }

                        // init
                        if (obj != null) t[t._dhxdataload.initObj].apply(t,[obj,data]); // data => url

                        t.callEvent("onXLE",[]);

                        if (onLoad != null) {
                            if (typeof(onLoad) == "function") {
                                onLoad.apply(t,[]);
                            } else if (typeof(window[onLoad]) == "function") {
                                window[onLoad].apply(t,[]);
                            }
                        }

                        callBack = onLoad = null;
                        obj = r = t = null;

                    };

                    params = params.join("&")+(typeof(loadParams)=="string"?"&"+loadParams:"");

                    if (dhx4.ajax.method == "post") {
                        dhx4.ajax.post(data, params, callBack);
                    } else if (dhx4.ajax.method == "get") {
                        dhx4.ajax.get(data+(data.indexOf("?")>0?"&":"?")+params, callBack);
                    }

                    return;
                }

            } else {
                if (typeof(data.documentElement) == "object" || (typeof(data.tagName) != "undefined" && typeof(data.getElementsByTagName) != "undefined" && data.getElementsByTagName(this._dhxdataload.xmlRootTag).length > 0)) { // xml
                    obj = this[this._dhxdataload.xmlToJson].apply(this, [data]);
                } else { // json
                    obj = window.dhx4._copyObj(data);
                }

            }

            // init
            if (obj != null) this[this._dhxdataload.initObj].apply(this,[obj]);

            if (onLoad != null) {
                if (typeof(onLoad) == "function") {
                    onLoad.apply(this, []);
                } else if (typeof(window[onLoad]) == "function") {
                    window[onLoad].apply(this, []);
                }
                onLoad = null;
            }

        };

        // loadStruct for hdr/conf
        // load for data
        if (mode != null) {
            var k = {struct: "loadStruct", data: "load"};
            for (var a in mode) {
                if (mode[a] == true) obj[k[a]] = function() {return this._loadData.apply(this, arguments);}
            }
        }

        obj = null;

    };
};

if (typeof(window.dhx4._eventable) == "undefined") {

    window.dhx4._eventable = function(obj, mode) {

        if (mode == "clear") {

            obj.detachAllEvents();

            obj.dhxevs = null;

            obj.attachEvent = null;
            obj.detachEvent = null;
            obj.checkEvent = null;
            obj.callEvent = null;
            obj.detachAllEvents = null;

            obj = null;

            return;

        }

        obj.dhxevs = { data: {} };

        obj.attachEvent = function(name, func) {
            name = String(name).toLowerCase();
            if (!this.dhxevs.data[name]) this.dhxevs.data[name] = {};
            var eventId = window.dhx4.newId();
            this.dhxevs.data[name][eventId] = func;
            return eventId;
        }

        obj.detachEvent = function(eventId) {
            for (var a in this.dhxevs.data) {
                var k = 0;
                for (var b in this.dhxevs.data[a]) {
                    if (b == eventId) {
                        this.dhxevs.data[a][b] = null;
                        delete this.dhxevs.data[a][b];
                    } else {
                        k++;
                    }
                }
                if (k == 0) {
                    this.dhxevs.data[a] = null;
                    delete this.dhxevs.data[a];
                }
            }
        }

        obj.checkEvent = function(name) {
            name = String(name).toLowerCase();
            return (this.dhxevs.data[name] != null);
        }

        obj.callEvent = function(name, params) {
            name = String(name).toLowerCase();
            if (this.dhxevs.data[name] == null) return true;
            var r = true;
            for (var a in this.dhxevs.data[name]) {
                r = this.dhxevs.data[name][a].apply(this, params) && r;
            }
            return r;
        }

        obj.detachAllEvents = function() {
            for (var a in this.dhxevs.data) {
                for (var b in this.dhxevs.data[a]) {
                    this.dhxevs.data[a][b] = null;
                    delete this.dhxevs.data[a][b];
                }
                this.dhxevs.data[a] = null;
                delete this.dhxevs.data[a];
            }
        }

        obj = null;
    };


    dhx4._eventable(dhx4);

};

if (typeof(window.dhtmlx) == "undefined") {
    window.dhtmlx={
        extend:function(a, b){
            for (var key in b)
                if (!a[key])
                    a[key]=b[key];
            return a;
        },
        extend_api:function(name,map,ext){
            var t = window[name];
            if (!t) return; //component not defined
            window[name]=function(obj){
                if (obj && typeof obj == "object" && !obj.tagName){
                    var that = t.apply(this,(map._init?map._init(obj):arguments));
                    //global settings
                    for (var a in dhtmlx)
                        if (map[a]) this[map[a]](dhtmlx[a]);
                    //local settings
                    for (var a in obj){
                        if (map[a]) this[map[a]](obj[a]);
                        else if (a.indexOf("on")===0){
                            this.attachEvent(a,obj[a]);
                        }
                    }
                } else
                    var that = t.apply(this,arguments);
                if (map._patch) map._patch(this);
                return that||this;
            };
            window[name].prototype=t.prototype;
            if (ext)
                dhtmlx.extend(window[name].prototype,ext);
        },
        url:function(str){
            if (str.indexOf("?") != -1)
                return "&";
            else
                return "?";
        }
    };
};

/**
 *     @desc: find out what symbol to use as url param delimiters in further params
 *     @type: private
 *     @param: str - current url string
 *     @topic: 0
 */


function dhtmlDragAndDropObject(){
    if (window.dhtmlDragAndDrop)
        return window.dhtmlDragAndDrop;

    this.lastLanding=0;
    this.dragNode=0;
    this.dragStartNode=0;
    this.dragStartObject=0;
    this.tempDOMU=null;
    this.tempDOMM=null;
    this.waitDrag=0;
    window.dhtmlDragAndDrop=this;

    return this;
};

dhtmlDragAndDropObject.prototype.removeDraggableItem=function(htmlNode){
    htmlNode.onmousedown=null;
    htmlNode.dragStarter=null;
    htmlNode.dragLanding=null;
}
dhtmlDragAndDropObject.prototype.addDraggableItem=function(htmlNode, dhtmlObject){
    htmlNode.onmousedown=this.preCreateDragCopy;
    htmlNode.dragStarter=dhtmlObject;
    this.addDragLanding(htmlNode, dhtmlObject);
}
dhtmlDragAndDropObject.prototype.addDragLanding=function(htmlNode, dhtmlObject){
    htmlNode.dragLanding=dhtmlObject;
}
dhtmlDragAndDropObject.prototype.preCreateDragCopy=function(e){
    if ((e||window.event) && (e||event).button == 2)
        return;

    if (window.dhtmlDragAndDrop.waitDrag){
        window.dhtmlDragAndDrop.waitDrag=0;
        document.body.onmouseup=window.dhtmlDragAndDrop.tempDOMU;
        document.body.onmousemove=window.dhtmlDragAndDrop.tempDOMM;
        return false;
    }

    if (window.dhtmlDragAndDrop.dragNode)
        window.dhtmlDragAndDrop.stopDrag(e);

    window.dhtmlDragAndDrop.waitDrag=1;
    window.dhtmlDragAndDrop.tempDOMU=document.body.onmouseup;
    window.dhtmlDragAndDrop.tempDOMM=document.body.onmousemove;
    window.dhtmlDragAndDrop.dragStartNode=this;
    window.dhtmlDragAndDrop.dragStartObject=this.dragStarter;
    document.body.onmouseup=window.dhtmlDragAndDrop.preCreateDragCopy;
    document.body.onmousemove=window.dhtmlDragAndDrop.callDrag;
    window.dhtmlDragAndDrop.downtime = new Date().valueOf();


    if ((e)&&(e.preventDefault)){
        e.preventDefault();
        return false;
    }
    return false;
};
dhtmlDragAndDropObject.prototype.callDrag=function(e){
    if (!e)
        e=window.event;
    dragger=window.dhtmlDragAndDrop;
    if ((new Date()).valueOf()-dragger.downtime<100) return;

    //if ((e.button == 0)&&(_isIE))
    //	return dragger.stopDrag();

    if (!dragger.dragNode){
        if (dragger.waitDrag){
            dragger.dragNode=dragger.dragStartObject._createDragNode(dragger.dragStartNode, e);

            if (!dragger.dragNode)
                return dragger.stopDrag();

            dragger.dragNode.onselectstart=function(){return false;}
            dragger.gldragNode=dragger.dragNode;
            document.body.appendChild(dragger.dragNode);
            document.body.onmouseup=dragger.stopDrag;
            dragger.waitDrag=0;
            dragger.dragNode.pWindow=window;
            dragger.initFrameRoute();
        }
        else return dragger.stopDrag(e, true);
    }

    if (dragger.dragNode.parentNode != window.document.body && dragger.gldragNode){
        var grd = dragger.gldragNode;

        if (dragger.gldragNode.old)
            grd=dragger.gldragNode.old;

        //if (!document.all) dragger.calculateFramePosition();
        grd.parentNode.removeChild(grd);
        var oldBody = dragger.dragNode.pWindow;

        if (grd.pWindow &&	grd.pWindow.dhtmlDragAndDrop.lastLanding)
            grd.pWindow.dhtmlDragAndDrop.lastLanding.dragLanding._dragOut(grd.pWindow.dhtmlDragAndDrop.lastLanding);

        //		var oldp=dragger.dragNode.parentObject;
        if (_isIE){
            var div = document.createElement("Div");
            div.innerHTML=dragger.dragNode.outerHTML;
            dragger.dragNode=div.childNodes[0];
        } else
            dragger.dragNode=dragger.dragNode.cloneNode(true);

        dragger.dragNode.pWindow=window;
        //		dragger.dragNode.parentObject=oldp;

        dragger.gldragNode.old=dragger.dragNode;
        document.body.appendChild(dragger.dragNode);
        oldBody.dhtmlDragAndDrop.dragNode=dragger.dragNode;
    }

    dragger.dragNode.style.left=e.clientX+15+(dragger.fx
        ? dragger.fx*(-1)
        : 0)
        +(document.body.scrollLeft||document.documentElement.scrollLeft)+"px";
    dragger.dragNode.style.top=e.clientY+3+(dragger.fy
        ? dragger.fy*(-1)
        : 0)
        +(document.body.scrollTop||document.documentElement.scrollTop)+"px";

    if (!e.srcElement)
        var z = e.target;
    else
        z=e.srcElement;
    dragger.checkLanding(z, e);
}

dhtmlDragAndDropObject.prototype.calculateFramePosition=function(n){
    //this.fx = 0, this.fy = 0;
    if (window.name){
        var el = parent.frames[window.name].frameElement.offsetParent;
        var fx = 0;
        var fy = 0;

        while (el){
            fx+=el.offsetLeft;
            fy+=el.offsetTop;
            el=el.offsetParent;
        }

        if ((parent.dhtmlDragAndDrop)){
            var ls = parent.dhtmlDragAndDrop.calculateFramePosition(1);
            fx+=ls.split('_')[0]*1;
            fy+=ls.split('_')[1]*1;
        }

        if (n)
            return fx+"_"+fy;
        else
            this.fx=fx;
        this.fy=fy;
    }
    return "0_0";
}
dhtmlDragAndDropObject.prototype.checkLanding=function(htmlObject, e){
    if ((htmlObject)&&(htmlObject.dragLanding)){
        if (this.lastLanding)
            this.lastLanding.dragLanding._dragOut(this.lastLanding);
        this.lastLanding=htmlObject;
        this.lastLanding=this.lastLanding.dragLanding._dragIn(this.lastLanding, this.dragStartNode, e.clientX,
            e.clientY, e);
        this.lastLanding_scr=(_isIE ? e.srcElement : e.target);
    } else {
        if ((htmlObject)&&(htmlObject.tagName != "BODY"))
            this.checkLanding(htmlObject.parentNode, e);
        else {
            if (this.lastLanding)
                this.lastLanding.dragLanding._dragOut(this.lastLanding, e.clientX, e.clientY, e);
            this.lastLanding=0;

            if (this._onNotFound)
                this._onNotFound();
        }
    }
}
dhtmlDragAndDropObject.prototype.stopDrag=function(e, mode){
    dragger=window.dhtmlDragAndDrop;

    if (!mode){
        dragger.stopFrameRoute();
        var temp = dragger.lastLanding;
        dragger.lastLanding=null;

        if (temp)
            temp.dragLanding._drag(dragger.dragStartNode, dragger.dragStartObject, temp, (_isIE
                ? event.srcElement
                : e.target));
    }
    dragger.lastLanding=null;

    if ((dragger.dragNode)&&(dragger.dragNode.parentNode == document.body))
        dragger.dragNode.parentNode.removeChild(dragger.dragNode);
    dragger.dragNode=0;
    dragger.gldragNode=0;
    dragger.fx=0;
    dragger.fy=0;
    dragger.dragStartNode=0;
    dragger.dragStartObject=0;
    document.body.onmouseup=dragger.tempDOMU;
    document.body.onmousemove=dragger.tempDOMM;
    dragger.tempDOMU=null;
    dragger.tempDOMM=null;
    dragger.waitDrag=0;
}

dhtmlDragAndDropObject.prototype.stopFrameRoute=function(win){
    if (win)
        window.dhtmlDragAndDrop.stopDrag(1, 1);

    for (var i = 0; i < window.frames.length; i++){
        try{
            if ((window.frames[i] != win)&&(window.frames[i].dhtmlDragAndDrop))
                window.frames[i].dhtmlDragAndDrop.stopFrameRoute(window);
        } catch(e){}
    }

    try{
        if ((parent.dhtmlDragAndDrop)&&(parent != window)&&(parent != win))
            parent.dhtmlDragAndDrop.stopFrameRoute(window);
    } catch(e){}
}
dhtmlDragAndDropObject.prototype.initFrameRoute=function(win, mode){
    if (win){
        window.dhtmlDragAndDrop.preCreateDragCopy();
        window.dhtmlDragAndDrop.dragStartNode=win.dhtmlDragAndDrop.dragStartNode;
        window.dhtmlDragAndDrop.dragStartObject=win.dhtmlDragAndDrop.dragStartObject;
        window.dhtmlDragAndDrop.dragNode=win.dhtmlDragAndDrop.dragNode;
        window.dhtmlDragAndDrop.gldragNode=win.dhtmlDragAndDrop.dragNode;
        window.document.body.onmouseup=window.dhtmlDragAndDrop.stopDrag;
        window.waitDrag=0;

        if (((!_isIE)&&(mode))&&((!_isFF)||(_FFrv < 1.8)))
            window.dhtmlDragAndDrop.calculateFramePosition();
    }
    try{
        if ((parent.dhtmlDragAndDrop)&&(parent != window)&&(parent != win))
            parent.dhtmlDragAndDrop.initFrameRoute(window);
    }catch(e){}

    for (var i = 0; i < window.frames.length; i++){
        try{
            if ((window.frames[i] != win)&&(window.frames[i].dhtmlDragAndDrop))
                window.frames[i].dhtmlDragAndDrop.initFrameRoute(window, ((!win||mode) ? 1 : 0));
        } catch(e){}
    }
}

_isFF = false;
_isIE = false;
_isOpera = false;
_isKHTML = false;
_isMacOS = false;
_isChrome = false;
_FFrv = false;
_KHTMLrv = false;
_OperaRv = false;

if (navigator.userAgent.indexOf('Macintosh') != -1)
    _isMacOS=true;


if (navigator.userAgent.toLowerCase().indexOf('chrome')>-1)
    _isChrome=true;

if ((navigator.userAgent.indexOf('Safari') != -1)||(navigator.userAgent.indexOf('Konqueror') != -1)){
    _KHTMLrv = parseFloat(navigator.userAgent.substr(navigator.userAgent.indexOf('Safari')+7, 5));

    if (_KHTMLrv > 525){ //mimic FF behavior for Safari 3.1+
        _isFF=true;
        _FFrv = 1.9;
    } else
        _isKHTML=true;
} else if (navigator.userAgent.indexOf('Opera') != -1){
    _isOpera=true;
    _OperaRv=parseFloat(navigator.userAgent.substr(navigator.userAgent.indexOf('Opera')+6, 3));
}


else if (navigator.appName.indexOf("Microsoft") != -1){
    _isIE=true;
    if ((navigator.appVersion.indexOf("MSIE 8.0")!= -1 ||
        navigator.appVersion.indexOf("MSIE 9.0")!= -1 ||
        navigator.appVersion.indexOf("MSIE 10.0")!= -1 ||
        document.documentMode > 7) &&
        document.compatMode != "BackCompat"){
        _isIE=8;
    }
} else if (navigator.appName  == 'Netscape' && navigator.userAgent.indexOf("Trident") != -1){
    //ie11
    _isIE=8;
} else {
    _isFF=true;
    _FFrv = parseFloat(navigator.userAgent.split("rv:")[1])
}

if (typeof(window.dhtmlxEvent) == "undefined") {

    function dhtmlxEvent(el, event, handler){
        if (el.addEventListener)
            el.addEventListener(event, handler, false);

        else if (el.attachEvent)
            el.attachEvent("on"+event, handler);
    }
};

if (dhtmlxEvent.touchDelay == null) {
    dhtmlxEvent.touchDelay = 2000;
};

if (typeof(dhtmlxEvent.initTouch) == "undefined") {

    dhtmlxEvent.initTouch = function(){
        var longtouch;
        var target;
        var tx, ty;

        dhtmlxEvent(document.body, "touchstart", function(ev){
            target = ev.touches[0].target;
            tx = ev.touches[0].clientX;
            ty = ev.touches[0].clientY;
            longtouch = window.setTimeout(touch_event, dhtmlxEvent.touchDelay);
        });
        function touch_event(){
            if (target){
                var ev = document.createEvent("HTMLEvents"); // for chrome and firefox
                ev.initEvent("dblclick", true, true);
                target.dispatchEvent(ev);
                longtouch = target = null;
            }
        };
        dhtmlxEvent(document.body, "touchmove", function(ev){
            if (longtouch){
                if (Math.abs(ev.touches[0].clientX - tx) > 50 || Math.abs(ev.touches[0].clientY - ty) > 50 ){
                    window.clearTimeout(longtouch);
                    longtouch = target = false;
                }
            }
        });
        dhtmlxEvent(document.body, "touchend", function(ev){
            if (longtouch){
                window.clearTimeout(longtouch);
                longtouch = target = false;
            }
        });

        dhtmlxEvent.initTouch = function(){};
    };
};
/*
Product Name: dhtmlxSuite
Version: 4.1.2
Edition: Standard
License: content of this file is covered by GPL. Usage outside GPL terms is prohibited. To obtain Commercial or Enterprise license contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXMenuObject(base, skin) {

    var that = this;

    // iframe
    this.conf = {
        skin: (skin||window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhxmenu")||"dhx_skyblue"),
        mode: "web",
        align: "right" /*r.ghafari*/,
        is_touched: false,
        selected: -1,
        last_click: -1,
        fixed_pos: false, // should be used for frameset in IE
        rtl: false,
        icons_path: "",
        arrow_ff_fix: (navigator.userAgent.indexOf("MSIE") >= 0 && document.compatMode=="BackCompat"), // border fixer for FF for arrows polygons
        live_id: window.dhx4.newId(),
        tags: {
            root: "menu",
            item: "item",
            text_ext: "itemtext",
            userdata: "userdata",
            tooltip: "tooltip",
            hotkey: "hotkey",
            href: "href"
        },
        autoload: {},
        hide_tm: {},
        // shows sublevel polygons from toplevel items with delay
        top_mode: true,
        top_tmtime: 200,
        // visible area
        v_enabled: false,
        v: {x1: null, x2: null, y1: null, y2: null},
        // open direction
        dir_toplv: "bottom",
        dir_sublv: "right",
        // overflow
        auto_overflow: false,
        overflow_limit: 0,
        of_utm: null, // scroll up - tm
        of_utime: 20, // scroll up - time
        of_ustep: 3, // scroll up - step
        of_dtm: null,
        of_dtime: 20,
        of_dstep: 3,
        // hide
        tm_sec: 400,
        tm_handler: null,
        // dyn load
        dload: false,
        dload_url: "",
        dload_icon: false, // show loading icon
        dload_params: {action: "loadMenu"}, // extra params
        dload_pid: "parentId", // parentId param name
        // skinbased offsets
        tl_botmarg: 1, // top level bottom margin
        tl_rmarg: 0, // right margin
        tl_ofsleft: 1, // offset left
        // context menu
        context: false,
        ctx_zoneid: false,
        ctx_autoshow: true, // default open action
        ctx_autohide: true, // default close action
        ctx_hideall: true, // true will hide all opened contextual menu polygons on mouseout, false - all except topleft
        ctx_zones: {},
        ctx_baseid: null, // add baseId as context zone
        // selected subitems
        selected_sub: [],
        opened_poly: []
    }

    if (typeof(base) == "object" && base != null && typeof(base.tagName) == "undefined") {

        // object-api init
        if (base.icons_path != null || base.icon_path != null) this.conf.icons_path = (base.icons_path||base.icon_path);
        if (base.skin != null) this.conf.skin = base.skin;
        if (base.visible_area) {
            this.conf.v_enabled = true;
            this.conf.v = {
                x1: base.visible_area.x1,
                x2: base.visible_area.x2,
                y1: base.visible_area.y1,
                y2: base.visible_area.y2
            };
        }

        for (var a in {json:1,xml:1,items:1,top_text:1,align:1,open_mode:1,overflow:1,dynamic:1,dynamic_icon:1,context:1,onload:1,onclick:1,oncheckboxclick:1,onradioclick:1}) {
            if (base[a] != null) this.conf.autoload[a] = base[a];
        }

        base = base.parent;
    }

    if (base == null) {
        this.base = document.body;
    } else {
        var baseObj = (typeof(base)=="string"?document.getElementById(base):base);
        if (baseObj != null) {
            this.base = baseObj;
            if (!this.base.id) this.base.id = (new Date()).valueOf();
            this.base.className += " dhtmlxMenu_"+this.conf.skin+"_Middle dir_left";
            this.base._autoSkinUpdate = true;
            // preserv default oncontextmenu for future restorin in case of context menu
            if (this.base.oncontextmenu) this.base._oldContextMenuHandler = this.base.oncontextmenu;
            //
            this.conf.ctx_baseid = this.base.id;
            this.base.onselectstart = function(e) { e = e || event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
            this.base.oncontextmenu = function(e) { e = e || event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
        } else {
            this.base = document.body;
        }
    }

    this.idPrefix = "";
    this.topId = "dhxWebMenuTopId";

    this.idPull = {};
    this.itemPull = {};
    this.userData = {};
    this.radio = {};
    //
    this.setSkin = function(skin) {
        var oldSkin = this.conf.skin;
        this.conf.skin = skin;
        switch (this.conf.skin){
            case "dhx_skyblue":
            case "dhx_web":
                this.conf.tl_botmarg = 2;
                this.conf.tl_rmarg = 1;
                this.conf.tl_ofsleft = 1;
                break;
            case "dhx_terrace":
                this.conf.tl_botmarg = 0;
                this.conf.tl_rmarg = 0;
                this.conf.tl_ofsleft = 0;
                break;
        }
        if (this.base._autoSkinUpdate) {
            this.base.className = this.base.className.replace("dhtmlxMenu_"+oldSkin+"_Middle", "")+" dhtmlxMenu_"+this.conf.skin+"_Middle";
        }

        for (var a in this.idPull) {
            this.idPull[a].className = String(this.idPull[a].className).replace(oldSkin, this.conf.skin);

        }
    }
    this.setSkin(this.conf.skin);
    //

    this._addSubItemToSelected = function(item, polygon) {
        var t = true;
        for (var q=0; q<this.conf.selected_sub.length; q++) { if ((this.conf.selected_sub[q][0] == item) && (this.conf.selected_sub[q][1] == polygon)) { t = false; } }
        if (t == true) { this.conf.selected_sub.push(new Array(item, polygon)); }
        return t;
    }
    this._removeSubItemFromSelected = function(item, polygon) {
        var m = new Array();
        var t = false;
        for (var q=0; q<this.conf.selected_sub.length; q++) { if ((this.conf.selected_sub[q][0] == item) && (this.conf.selected_sub[q][1] == polygon)) { t = true; } else { m[m.length] = this.conf.selected_sub[q]; } }
        if (t == true) { this.conf.selected_sub = m; }
        return t;
    }
    this._getSubItemToDeselectByPolygon = function(polygon) {
        var m = new Array();
        for (var q=0; q<this.conf.selected_sub.length; q++) {
            if (this.conf.selected_sub[q][1] == polygon) {
                m[m.length] = this.conf.selected_sub[q][0];
                m = m.concat(this._getSubItemToDeselectByPolygon(this.conf.selected_sub[q][0]));
                var t = true;
                for (var w=0; w<this.conf.opened_poly.length; w++) { if (this.conf.opened_poly[w] == this.conf.selected_sub[q][0]) { t = false; } }
                if (t == true) { this.conf.opened_poly[this.conf.opened_poly.length] = this.conf.selected_sub[q][0]; }
                this.conf.selected_sub[q][0] = -1;
                this.conf.selected_sub[q][1] = -1;
            }
        }
        return m;
    }

    this._hidePolygon = function(id) {
        if (this.idPull["polygon_" + id] != null) {
            // clear z-index
            if (this.idPull["polygon_"+id]._zId != null) {
                window.dhx4.zim.clear(this.idPull["polygon_"+id]._zId);
            }
            //
            if (typeof(this._menuEffect) != "undefined" && this._menuEffect !== false) {
                this._hidePolygonEffect("polygon_"+id);
            } else {
                // already hidden
                if (this.idPull["polygon_"+id].style.display == "none") return;
                //
                this.idPull["polygon_"+id].style.display = "none";
                if (this.idPull["arrowup_"+id] != null) this.idPull["arrowup_"+id].style.display = "none";
                if (this.idPull["arrowdown_"+id] != null) this.idPull["arrowdown_"+id].style.display = "none";
                this._updateItemComplexState(id, true, false);
                // hide ie6 cover
                if (window.dhx4.isIE6 && this.idPull["polygon_"+id+"_ie6cover"] != null) this.idPull["polygon_"+id+"_ie6cover"].style.display = "none";
            }
            // call event
            id = String(id).replace(this.idPrefix, "");
            if (id == this.topId) id = null;
            this.callEvent("onHide", [id]);

            // corners
            if (id != null && this.conf.skin == "dhx_terrace" && this.itemPull[this.idPrefix+id].parent == this.idPrefix+this.topId) {
                this._improveTerraceButton(this.idPrefix+id, true);
            }

        }
    }

    this._showPolygon = function(id, openType) {

        var itemCount = this._countVisiblePolygonItems(id);
        if (itemCount == 0) return;
        var pId = "polygon_"+id;
        if ((this.idPull[pId] != null) && (this.idPull[id] != null)) {

            if (this.conf.top_mode && this.conf.mode == "web" && !this.conf.context) {
                if (!this.idPull[id]._mouseOver && openType == this.conf.dir_toplv) return;
            }

            // detect visible area
            if (!this.conf.fixed_pos) this._autoDetectVisibleArea();

            // show arrows
            var arrUpH = 0;
            var arrDownH = 0;
            //
            var arrowUp = null;
            var arrowDown = null;

            // show polygon
            if (this.idPull[pId]._zId == null) {
                this.idPull[pId]._zId = window.dhx4.newId();
            }
            this.idPull[pId]._zInd = window.dhx4.zim.reserve(this.idPull[pId]._zId);

            this.idPull[pId].style.visibility = "hidden";
            this.idPull[pId].style.left = "0px";
            this.idPull[pId].style.top = "0px";
            this.idPull[pId].style.display = "";
            this.idPull[pId].style.zIndex = this.idPull[pId]._zInd;

            //
            if (this.conf.auto_overflow) {
                if (this.idPull[pId].firstChild.offsetHeight > this.conf.v.y1+this.conf.v.y2) {
                    var t0 = Math.floor((this.conf.v.y2-this.conf.v.y1-35)/24);
                    this.conf.overflow_limit = t0;
                } else {
                    this.conf.overflow_limit = 0;

                    if (this.idPull["arrowup_"+id] != null) this._removeUpArrow(String(id).replace(this.idPrefix,""));
                    if (this.idPull["arrowdown_"+id] != null) this._removeDownArrow(String(id).replace(this.idPrefix,""));
                }
            }

            if (this.conf.overflow_limit > 0 && this.conf.overflow_limit < itemCount)  {

                // add overflow arrows if they not exists
                if (this.idPull["arrowup_"+id] == null) this._addUpArrow(String(id).replace(this.idPrefix,""));
                if (this.idPull["arrowdown_"+id] == null) this._addDownArrow(String(id).replace(this.idPrefix,""));

                // configure up arrow
                arrowUp = this.idPull["arrowup_"+id];
                arrowUp.style.display = "none";
                //arrUpH = arrowUp.offsetHeight;

                // configure bottom arrow
                arrowDown = this.idPull["arrowdown_"+id];
                arrowDown.style.display = "none";
                //arrDownH = arrowDown.offsetHeight;

            }

            if (this.conf.overflow_limit > 0) {
                if (this.conf.overflow_limit < itemCount)  {
                    // set fixed size
                    this.idPull[pId].childNodes[1].style.height = 24*this.conf.overflow_limit+"px";
                    arrowUp.style.width = arrowDown.style.width = this.idPull[pId].childNodes[1].style.width = this.idPull[pId].childNodes[1].childNodes[0].offsetWidth+"px";
                    this.idPull[pId].childNodes[1].scrollTop = 0;

                    arrowUp.style.display = "";
                    arrUpH = arrowUp.offsetHeight;

                    arrowDown.style.display = "";
                    arrDownH = arrowDown.offsetHeight;

                } else {
                    // remove fixed size
                    this.idPull[pId].childNodes[1].style.height = "";
                    this.idPull[pId].childNodes[1].style.width = "";
                }
            }

            if (this.itemPull[id] != null) {
                var parPoly = "polygon_"+this.itemPull[id]["parent"];
            } else if (this.conf.context) {
                var parPoly = this.idPull[this.idPrefix+this.topId];
            }

            // define position
            var srcX = (this.idPull[id].tagName != null ? window.dhx4.absLeft(this.idPull[id]) : this.idPull[id][0]);
            var srcY = (this.idPull[id].tagName != null ? window.dhx4.absTop(this.idPull[id]) : this.idPull[id][1]);
            var srcW = (this.idPull[id].tagName != null ? this.idPull[id].offsetWidth : 0);
            var srcH = (this.idPull[id].tagName != null ? this.idPull[id].offsetHeight : 0);

            var x = 0;
            var y = 0;
            var w = this.idPull[pId].offsetWidth;
            var h = this.idPull[pId].childNodes[1].offsetHeight + arrUpH + arrDownH;

            // pos
            if (openType == "bottom") {
                if (this.conf.rtl) {
                    x = srcX + (srcW!=null?srcW:0) - w;
                } else {
                    if (this.conf.align == "right") {
                        x = srcX + srcW - w;
                    } else {
                        x = srcX - 1 + (openType==this.conf.dir_toplv?this.conf.tl_rmarg:0);
                    }
                }
                y = srcY - 1 + srcH + this.conf.tl_botmarg;
            }
            if (openType == "right") { x = srcX + srcW - 1; y = srcY + 2; }
            if (openType == "left") { x = srcX - this.idPull[pId].offsetWidth + 2; y = srcY + 2; }
            if (openType == "top") { x = srcX - 1; y = srcY - h + 2; }

            // overflow check
            if (this.conf.fixed_pos) {
                // use fixed document.body/window dimension if required
                var mx = 65536;
                var my = 65536;
            } else {
                var mx = (this.conf.v.x2!=null?this.conf.v.x2:0);
                var my = (this.conf.v.y2!=null?this.conf.v.y2:0);

                if (mx == 0) {
                    if (window.innerWidth) {
                        mx = window.innerWidth;
                        my = window.innerHeight;
                    } else {
                        mx = document.body.offsetWidth;
                        my = document.body.scrollHeight;
                    }
                }
            }
            if (x+w > mx && !this.conf.rtl) {
                // no space on right, open to left
                x = srcX - w + 2;
            }
            if (x < this.conf.v.x1 && this.conf.rtl) {
                // no space on left, open to right
                x = srcX + srcW - 2;
            }
            if (x < 0) {
                // menu floats left
                x = 0;
            }
            if (y+h > my && this.conf.v.y2 != null) {
                y = Math.max(srcY + srcH - h + 2, (this.conf.v_enabled?this.conf.v.y1+2:2));
                // open from top level
                if (this.conf.context && this.idPrefix+this.topId == id && arrowDown != null) {
                    // autoscroll prevent because menu mouse pointer will right over downarrow
                    y = y-2;
                }
                if (this.itemPull[id] != null && !this.conf.context) {
                    if (this.itemPull[id]["parent"] == this.idPrefix+this.topId) y = y - this.base.offsetHeight;
                }
            }
            //
            this.idPull[pId].style.left = x+"px";
            //this.idPull[pId].style.top = y+arrUpH+"px";
            this.idPull[pId].style.top = y+"px";
            //
            if (typeof(this._menuEffect) != "undefined" && this._menuEffect !== false) {
                this._showPolygonEffect(pId);
            } else {
                this.idPull[pId].style.visibility = "";

                if (this.conf.overflow_limit > 0 && this.conf.overflow_limit < itemCount)  {
                    this.idPull[pId].childNodes[1].scrollTop = 0;
                    this._checkArrowsState(id);
                }

                // show ie6 cover
                if (window.dhx4.isIE6) {
                    var pIdIE6 = pId+"_ie6cover";
                    if (this.idPull[pIdIE6] == null) {
                        var ifr = document.createElement("IFRAME");
                        ifr.className = "dhtmlxMenu_IE6CoverFix_"+this.conf.skin;
                        ifr.frameBorder = 0;
                        ifr.setAttribute("src", "javascript:false;");
                        document.body.insertBefore(ifr, document.body.firstChild);
                        this.idPull[pIdIE6] = ifr;
                    }
                    this.idPull[pIdIE6].style.left = x+"px";
                    this.idPull[pIdIE6].style.top = y+"px";
                    this.idPull[pIdIE6].style.width = this.idPull[pId].offsetWidth+"px";
                    this.idPull[pIdIE6].style.height = this.idPull[pId].offsetHeight+"px";
                    this.idPull[pIdIE6].style.zIndex = this.idPull[pId].style.zIndex-1;
                    this.idPull[pIdIE6].style.display = "";
                }
            }

            id = String(id).replace(this.idPrefix, "");
            if (id == this.topId) id = null;
            this.callEvent("onShow", [id]);

            // corners
            if (id != null && this.conf.skin == "dhx_terrace" && this.itemPull[this.idPrefix+id].parent == this.idPrefix+this.topId) {
                this._improveTerraceButton(this.idPrefix+id, false);
            }

        }
    }

    this._redistribSubLevelSelection = function(id, parentId) {
        // clear previosly selected items
        while (this.conf.opened_poly.length > 0) this.conf.opened_poly.pop();
        // this.conf.opened_poly = new Array();
        var i = this._getSubItemToDeselectByPolygon(parentId);
        this._removeSubItemFromSelected(-1, -1);
        for (var q=0; q<i.length; q++) { if ((this.idPull[i[q]] != null) && (i[q] != id)) { if (this.itemPull[i[q]]["state"] == "enabled") { this.idPull[i[q]].className = "sub_item"; } } }
        // hide polygons
        for (var q=0; q<this.conf.opened_poly.length; q++) { if (this.conf.opened_poly[q] != parentId) { this._hidePolygon(this.conf.opened_poly[q]); } }
        // add new selection into list new
        if (this.itemPull[id]["state"] == "enabled") {
            this.idPull[id].className = "sub_item_selected";
            if (this.itemPull[id]["complex"] && this.conf.dload && (this.itemPull[id]["loaded"]=="no")) {
                if (this.conf.dload_icon == true) { this._updateLoaderIcon(id, true); }
                this.itemPull[id].loaded = "get";
                var xmlParentId = id.replace(this.idPrefix,"");
                this._dhxdataload.onBeforeXLS = function() {
                    var p = {params:{}};
                    p.params[this.conf.dload_pid] = xmlParentId;
                    for (var a in this.conf.dload_params) p.params[a] = this.conf.dload_params[a];
                    return p;
                };
                this.loadStruct(this.conf.dload_url);
            }
            // show
            if (this.itemPull[id]["complex"] || (this.conf.dload && (this.itemPull[id]["loaded"] == "yes"))) {
                // make arrow over
                if ((this.itemPull[id]["complex"]) && (this.idPull["polygon_" + id] != null))  {
                    this._updateItemComplexState(id, true, true);
                    this._showPolygon(id, this.conf.dir_sublv);
                }
            }
            this._addSubItemToSelected(id, parentId);
            this.conf.selected = id;
        }
    }

    this._doOnClick = function(id, type, casState) {
        this.conf.last_click = id;
        // href
        if (this.itemPull[this.idPrefix+id]["href_link"] != null && this.itemPull[this.idPrefix+id].state == "enabled") {
            var form = document.createElement("FORM");
            var k = String(this.itemPull[this.idPrefix+id]["href_link"]).split("?");
            form.action = k[0];
            if (k[1] != null) {
                var p = String(k[1]).split("&");
                for (var q=0; q<p.length; q++) {
                    var j = String(p[q]).split("=");
                    var m = document.createElement("INPUT");
                    m.type = "hidden";
                    m.name = (j[0]||"");
                    m.value = (j[1]||"");
                    form.appendChild(m);
                }
            }
            if (this.itemPull[this.idPrefix+id]["href_target"] != null) { form.target = this.itemPull[this.idPrefix+id]["href_target"]; }
            form.style.display = "none";
            document.body.appendChild(form);
            form.submit();
            if (form != null) {
                document.body.removeChild(form);
                form = null;
            }
            return;
        }
        //
        // some fixes
        if (type.charAt(0)=="c") return; // can't click on complex item
        if (type.charAt(1)=="d") return; // can't click on disabled item
        if (type.charAt(2)=="s") return; // can't click on separator
        //
        if (this.checkEvent("onClick")) {
            this.callEvent("onClick", [id, this.conf.ctx_zoneid, casState]);
        } else {
            if ((type.charAt(1) == "d") || (this.conf.mode == "win" && type.charAt(2) == "t")) return;
        }
        if (this.conf.context && this._isContextMenuVisible() && this.conf.ctx_autohide) {
            this._hideContextMenu();
        } else {
            // if menu unloaded from click event
            if (this._clearAndHide) this._clearAndHide();
        }
    }
    // onTouchMenu action - select topLevel item
    this._doOnTouchMenu = function(id) {
        if (this.conf.is_touched == false) {
            this.conf.is_touched = true;
            if (this.checkEvent("onTouch")) {
                this.callEvent("onTouch", [id]);
            }
        }
    }

    // return menu array of all nested objects
    this._searchMenuNode = function(node, menu) {
        var m = new Array();
        for (var q=0; q<menu.length; q++) {
            if (typeof(menu[q]) == "object") {
                if (menu[q].length == 5) { if (typeof(menu[q][0]) != "object") { if ((menu[q][0].replace(this.idPrefix, "") == node) && (q == 0)) { m = menu; } } }
                var j = this._searchMenuNode(node, menu[q]);
                if (j.length > 0) { m = j; }
            }
        }
        return m;
    }
    // return array of subitems for single menu object
    this._getMenuNodes = function(node) {
        var m = new Array;
        for (var a in this.itemPull) { if (this.itemPull[a]["parent"] == node) { m[m.length] = a; } }
        return m;
    }
    // generate random string with specified length
    this._genStr = function(w) {
        var s = ""; var z = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
        for (var q=0; q<w; q++) s += z.charAt(Math.round(Math.random() * (z.length-1)));
        return s;
    }

    this.getItemType = function(id) {
        id = this.idPrefix+id;
        if (this.itemPull[id] == null) { return null; }
        return this.itemPull[id]["type"];
    }

    this.forEachItem = function(handler) {
        for (var a in this.itemPull) { handler(String(a).replace(this.idPrefix, "")); }
    }

    // clear selection and hide menu on onbody click event
    this._clearAndHide = function() {
        that.conf.selected = -1;
        that.conf.last_click = -1;
        while (that.conf.opened_poly.length > 0) { that.conf.opened_poly.pop(); }
        for (var q=0; q<that.conf.selected_sub.length; q++) {
            var id = that.conf.selected_sub[q][0];
            // clear all selection
            if (that.idPull[id] != null) {
                if (that.itemPull[id]["state"] == "enabled") {
                    if (that.idPull[id].className == "sub_item_selected") that.idPull[id].className = "sub_item";
                    if (that.idPull[id].className == "dhtmlxMenu_"+that.conf.skin+"_TopLevel_Item_Selected") {
                        // custom css
                        if (that.itemPull[id]["cssNormal"] != null) {
                            that.idPull[id].className = that.itemPull[id]["cssNormal"];
                        } else {
                            // default css
                            that.idPull[id].className = "dhtmlxMenu_"+that.conf.skin+"_TopLevel_Item_Normal";
                        }
                    }
                }
            }
            that._hidePolygon(id);
        }

        that.conf.is_touched = false;

        // hide all contextmenu polygons on mouseout
        if (that.conf.context && that.conf.ctx_hideall) that._hidePolygon(that.idPrefix+that.topId);

    }

    /* show sublevel item */
    this._showSubLevelItem = function(id,back) {
        if (document.getElementById("arrow_" + this.idPrefix + id) != null) { document.getElementById("arrow_" + this.idPrefix + id).style.display = (back?"none":""); }
        if (document.getElementById("image_" + this.idPrefix + id) != null) { document.getElementById("image_" + this.idPrefix + id).style.display = (back?"none":""); }
        if (document.getElementById(this.idPrefix + id) != null) { document.getElementById(this.idPrefix + id).style.display = (back?"":"none"); }
    }
    /* hide sublevel item */
    this._hideSubLevelItem = function(id) {
        this._showSubLevelItem(id,true)
    }
    // generating id prefix
    this.idPrefix = this._genStr(12)+"_";

    /* attach body events */
    this._bodyClick = function(e) {
        e = e||event;
        if (e.button == 2 || (window.dhx4.isOpera && e.ctrlKey == true)) return;
        if (that.conf.context) {
            if (that.conf.ctx_autohide && (!window.dhx4.isOpera || (that._isContextMenuVisible() && window.dhx4.isOpera))) that._hideContextMenu();
        } else {
            if (that._clearAndHide) that._clearAndHide();
        }
    }
    this._bodyContext = function(e) {
        e = e||event;
        var t = String((e.srcElement||e.target).className);
        if (t.search("dhtmlxMenu") != -1 && t.search("SubLevelArea") != -1) return;
        var toHide = true;
        var testZone = e.target || e.srcElement;
        while (testZone != null) {
            if (testZone.id != null) if (that.isContextZone(testZone.id)) toHide = false;
            if (testZone == document.body) toHide = false;
            testZone = testZone.parentNode;
        }
        if (toHide) that.hideContextMenu();
    }

    if (typeof(window.addEventListener) != "undefined") {
        window.addEventListener("click", this._bodyClick, false);
        window.addEventListener("contextmenu", this._bodyContext, false);
    } else {
        document.body.attachEvent("onclick", this._bodyClick);
        document.body.attachEvent("oncontextmenu", this._bodyContext);
    }

    this.unload = function() {

        window.dhx4._eventable(this, "clear");

        // remove menu from global store
        dhtmlXMenuObject.prototype.liveInst[this.conf.live_id] = null;
        try { delete dhtmlXMenuObject.prototype.liveInst[this.conf.live_id]; } catch(e) {}
        this.conf.live_id = null;

        if (typeof(window.addEventListener) == "function") {
            window.removeEventListener("click", this._bodyClick, false);
            window.removeEventListener("contextmenu", this._bodyContext, false);
        } else {
            document.body.detachEvent("onclick", this._bodyClick);
            document.body.detachEvent("oncontextmenu", this._bodyContext);
        }
        this._bodyClick = null;
        this._bodyContext = null;

        // will recursively remove all items
        this.removeItem(this.idPrefix+this.topId, true);

        this.itemPull = null;
        this.idPull = null;

        // clear context zones
        if (this.conf.context) for (var a in this.conf.ctx_zones) this.removeContextZone(a);

        if (this.cont != null) {
            this.cont.className = "";
            this.cont.parentNode.removeChild(this.cont);
            this.cont = null;
        }

        if (this.base != null) {
            if (!this.conf.context) this.base.className = "";
            if (!this.conf.context) this.base.oncontextmenu = (this.base._oldContextMenuHandler||null);
            this.base.onselectstart = null;
            this.base = null;
        }

        for (var a in this) this[a] = null;
        that = null;

    }

    // register instance
    dhtmlXMenuObject.prototype.liveInst[this.conf.live_id] = this;

    window.dhx4._enableDataLoading(this, "_initObj", "_xmlToJson", this.conf.tags.root, {struct:true});
    window.dhx4._eventable(this);

    // autoload
    if (window.dhx4.s2b(this.conf.autoload.context) == true) this.renderAsContextMenu();

    if (this.conf.autoload.dynamic != null) {
        this.enableDynamicLoading(this.conf.autoload.dynamic, window.dhx4.s2b(this.conf.autoload.dynamic_icon));
    } else if (this.conf.autoload.items != null) {
        this.loadStruct(this.conf.autoload.items, this.conf.autoload.onload);
    } else if (this.conf.autoload.json != null) {
        this.loadStruct(this.conf.autoload.json, this.conf.autoload.onload);
    } else if (this.conf.autoload.xml != null) {
        this.loadStruct(this.conf.autoload.xml, this.conf.autoload.onload);
    }

    for (var a in {onclick:1,oncheckboxclick:1,onradioclick:1}) {
        if (this.conf.autoload[a] != null) {
            if (typeof(this.conf.autoload[a]) == "function") {
                this.attachEvent(a, this.conf.autoload[a]);
            } else if (typeof(window[this.conf.autoload[a]]) == "function") {
                this.attachEvent(a, window[this.conf.autoload[a]]);
            }
        }
    }

    if (this.conf.autoload.top_text != null) this.setTopText(this.conf.autoload.top_text);
    if (this.conf.autoload.align != null) this.setAlign(this.conf.autoload.align);
    if (this.conf.autoload.open_mode != null) this.setOpenMode(this.conf.autoload.open_mode);
    if (this.conf.autoload.overflow != null) this.setOverflowHeight(this.conf.autoload.overflow);
    //
    for (var a in this.conf.autoload) {
        this.conf.autoload[a] = null;
        delete this.conf.autoload[a];
    }
    this.conf.autoload = null;

    //
    return this;

};

dhtmlXMenuObject.prototype._init = function() {
    if (this._isInited == true) return;
    if (this.conf.dload) {
        this._dhxdataload.onBeforeXLS = function() {
            var p = {params:{}};
            for (var a in this.conf.dload_params) p.params[a] = this.conf.dload_params[a];
            return p;
        };
        this.loadStruct(this.conf.dload_url);
    } else {
        this._initTopLevelMenu();
        this._isInited = true;
    }
};

dhtmlXMenuObject.prototype._countVisiblePolygonItems = function(id) {

    var count = 0;

    for (var a in this.itemPull) {

        var par = this.itemPull[a]["parent"];
        var tp = this.itemPull[a]["type"];
        if (this.idPull[a] != null) {
            if (par == id && (tp == "item" || tp == "radio" || tp == "checkbox") && this.idPull[a].style.display != "none") {
                count++;
            }
        }
    }
    return count;
};

dhtmlXMenuObject.prototype._redefineComplexState = function(id) {
    // alert(id)
    if (this.idPrefix+this.topId == id) { return; }
    if ((this.idPull["polygon_"+id] != null) && (this.idPull[id] != null)) {
        var u = this._countVisiblePolygonItems(id);
        if ((u > 0) && (!this.itemPull[id]["complex"])) { this._updateItemComplexState(id, true, false); }
        if ((u == 0) && (this.itemPull[id]["complex"])) { this._updateItemComplexState(id, false, false); }
    }
};

dhtmlXMenuObject.prototype._updateItemComplexState = function(id, state, over) {
    // 0.2 FIX :: topLevel's items can have complex items with arrow
    if ((!this.conf.context) && (this._getItemLevelType(id.replace(this.idPrefix,"")) == "TopLevel")) {
        // 30.06.2008 fix > complex state for top level item, state only, no arrow
        this.itemPull[id]["complex"] = state;
        return;
    }
    if ((this.idPull[id] == null) || (this.itemPull[id] == null)) { return; }
    // 0.2 FIX :: end
    this.itemPull[id]["complex"] = state;
    // fixed in 0.4 for context
    if (id == this.idPrefix+this.topId) return;
    // end fix
    // try to retrieve arrow img object
    var arrowObj = null;


    var item = this.idPull[id].childNodes[this.conf.rtl?0:2];
    if (item.childNodes[0]) if (String(item.childNodes[0].className).search("complex_arrow") === 0) arrowObj = item.childNodes[0];

    if (this.itemPull[id]["complex"]) {
        // create arrow
        if (arrowObj == null) {
            arrowObj = document.createElement("DIV");
            arrowObj.className = "complex_arrow";
            arrowObj.id = "arrow_"+id;
            while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
            item.appendChild(arrowObj);
        }
        // over state added in 0.4

        if (this.conf.dload && (this.itemPull[id].loaded == "get") && this.conf.dload_icon) {
            // change arrow to loader
            if (arrowObj.className != "complex_arrow_loading") arrowObj.className = "complex_arrow_loading";
        } else {
            arrowObj.className = "complex_arrow";
        }

        return;
    }

    if ((!this.itemPull[id]["complex"]) && (arrowObj!=null)) {
        item.removeChild(arrowObj);
        if (this.itemPull[id]["hotkey_backup"] != null && this.setHotKey) { this.setHotKey(id.replace(this.idPrefix, ""), this.itemPull[id]["hotkey_backup"]); }
    }

};

dhtmlXMenuObject.prototype._getItemLevelType = function(id) {
    return (this.itemPull[this.idPrefix+id]["parent"]==this.idPrefix+this.topId?"TopLevel":"SubLevelArea");
};

dhtmlXMenuObject.prototype.setIconsPath = function(path) {
    this.conf.icons_path = path;
};

/* real-time update icon in menu */
dhtmlXMenuObject.prototype._updateItemImage = function(id, levelType) {
    // search existsing image

    id = this.idPrefix+id;

    var tp = this.itemPull[id]["type"];
    if (tp == "checkbox" || tp == "radio") return;

    var isTopLevel = (this.itemPull[id]["parent"] == this.idPrefix+this.topId && !this.conf.context);

    // search existing image
    var imgObj = null;
    if (isTopLevel) {
        for (var q=0; q<this.idPull[id].childNodes.length; q++) {
            try { if (this.idPull[id].childNodes[q].className == "dhtmlxMenu_TopLevel_Item_Icon") imgObj = this.idPull[id].childNodes[q]; } catch(e) {}
        }
    } else {
        try { var imgObj = this.idPull[id].childNodes[this.conf.rtl?2:0].childNodes[0]; } catch(e) { }
        if (!(imgObj != null && typeof(imgObj.className) != "undefined" && imgObj.className == "sub_icon")) imgObj = null;
    }

    var imgSrc = this.itemPull[id][(this.itemPull[id]["state"]=="enabled"?"imgen":"imgdis")];

    if (imgSrc.length > 0) {
        if (imgObj != null) {
            imgObj.src = this.conf.icons_path+imgSrc;
        } else {
            if (isTopLevel) {
                var imgObj = document.createElement("IMG");
                imgObj.className = "dhtmlxMenu_TopLevel_Item_Icon";
                imgObj.src = this.conf.icons_path+imgSrc;
                imgObj.border = "0";
                imgObj.id = "image_"+id;
                if (!this.conf.rtl && this.idPull[id].childNodes.length > 0) this.idPull[id].insertBefore(imgObj,this.idPull[id].childNodes[0]); else this.idPull[id].appendChild(imgObj);

            } else {

                var imgObj = document.createElement("IMG");
                imgObj.className = "sub_icon";
                imgObj.src = this.conf.icons_path+imgSrc;
                imgObj.border = "0";
                imgObj.id = "image_"+id;
                var item = this.idPull[id].childNodes[this.conf.rtl?2:0];
                while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
                item.appendChild(imgObj);

            }
        }
    } else {
        if (imgObj != null) {
            var p = imgObj.parentNode;
            p.removeChild(imgObj);
            p.innerHTML = "&nbsp;";
            p = imgObj = null;
        }
    }
};

// collect parents for remove complex item
dhtmlXMenuObject.prototype._getAllParents = function(id) {
    var parents = new Array();
    for (var a in this.itemPull) {
        if (this.itemPull[a]["parent"] == id) {
            parents[parents.length] = this.itemPull[a]["id"];
            if (this.itemPull[a]["complex"]) {
                var t = this._getAllParents(this.itemPull[a]["id"]);
                for (var q=0; q<t.length; q++) { parents[parents.length] = t[q]; }
            }
        }
    }
    return parents;
};

// visible area
dhtmlXMenuObject.prototype._autoDetectVisibleArea = function() {
    if (this.conf.v_enabled) return;
    var d = window.dhx4.screenDim();
    this.conf.v.x1 = d.left;
    this.conf.v.x2 = d.right;
    this.conf.v.y1 = d.top;
    this.conf.v.y2 = d.bottom;
};

dhtmlXMenuObject.prototype.getItemPosition = function(id) {
    id = this.idPrefix+id;
    var pos = -1;
    if (this.itemPull[id] == null) return pos;
    var parent = this.itemPull[id]["parent"];
    // var obj = (this.idPull["polygon_"+parent]!=null?this.idPull["polygon_"+parent].tbd:this.base);
    var obj = (this.idPull["polygon_"+parent]!=null?this.idPull["polygon_"+parent].tbd:this.cont);
    for (var q=0; q<obj.childNodes.length; q++) { if (obj.childNodes[q]==this.idPull["separator_"+id]||obj.childNodes[q]==this.idPull[id]) { pos = q; } }
    return pos;
};

dhtmlXMenuObject.prototype.setItemPosition = function(id, pos) {
    id = this.idPrefix+id;
    if (this.idPull[id] == null) { return; }
    // added in 0.4
    var isOnTopLevel = (this.itemPull[id]["parent"] == this.idPrefix+this.topId);
    //
    var itemData = this.idPull[id];
    var itemPos = this.getItemPosition(id.replace(this.idPrefix,""));
    var parent = this.itemPull[id]["parent"];
    // var obj = (this.idPull["polygon_"+parent]!=null?this.idPull["polygon_"+parent].tbd:this.base);
    var obj = (this.idPull["polygon_"+parent]!=null?this.idPull["polygon_"+parent].tbd:this.cont);
    obj.removeChild(obj.childNodes[itemPos]);
    if (pos < 0) pos = 0;
    // added in 0.4
    if (isOnTopLevel && pos < 1) { pos = 1; }
    //
    if (pos < obj.childNodes.length) { obj.insertBefore(itemData, obj.childNodes[pos]); } else { obj.appendChild(itemData); }
};

dhtmlXMenuObject.prototype.getParentId = function(id) {
    id = this.idPrefix+id;
    if (this.itemPull[id] == null) { return null; }
    return ((this.itemPull[id]["parent"]!=null?this.itemPull[id]["parent"]:this.topId).replace(this.idPrefix,""));
};


// hide any opened polygons
dhtmlXMenuObject.prototype.hide = function() {
    this._clearAndHide();
};
dhtmlXMenuObject.prototype.clearAll = function() {
    this.removeItem(this.idPrefix+this.topId, true);
    this._isInited = false;
    this.idPrefix = this._genStr(12)+"_";
    this.itemPull = {};
};

// dhtmlxmenu global store
if (typeof(dhtmlXMenuObject.prototype.liveInst) == "undefined") {
    dhtmlXMenuObject.prototype.liveInst = {};
};


// redistrib selection in case of top node in real-time mode
dhtmlXMenuObject.prototype._redistribTopLevelSelection = function(id, parent) {
    // kick polygons and decelect before selected menues
    var i = this._getSubItemToDeselectByPolygon("parent");
    this._removeSubItemFromSelected(-1, -1);
    for (var q=0; q<i.length; q++) {
        if (i[q] != id) { this._hidePolygon(i[q]); }
        if ((this.idPull[i[q]] != null) && (i[q] != id)) { this.idPull[i[q]].className = this.idPull[i[q]].className.replace(/Selected/g, "Normal"); }
    }
    // check if enabled
    if (this.itemPull[this.idPrefix+id]["state"] == "enabled") {
        this.idPull[this.idPrefix+id].className = "dhtmlxMenu_"+this.conf.skin+"_TopLevel_Item_Selected";
        //
        this._addSubItemToSelected(this.idPrefix+id, "parent");
        this.conf.selected = (this.conf.mode=="win"?(this.conf.selected!=-1?id:this.conf.selected):id);
        if ((this.itemPull[this.idPrefix+id]["complex"]) && (this.conf.selected != -1)) { this._showPolygon(this.idPrefix+id, this.conf.dir_toplv); }
    }
};

dhtmlXMenuObject.prototype._initTopLevelMenu = function() {

    this.conf.dir_toplv = "bottom";
    this.conf.dir_sublv = (this.conf.rtl?"left":"right");
    if (this.conf.context) {
        this.idPull[this.idPrefix+this.topId] = new Array(0,0);
        this._addSubMenuPolygon(this.idPrefix+this.topId, this.idPrefix+this.topId);
    } else {
        var m = this._getMenuNodes(this.idPrefix + this.topId);
        for (var q=0; q<m.length; q++) {
            if (this.itemPull[m[q]]["type"] == "item") this._renderToplevelItem(m[q], null);
            if (this.itemPull[m[q]]["type"] == "separator") this._renderSeparator(m[q], null);
        }
    }
};

// add top menu item, complex define that submenues are in presence
dhtmlXMenuObject.prototype._renderToplevelItem = function(id, pos) {
    var that = this;
    var m = document.createElement("DIV");
    m.id = id;
    // custom css
    if (this.itemPull[id]["state"] == "enabled" && this.itemPull[id]["cssNormal"] != null) {
        m.className = this.itemPull[id]["cssNormal"];
    } else {
        m.className = "dhtmlxMenu_"+this.conf.skin+"_TopLevel_Item_"+(this.itemPull[id]["state"]=="enabled"?"Normal":"Disabled");
    }

    // text
    if (this.itemPull[id]["title"] != "") {
        var t1 = document.createElement("DIV");
        t1.className = "top_level_text";
        t1.innerHTML = this.itemPull[id]["title"];
        m.appendChild(t1);
    }
    // tooltip
    if (this.itemPull[id]["tip"].length > 0) m.title = this.itemPull[id]["tip"];
    //
    // image in top level
    if ((this.itemPull[id]["imgen"]!="")||(this.itemPull[id]["imgdis"]!="")) {
        var imgTop=this.itemPull[id][(this.itemPull[id]["state"]=="enabled")?"imgen":"imgdis"];
        if (imgTop) {
            var img = document.createElement("IMG");
            img.border = "0";
            img.id = "image_"+id;
            img.src= this.conf.icons_path+imgTop;
            img.className = "dhtmlxMenu_TopLevel_Item_Icon";
            if (m.childNodes.length > 0 && !this.conf.rtl) m.insertBefore(img, m.childNodes[0]); else m.appendChild(img);
        }
    }
    m.onselectstart = function(e) { e = e || event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
    m.oncontextmenu = function(e) { e = e || event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
    // add container for top-level items if not exists yet
    if (!this.cont) {
        this.cont = document.createElement("DIV");
        this.cont.dir = "ltr";
        this.cont.className = (this.conf.align=="right"?"align_right":"align_left");
        this.base.appendChild(this.cont);
    }
    // insert

    if (pos != null) { pos++; if (pos < 0) pos = 0; if (pos > this.cont.childNodes.length - 1) pos = null; }
    if (pos != null) this.cont.insertBefore(m, this.cont.childNodes[pos]); else this.cont.appendChild(m);

    this.idPull[m.id] = m;
    // create submenues
    if (this.itemPull[id]["complex"] && (!this.conf.dload)) this._addSubMenuPolygon(this.itemPull[id]["id"], this.itemPull[id]["id"]);
    // events
    m.onmouseover = function() {
        if (that.conf.mode == "web") { window.clearTimeout(that.conf.tm_handler); }
        // kick polygons and decelect before selected menues
        var i = that._getSubItemToDeselectByPolygon("parent");
        that._removeSubItemFromSelected(-1, -1);
        for (var q=0; q<i.length; q++) {
            if (i[q] != this.id) { that._hidePolygon(i[q]); }
            if ((that.idPull[i[q]] != null) && (i[q] != this.id)) {
                // custom css
                if (that.itemPull[i[q]]["cssNormal"] != null) {
                    that.idPull[i[q]].className = that.itemPull[i[q]]["cssNormal"];
                } else {
                    if (that.idPull[i[q]].className == "sub_item_selected") that.idPull[i[q]].className = "sub_item";
                    that.idPull[i[q]].className = that.idPull[i[q]].className.replace(/Selected/g, "Normal");
                }
            }
        }
        // check if enabled
        if (that.itemPull[this.id]["state"] == "enabled") {
            this.className = "dhtmlxMenu_"+that.conf.skin+"_TopLevel_Item_Selected";
            //
            that._addSubItemToSelected(this.id, "parent");
            that.conf.selected = (that.conf.mode=="win"?(that.conf.selected!=-1?this.id:that.conf.selected):this.id);
            if (that.conf.dload) {
                if (that.itemPull[this.id].loaded == "no") {
                    this._dynLoadTM = new Date().getTime();
                    that.itemPull[this.id].loaded = "get";
                    var xmlParentId = this.id.replace(that.idPrefix,"");
                    that._dhxdataload.onBeforeXLS = function() {
                        var p = {params:{}};
                        p.params[this.conf.dload_pid] = xmlParentId;
                        for (var a in this.conf.dload_params) p.params[a] = this.conf.dload_params[a];
                        return p;
                    };
                    that.loadStruct(that.conf.dload_url);
                }
                if (that.conf.top_mode && that.conf.mode == "web" && !that.conf.context) {
                    this._mouseOver = true;
                }
            }
            if ((!that.conf.dload) || (that.conf.dload && (!that.itemPull[this.id]["loaded"] || that.itemPull[this.id]["loaded"]=="yes"))) {
                if ((that.itemPull[this.id]["complex"]) && (that.conf.selected != -1)) {
                    if (that.conf.top_mode && that.conf.mode == "web" && !that.conf.context) {
                        this._mouseOver = true;
                        var showItemId = this.id;
                        this._menuOpenTM = window.setTimeout(function(){that._showPolygon(showItemId, that.conf.dir_toplv);}, that.conf.top_tmtime);
                    } else {
                        that._showPolygon(this.id, that.conf.dir_toplv);
                    }
                }
            }
        }
        that._doOnTouchMenu(this.id.replace(that.idPrefix, ""));
    }
    m.onmouseout = function() {
        if (!((that.itemPull[this.id]["complex"]) && (that.conf.selected != -1)) && (that.itemPull[this.id]["state"]=="enabled")) {
            // custom css

            if (that.itemPull[this.id]["cssNormal"] != null) {
                // alert(1)
                m.className = that.itemPull[this.id]["cssNormal"];
            } else {
                // default css
                m.className = "dhtmlxMenu_"+that.conf.skin+"_TopLevel_Item_Normal";
            }
        }
        if (that.conf.mode == "web") {
            window.clearTimeout(that.conf.tm_handler);
            that.conf.tm_handler = window.setTimeout(function(){that._clearAndHide();}, that.conf.tm_sec, "JavaScript");
        }
        if (that.conf.top_mode && that.conf.mode == "web" && !that.conf.context) {
            this._mouseOver = false;
            window.clearTimeout(this._menuOpenTM);
        }
    }
    m.onclick = function(e) {
        if (that.conf.mode == "web") { window.clearTimeout(that.conf.tm_handler); }
        // fix, added in 0.4
        if (that.conf.mode != "web" && that.itemPull[this.id]["state"] == "disabled") { return; }
        //
        e = e || event;
        e.cancelBubble = true;
        if (e.preventDefault) e.preventDefault(); else e.returnValue = false;

        if (that.conf.mode == "win") {
            if (that.itemPull[this.id]["complex"]) {
                if (that.conf.selected == this.id) { that.conf.selected = -1; var s = false; } else { that.conf.selected = this.id; var s = true; }
                if (s) { that._showPolygon(this.id, that.conf.dir_toplv); } else { that._hidePolygon(this.id); }
            }
        }
        var tc = (that.itemPull[this.id]["complex"]?"c":"-");
        var td = (that.itemPull[this.id]["state"]!="enabled"?"d":"-");
        var cas = {"ctrl": e.ctrlKey, "alt": e.altKey, "shift": e.shiftKey};
        that._doOnClick(this.id.replace(that.idPrefix, ""), tc+td+"t", cas);
        return false;
    }

    if (this.conf.skin == "dhx_terrace") {
        this._improveTerraceSkin();
    }
};

// recursively creates and adds submenu polygon
dhtmlXMenuObject.prototype._addSubMenuPolygon = function(id, parentId) {
    var s = this._renderSublevelPolygon(id, parentId);
    var j = this._getMenuNodes(parentId);
    for (q=0; q<j.length; q++) { if (this.itemPull[j[q]]["type"] == "separator") { this._renderSeparator(j[q], null); } else { this._renderSublevelItem(j[q], null); } }
    if (id == parentId) { var level = "topLevel"; } else { var level = "subLevel"; }
    for (var q=0; q<j.length; q++) { if (this.itemPull[j[q]]["complex"]) { this._addSubMenuPolygon(id, this.itemPull[j[q]]["id"]); } }
};

// inner: add single subpolygon/item/separator
dhtmlXMenuObject.prototype._renderSublevelPolygon = function(id, parentId) {
    var s = document.createElement("DIV");
    s.className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_Polygon "+(this.conf.rtl?"dir_right":"");
    s.dir = "ltr";
    s.oncontextmenu = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; e.cancelBubble = true; return false; }
    s.id = "polygon_" + parentId;
    s.onclick = function(e) { e = e || event; e.cancelBubble = true; }
    s.style.display = "none";
    document.body.insertBefore(s, document.body.firstChild);
    //

    s.innerHTML = '<div style="position:relative;"></div>'+'<div style="position: relative; overflow:hidden;"></div>'+'<div style="position:relative;"></div>';

    var tbl = document.createElement("TABLE");
    tbl.className = "dhtmlxMebu_SubLevelArea_Tbl";
    tbl.cellSpacing = 0;
    tbl.cellPadding = 0;
    tbl.border = 0;
    var tbd = document.createElement("TBODY");
    tbl.appendChild(tbd);

    s.childNodes[1].appendChild(tbl);

    s.tbl = tbl;
    s.tbd = tbd;
    // polygon
    this.idPull[s.id] = s;
    if (this.sxDacProc != null) {
        this.idPull["sxDac_" + parentId] = new this.sxDacProc(s, s.className);
        if (window.dhx4.isIE) {
            this.idPull["sxDac_" + parentId]._setSpeed(this.dacSpeedIE);
            this.idPull["sxDac_" + parentId]._setCustomCycle(this.dacCyclesIE);
        } else {
            this.idPull["sxDac_" + parentId]._setSpeed(this.dacSpeed);
            this.idPull["sxDac_" + parentId]._setCustomCycle(this.dacCycles);
        }
    }
    return s;
};

dhtmlXMenuObject.prototype._renderSublevelItem = function(id, pos) {
    var that = this;

    var tr = document.createElement("TR");
    tr.className = (this.itemPull[id]["state"]=="enabled"?"sub_item":"sub_item_dis");

    // icon
    var t1 = document.createElement("TD");
    t1.className = "sub_item_icon";
    var icon = this.itemPull[id][(this.itemPull[id]["state"]=="enabled"?"imgen":"imgdis")];
    if (icon != "") {
        var tp = this.itemPull[id]["type"];
        if (tp=="checkbox"||tp=="radio") {
            var img = document.createElement("DIV");
            img.id = "image_"+this.itemPull[id]["id"];
            img.className = "sub_icon "+icon;
            t1.appendChild(img);
        }
        if (!(tp=="checkbox"||tp=="radio")) {
            var img = document.createElement("IMG");
            img.id = "image_"+this.itemPull[id]["id"];
            img.className = "sub_icon";
            img.src = this.conf.icons_path+icon;
            t1.appendChild(img);
        }
    } else {
        t1.innerHTML = "&nbsp;";
    }

    // text
    var t2 = document.createElement("TD");
    t2.className = "sub_item_text";
    if (this.itemPull[id]["title"] != "") {
        var t2t = document.createElement("DIV");
        t2t.className = "sub_item_text";
        t2t.innerHTML = this.itemPull[id]["title"];
        t2.appendChild(t2t);
    } else {
        t2.innerHTML = "&nbsp;";
    }

    // hotkey/sublevel arrow
    var t3 = document.createElement("TD");
    t3.className = "sub_item_hk";
    if (this.itemPull[id]["complex"]) {

        var arw = document.createElement("DIV");
        arw.className = "complex_arrow";
        arw.id = "arrow_"+this.itemPull[id]["id"];
        t3.appendChild(arw);

    } else {
        if (this.itemPull[id]["hotkey"].length > 0 && !this.itemPull[id]["complex"]) {
            var t3t = document.createElement("DIV");
            t3t.className = "sub_item_hk";
            t3t.innerHTML = this.itemPull[id]["hotkey"];
            t3.appendChild(t3t);
        } else {
            t3.innerHTML = "&nbsp;";
        }
    }
    tr.appendChild(this.conf.rtl?t3:t1);
    tr.appendChild(t2);
    tr.appendChild(this.conf.rtl?t1:t3);


    //
    tr.id = this.itemPull[id]["id"];
    tr.parent = this.itemPull[id]["parent"];
    // tooltip, added in 0.4
    if (this.itemPull[id]["tip"].length > 0) tr.title = this.itemPull[id]["tip"];
    //
    tr.onselectstart = function(e) { e = e || event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
    tr.onmouseover = function(e) {
        if (that.conf.hide_tm[this.id]) window.clearTimeout(that.conf.hide_tm[this.id]);
        if (that.conf.mode == "web") window.clearTimeout(that.conf.tm_handler);
        if (!this._visible) that._redistribSubLevelSelection(this.id, this.parent); // if not visible
        this._visible = true;
    }
    tr.onmouseout = function() {
        if (that.conf.mode == "web") {
            if (that.conf.tm_handler) window.clearTimeout(that.conf.tm_handler);
            that.conf.tm_handler = window.setTimeout(function(){if(that&&that._clearAndHide)that._clearAndHide();}, that.conf.tm_sec, "JavaScript");
        }
        var k = this;
        if (that.conf.hide_tm[this.id]) window.clearTimeout(that.conf.hide_tm[this.id]);
        that.conf.hide_tm[this.id] = window.setTimeout(function(){k._visible=false;}, 50);
    }
    tr.onclick = function(e) {
        // added in 0.4, preven complex closing if user event not defined
        if (!that.checkEvent("onClick") && that.itemPull[this.id]["complex"]) return;
        //
        e = e || event; e.cancelBubble = true;
        if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
        tc = (that.itemPull[this.id]["complex"]?"c":"-");
        td = (that.itemPull[this.id]["state"]=="enabled"?"-":"d");
        var cas = {"ctrl": e.ctrlKey, "alt": e.altKey, "shift": e.shiftKey};
        switch (that.itemPull[this.id]["type"]) {
            case "checkbox":
                that._checkboxOnClickHandler(this.id.replace(that.idPrefix, ""), tc+td+"n", cas);
                break;
            case "radio":
                that._radioOnClickHandler(this.id.replace(that.idPrefix, ""), tc+td+"n", cas);
                break;
            case "item":
                that._doOnClick(this.id.replace(that.idPrefix, ""), tc+td+"n", cas);
                break;
        }
        return false;
    }
    // add
    var polygon = this.idPull["polygon_"+this.itemPull[id]["parent"]];
    if (pos != null) { pos++; if (pos < 0) pos = 0; if (pos > polygon.tbd.childNodes.length - 1) pos = null; }
    if (pos != null && polygon.tbd.childNodes[pos] != null) polygon.tbd.insertBefore(tr, polygon.tbd.childNodes[pos]); else polygon.tbd.appendChild(tr);
    this.idPull[tr.id] = tr;
};

dhtmlXMenuObject.prototype._renderSeparator = function(id, pos) {
    var level = (this.conf.context?"SubLevelArea":(this.itemPull[id]["parent"]==this.idPrefix+this.topId?"TopLevel":"SubLevelArea"));
    if (level == "TopLevel" && this.conf.context) return;

    var that = this;

    if (level != "TopLevel") {
        var tr = document.createElement("TR");
        tr.className = "sub_sep";
        var td = document.createElement("TD");
        td.colSpan = "3";
        tr.appendChild(td);
    }

    var k = document.createElement("DIV");
    k.id = "separator_"+id;
    k.className = (level=="TopLevel"?"top_sep":"sub_sep");
    k.onselectstart = function(e) { e = e || event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; }
    k.onclick = function(e) {
        e = e || event; e.cancelBubble = true;
        var cas = {"ctrl": e.ctrlKey, "alt": e.altKey, "shift": e.shiftKey};
        that._doOnClick(this.id.replace("separator_" + that.idPrefix, ""), "--s", cas);
    }
    if (level == "TopLevel") {
        if (pos != null) {
            pos++; if (pos < 0) { pos = 0; }
            // if (this.base.childNodes[pos] != null) { this.base.insertBefore(k, this.base.childNodes[pos]); } else { this.base.appendChild(k); }
            if (this.cont.childNodes[pos] != null) { this.cont.insertBefore(k, this.cont.childNodes[pos]); } else { this.cont.appendChild(k); }
        } else {
            // add as a last item
            // var last = this.base.childNodes[this.base.childNodes.length-1];
            var last = this.cont.childNodes[this.cont.childNodes.length-1];
            // if (String(last).search("TopLevel_Text") == -1) { this.base.appendChild(k); } else { this.base.insertBefore(k, last); }
            if (String(last).search("TopLevel_Text") == -1) { this.cont.appendChild(k); } else { this.cont.insertBefore(k, last); }
        }
        this.idPull[k.id] = k;
    } else {
        var polygon = this.idPull["polygon_"+this.itemPull[id]["parent"]];
        if (pos != null) { pos++; if (pos < 0) pos = 0; if (pos > polygon.tbd.childNodes.length - 1) pos = null; }
        if (pos != null && polygon.tbd.childNodes[pos] != null) polygon.tbd.insertBefore(tr, polygon.tbd.childNodes[pos]); else polygon.tbd.appendChild(tr);
        td.appendChild(k);
        this.idPull[k.id] = tr;
    }
};

dhtmlXMenuObject.prototype.addNewSeparator = function(nextToId, itemId) {
    itemId = this.idPrefix+(itemId!=null?itemId:this._genStr(24));
    var parentId = this.idPrefix+this.getParentId(nextToId);

    this._addItemIntoGlobalStrorage(itemId, parentId, "", "separator", false, "", "");
    this._renderSeparator(itemId, this.getItemPosition(nextToId));
};


dhtmlXMenuObject.prototype._initObj = function(items, nested, parentId) {

    if (!(items instanceof Array)) {
        parentId = items.parentId;
        if (parentId != null && String(parentId).indexOf(this.idPrefix) !== 0) parentId = this.idPrefix+String(parentId);
        items = items.items;
    }

    for (var q=0; q<items.length; q++) {

        // api-init, items w/o id
        if (typeof(items[q].id) == "undefined" || items[q].id == null) {
            items[q].id = this._genStr(24);
        }

        // empty text fix
        if (items[q].text == null) items[q].text = "";

        // api-init, add idPrefix
        if (String(items[q].id).indexOf(this.idPrefix) !== 0) {
            items[q].id = this.idPrefix+String(items[q].id);
        }

        var k = {type: "item", tip: "", hotkey: "", state: "enabled", imgen: "", imgdis: ""};
        for (var a in k) { if (typeof(items[q][a]) == "undefined") items[q][a] = k[a]; }

        //
        if (items[q].imgen == "" && items[q].img != null) items[q].imgen = items[q].img;
        if (items[q].imgdis == "" && items[q].img_disabled != null) items[q].imgdis = items[q].img_disabled;
        if (items[q].title == null && items[q].text != null) items[q].title = items[q].text;

        // hrefs
        if (items[q].href != null) {
            if (items[q].href.link != null) items[q].href_link = items[q].href.link;
            if (items[q].href.target != null) items[q].href_target = items[q].href.target;
        }

        // userdata
        if (items[q].userdata != null) {
            for (var a in items[q].userdata) this.userData[items[q].id+"_"+a] = items[q].userdata[a];
        }


        // en/dis
        if (typeof(items[q].enabled) != "undefined" && window.dhx4.s2b(items[q].enabled) == false) {
            items[q].state = "disabled";
        } else if (typeof(items[q].disabled) != "undefined" && window.dhx4.s2b(items[q].disabled) == true) {
            items[q].state = "disabled";
        }

        //
        if (typeof(items[q].parent) == "undefined") {
            items[q].parent = (parentId != null ? parentId : this.idPrefix+this.topId);
        }


        // checkbox
        if (items[q].type == "checkbox") {
            items[q].checked = window.dhx4.s2b(items[q].checked);
            items[q].imgen = items[q].imgdis = "chbx_"+(items[q].checked?"1":"0"); // set classname
        }
        // radio
        if (items[q].type == "radio") {
            items[q].checked = window.dhx4.s2b(items[q].checked);
            items[q].imgen = items[q].imgdis = "rdbt_"+(items[q].checked?"1":"0");
            // group
            if (typeof(items[q].group) == "undefined" || items[q].group == null) items[q].group = this._genStr(24);
            if (this.radio[items[q].group] == null) this.radio[items[q].group] = [];
            this.radio[items[q].group].push(items[q].id);
        }

        //
        this.itemPull[items[q].id] = items[q];
        if (items[q].items != null && items[q].items.length > 0) {
            this.itemPull[items[q].id].complex = true;
            this._initObj(items[q].items, true, items[q].id);
        } else if (this.conf.dload && items[q].complex == true) {
            this.itemPull[items[q].id].loaded = "no";
        }
        this.itemPull[items[q].id].items = null;

    }

    if (nested !== true) {
        if (this.conf.dload == true) {
            if (parentId == null) {
                this._initTopLevelMenu();
            } else {
                this._addSubMenuPolygon(parentId, parentId);
                if (this.conf.selected == parentId) {
                    var isTop = (this.itemPull[parentId].parent == this.idPrefix+this.topId);
                    var level = (isTop && !this.conf.context ? this.conf.dir_toplv:this.conf.dir_sublv);
                    var isShow = false;
                    if (isTop && this.conf.top_mode && this.conf.mode == "web" && !this.conf.context) {
                        var item = this.idPull[parentId];
                        if (item._mouseOver == true) {
                            var delay = this.conf.top_tmtime - (new Date().getTime()-item._dynLoadTM);
                            if (delay > 1) {
                                var pId = parentId;
                                var that = this;
                                item._menuOpenTM = window.setTimeout(function(){
                                    that._showPolygon(pId, level);
                                    that = pId = null;
                                }, delay);
                                isShow = true;
                            }
                        }
                    }
                    if (!isShow) this._showPolygon(parentId, level);
                }

                this.itemPull[parentId].loaded = "yes";
                if (this.conf.dload_icon == true) this._updateLoaderIcon(parentId, false);
            }
        } else {
            this._init();
        }
    }

};

dhtmlXMenuObject.prototype._xmlToJson = function(xml, parentId) {

    var items = [];

    if (parentId == null) {
        var root = xml.getElementsByTagName(this.conf.tags.root);
        if (root == null || (root != null && root.length == 0)) return {items:[]};
        root = root[0];
    } else {
        root = xml;
    }

    if (root.getAttribute("parentId") != null) {
        parentId = this.idPrefix+root.getAttribute("parentId");
    }

    for (var q=0; q<root.childNodes.length; q++) {
        if (typeof(root.childNodes[q].tagName) != "undefined" && String(root.childNodes[q].tagName).toLowerCase() == this.conf.tags.item) {
            var r = root.childNodes[q];
            var item = {
                // basic
                id: this.idPrefix+(r.getAttribute("id")||this._genStr(24)),
                title: r.getAttribute("text")||"",
                // images
                imgen: r.getAttribute("img")||"",
                imgdis: r.getAttribute("imgdis")||"",
                tip: "",
                hotkey: "",
                //
                type: r.getAttribute("type")||"item"
            };
            // custom css
            if (r.getAttribute("cssNormal") != null) {
                item.cssNormal = r.getAttribute("cssNormal");
            }
            // checkbox
            if (item.type == "checkbox") item.checked = r.getAttribute("checked");
            // radio
            if (item.type == "radio") {
                item.checked = r.getAttribute("checked");
                item.group = r.getAttribute("group");
            }
            // en/dis
            item.state = "enabled";
            if (r.getAttribute("enabled") != null && window.dhx4.s2b(r.getAttribute("enabled")) == false) {
                item.state = "disabled";
            } else if (r.getAttribute("disabled") != null && window.dhx4.s2b(r.getAttribute("disabled")) == true) {
                item.state = "disabled";
            }

            item.parent = (parentId != null ? parentId : this.idPrefix+this.topId);
            // is complex item
            if (this.conf.dload) {
                item.complex = (r.getAttribute("complex") != null);
                if (item.complex) item.loaded = "no";
            } else {
                var i = this._xmlToJson(r, item.id);
                item.items = i.items;
                item.complex = (item.items.length > 0);
            }

            // misc
            for (var w=0; w<r.childNodes.length; w++) {
                if (typeof(r.childNodes[w].tagName) != "undefined") {
                    var t = String(r.childNodes[w].tagName||"").toLowerCase();
                    // userdata
                    if (t == this.conf.tags.userdata) {
                        var d = r.childNodes[w];
                        if (d.getAttribute("name") != null) {
                            this.userData[item.id+"_"+d.getAttribute("name")] = (d.firstChild != null && d.firstChild.nodeValue != null ? d.firstChild.nodeValue : "");
                        }
                    }
                    // extended text
                    if (t == this.conf.tags.text_ext) {
                        item.title = r.childNodes[w].firstChild.nodeValue;
                    }
                    // tooltips
                    if (t == this.conf.tags.tooltip) {
                        item.tip = r.childNodes[w].firstChild.nodeValue;
                    }
                    // hotkeys
                    if (t == this.conf.tags.hotkey) {
                        item.hotkey = r.childNodes[w].firstChild.nodeValue;
                    }
                    // hrefs
                    if (t == this.conf.tags.href && item.type == "item") {
                        item.href_link = r.childNodes[w].firstChild.nodeValue;
                        if (r.childNodes[w].getAttribute("target") != null) {
                            item.href_target = r.childNodes[w].getAttribute("target");
                        }
                    }
                }
            }
            items.push(item);
        }
    }

    var r = {
        parentId: parentId,//(root.getAttribute("parentId")||null),
        items: items
    };

    return r;
};

// dynload
dhtmlXMenuObject.prototype.enableDynamicLoading = function(url, icon) {
    this.conf.dload = true;
    this.conf.dload_url = url;
    this.conf.dload_sign = (String(this.conf.dload_url).search(/\?/)==-1?"?":"&");
    this.conf.dload_icon = icon;
    this._init();
};

dhtmlXMenuObject.prototype._updateLoaderIcon = function(id, state) {

    if (this.idPull[id] == null) return;
    if (String(this.idPull[id].className).search("TopLevel_Item") >= 0) return;
    // get arrow
    var ind = (this.conf.rtl?0:2);
    if (!this.idPull[id].childNodes[ind]) return;
    if (!this.idPull[id].childNodes[ind].childNodes[0]) return;
    var aNode = this.idPull[id].childNodes[ind].childNodes[0];
    if (String(aNode.className).search("complex_arrow") === 0) aNode.className = "complex_arrow"+(state?"_loading":"");

};



// add/remove
dhtmlXMenuObject.prototype.addNewSibling = function(nextToId, itemId, itemText, disabled, imgEnabled, imgDisabled) {
    var id = this.idPrefix+(itemId!=null?itemId:this._genStr(24));
    var parentId = this.idPrefix+(nextToId!=null?this.getParentId(nextToId):this.topId);

    this._addItemIntoGlobalStrorage(id, parentId, itemText, "item", disabled, imgEnabled, imgDisabled);
    if ((parentId == this.idPrefix+this.topId) && (!this.conf.context)) {
        this._renderToplevelItem(id, this.getItemPosition(nextToId));
    } else {
        this._renderSublevelItem(id, this.getItemPosition(nextToId));
    }
};

dhtmlXMenuObject.prototype.addNewChild = function(parentId, pos, itemId, itemText, disabled, imgEnabled, imgDisabled) {
    if (parentId == null) {
        if (this.conf.context) {
            parentId = this.topId;
        } else {
            this.addNewSibling(parentId, itemId, itemText, disabled, imgEnabled, imgDisabled);
            if (pos != null) this.setItemPosition(itemId, pos);
            return;
        }
    }
    itemId = this.idPrefix+(itemId!=null?itemId:this._genStr(24));
    // remove hotkey, added in 0.4
    if (this.setHotKey) this.setHotKey(parentId, "");
    //
    parentId = this.idPrefix+parentId;
    this._addItemIntoGlobalStrorage(itemId, parentId, itemText, "item", disabled, imgEnabled, imgDisabled);
    if (this.idPull["polygon_"+parentId] == null) { this._renderSublevelPolygon(parentId, parentId); }
    this._renderSublevelItem(itemId, pos-1);

    this._redefineComplexState(parentId);
};

dhtmlXMenuObject.prototype.removeItem = function(id, _isTId, _recCall) {
    if (!_isTId) id = this.idPrefix + id;

    var pId = null;

    if (id != this.idPrefix+this.topId) {

        if (this.itemPull[id] == null) return;

        // effects
        if (this.idPull["polygon_"+id] && this.idPull["polygon_"+id]._tmShow) window.clearTimeout(this.idPull["polygon_"+id]._tmShow);

        // separator top
        var t = this.itemPull[id]["type"];

        if (t == "separator") {
            var item = this.idPull["separator_"+id];
            if (this.itemPull[id]["parent"] == this.idPrefix+this.topId) {
                item.onclick = null;
                item.onselectstart = null;
                item.id = null;
                item.parentNode.removeChild(item);
            } else {
                item.childNodes[0].childNodes[0].onclick = null;
                item.childNodes[0].childNodes[0].onselectstart = null;
                item.childNodes[0].childNodes[0].id = null;
                item.childNodes[0].removeChild(item.childNodes[0].childNodes[0]);
                item.removeChild(item.childNodes[0]);
                item.parentNode.removeChild(item);
            }
            this.idPull["separator_"+id] = null;
            this.itemPull[id] = null;
            delete this.idPull["separator_"+id];
            delete this.itemPull[id];
            item = null;
        } else {
            // item checkbox radio
            pId = this.itemPull[id]["parent"];
            var item = this.idPull[id];
            item.onclick = null;
            item.oncontextmenu = null;
            item.onmouseover = null;
            item.onmouseout = null;
            item.onselectstart = null;
            item.id = null;
            while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
            item.parentNode.removeChild(item);
            this.idPull[id] = null;
            this.itemPull[id] = null;
            delete this.idPull[id];
            delete this.itemPull[id];
            item = null;

        }
        t = null;
    }

    // clear nested items
    for (var a in this.itemPull) if (this.itemPull[a]["parent"] == id) this.removeItem(a, true, true);

    // check if empty polygon left
    var p2 = new Array(id);
    if (pId != null && !_recCall) {
        if (this.idPull["polygon_"+pId] != null) {
            if (this.idPull["polygon_"+pId].tbd.childNodes.length == 0) {
                p2.push(pId);
                this._updateItemComplexState(pId, false, false);
            }
        }
    }

    // delete nested polygons and parent's if any
    for (var q=0; q<p2.length; q++) {
        if (this.idPull["polygon_"+p2[q]]) {
            var p = this.idPull["polygon_"+p2[q]];
            p.onclick = null;
            p.oncontextmenu = null;
            p.tbl.removeChild(p.tbd);
            p.tbd = null;
            p.childNodes[1].removeChild(p.tbl);
            p.tbl = null;
            p.id = null;
            p.parentNode.removeChild(p);
            p = null;
            if (window.dhx4.isIE6) {
                var pc = "polygon_"+p2[q]+"_ie6cover";
                if (this.idPull[pc] != null) { document.body.removeChild(this.idPull[pc]); delete this.idPull[pc]; }
            }
            if (this.idPull["arrowup_"+id] != null && this._removeArrow) this._removeArrow("arrowup_"+id);
            if (this.idPull["arrowdown_"+id] != null && this._removeArrow) this._removeArrow("arrowdown_"+id);
            //
            this.idPull["polygon_"+p2[q]] = null;
            delete this.idPull["polygon_"+p2[q]];
        }
    }
    p2 = null;

    // update corners
    if (this.conf.skin == "dhx_terrace" && arguments.length == 1) this._improveTerraceSkin();

};


// add item to storage
dhtmlXMenuObject.prototype._addItemIntoGlobalStrorage = function(itemId, itemParentId, itemText, itemType, disabled, img, imgDis) {
    var item = {
        id:	itemId,
        title:	itemText,
        imgen:	(img!=null?img:""),
        imgdis:	(imgDis!=null?imgDis:""),
        type:	itemType,
        state:	(disabled==true?"disabled":"enabled"),
        parent:	itemParentId,
        complex:false,
        hotkey:	"",
        tip:	""};
    this.itemPull[item.id] = item;
};

dhtmlXMenuObject.prototype.renderAsContextMenu = function() {
    this.conf.context = true;
    if (this.base._autoSkinUpdate == true) {
        this.base.className = this.base.className.replace("dhtmlxMenu_"+this.conf.skin+"_Middle","");
        this.base._autoSkinUpdate = false;
    }
    if (this.conf.ctx_baseid != null) { this.addContextZone(this.conf.ctx_baseid); }
};

dhtmlXMenuObject.prototype.addContextZone = function(zoneId) {
    if (zoneId == document.body) {
        zoneId = "document.body."+this.idPrefix;
        var zone = document.body;
    } else if (typeof(zoneId) == "string") {
        var zone = document.getElementById(zoneId);
    } else {
        var zone = zoneId;
    }
    var zoneExists = false;
    for (var a in this.conf.ctx_zones) { zoneExists = zoneExists || (a == zoneId) || (this.conf.ctx_zones[a] == zone); }
    if (zoneExists == true) return false;
    this.conf.ctx_zones[zoneId] = zone;
    var that = this;
    if (window.dhx4.isOpera) {
        this.operaContext = function(e){ that._doOnContextMenuOpera(e, that); }
        zone.addEventListener("mouseup", this.operaContext, false);
        //
    } else {
        if (zone.oncontextmenu != null && !zone._oldContextMenuHandler) zone._oldContextMenuHandler = zone.oncontextmenu;
        zone.oncontextmenu = function(e) {
            // autoclose any other opened context menues
            for (var q in dhtmlXMenuObject.prototype.liveInst) {
                if (q != that.conf.live_id) {
                    if (dhtmlXMenuObject.prototype.liveInst[q].context) {
                        dhtmlXMenuObject.prototype.liveInst[q]._hideContextMenu();
                    }
                }
            }
            //
            e = e||event;
            e.cancelBubble = true;
            if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
            that._doOnContextBeforeCall(e, this);
            return false;
        }
    }
};
dhtmlXMenuObject.prototype._doOnContextMenuOpera = function(e, that) {
    // autoclose any other opened context menues
    for (var q in dhtmlXMenuObject.prototype.liveInst) {
        if (q != that.conf.live_id) {
            if (dhtmlXMenuObject.prototype.liveInst[q].context) {
                dhtmlXMenuObject.prototype.liveInst[q]._hideContextMenu();
            }
        }
    }
    //
    e.cancelBubble = true;
    if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
    if (e.button == 0 && e.ctrlKey == true) { that._doOnContextBeforeCall(e, this); }
    return false;
};

dhtmlXMenuObject.prototype.removeContextZone = function(zoneId) {
    if (!this.isContextZone(zoneId)) return false;
    if (zoneId == document.body) zoneId = "document.body."+this.idPrefix;
    var zone = this.conf.ctx_zones[zoneId];
    if (window.dhx4.isOpera) {
        zone.removeEventListener("mouseup", this.operaContext, false);
    } else {
        zone.oncontextmenu = (zone._oldContextMenuHandler!=null?zone._oldContextMenuHandler:null);
        zone._oldContextMenuHandler = null;
    }
    try {
        this.conf.ctx_zones[zoneId] = null;
        delete this.conf.ctx_zones[zoneId];
    } catch(e){}
    return true;
};

dhtmlXMenuObject.prototype.isContextZone = function(zoneId) {
    if (zoneId == document.body && this.conf.ctx_zones["document.body."+this.idPrefix] != null) return true;
    var isZone = false;
    if (this.conf.ctx_zones[zoneId] != null) { if (this.conf.ctx_zones[zoneId] == document.getElementById(zoneId)) isZone = true; }
    return isZone;
};
dhtmlXMenuObject.prototype._isContextMenuVisible = function() {
    if (this.idPull["polygon_"+this.idPrefix+this.topId] == null) return false;
    return (this.idPull["polygon_"+this.idPrefix+this.topId].style.display == "");
};
dhtmlXMenuObject.prototype._showContextMenu = function(x, y, zoneId) {
    // hide any opened context menu/polygons
    this._clearAndHide();
    // open
    if (this.idPull["polygon_"+this.idPrefix+this.topId] == null) return false;
    window.clearTimeout(this.conf.tm_handler);
    this.idPull[this.idPrefix+this.topId] = new Array(x, y);
    this._showPolygon(this.idPrefix+this.topId, "bottom");
    this.callEvent("onContextMenu", [zoneId]);
};
dhtmlXMenuObject.prototype._hideContextMenu = function() {
    if (this.idPull["polygon_"+this.idPrefix+this.topId] == null) return false;
    this._clearAndHide();
    this._hidePolygon(this.idPrefix+this.topId);
};

dhtmlXMenuObject.prototype._doOnContextBeforeCall = function(e, cZone) {
    this.conf.ctx_zoneid = cZone.id;
    this._clearAndHide();
    this._hideContextMenu();

    // scroll settings
    var p = (e.srcElement||e.target);
    var px = (window.dhx4.isIE||window.dhx4.isOpera||window.dhx4.isKHTML?e.offsetX:e.layerX);
    var py = (window.dhx4.isIE||window.dhx4.isOpera||window.dhx4.isKHTML?e.offsetY:e.layerY);
    var mx = window.dhx4.absLeft(p)+px;
    var my = window.dhx4.absTop(p)+py;

    if (this.checkEvent("onBeforeContextMenu")) {
        if (this.callEvent("onBeforeContextMenu", [cZone.id,e])) {
            if (this.conf.ctx_autoshow) {
                this._showContextMenu(mx, my, cZone.id);
                this.callEvent("onAfterContextMenu", [cZone.id,e]);
            }
        }
    } else {
        if (this.conf.ctx_autoshow) {
            this._showContextMenu(mx, my, cZone.id);
            this.callEvent("onAfterContextMenu", [cZone.id]);
        }
    }
};

dhtmlXMenuObject.prototype.showContextMenu = function(x, y) {
    this._showContextMenu(x, y, false);
};

dhtmlXMenuObject.prototype.hideContextMenu = function() {
    this._hideContextMenu();
};

dhtmlXMenuObject.prototype.setAutoShowMode = function(mode) {
    this.conf.ctx_autoshow = (mode==true?true:false);
};

dhtmlXMenuObject.prototype.setAutoHideMode = function(mode) {
    this.conf.ctx_autohide = (mode==true?true:false);
};

dhtmlXMenuObject.prototype.setContextMenuHideAllMode = function(mode) {
    this.conf.ctx_hideall = (mode==true?true:false);
};

dhtmlXMenuObject.prototype.getContextMenuHideAllMode = function() {
    return this.conf.ctx_hideall;
};

dhtmlXMenuObject.prototype._improveTerraceSkin = function() {

    for (var a in this.itemPull) {

        if (this.itemPull[a].parent == this.idPrefix+this.topId && this.idPull[a] != null) { // this.idPull[a] will null for separator

            var bl = false;
            var br = false;

            // left side, first item, not sep
            if (this.idPull[a].parentNode.firstChild == this.idPull[a]) {
                bl = true;
            }

            // right side, last item, not sep
            if (this.idPull[a].parentNode.lastChild == this.idPull[a]) {
                br = true;
            }

            // check siblings
            for (var b in this.itemPull) {
                if (this.itemPull[b].type == "separator" && this.itemPull[b].parent == this.idPrefix+this.topId) {
                    if (this.idPull[a].nextSibling == this.idPull["separator_"+b]) {
                        br = true;
                    }
                    if (this.idPull[a].previousSibling == this.idPull["separator_"+b]) {
                        bl = true;
                    }
                }
            }

            this.idPull[a].style.borderLeftWidth = (bl?"1px":"0px");
            this.idPull[a].style.borderTopLeftRadius = this.idPull[a].style.borderBottomLeftRadius = (bl?"3px":"0px");

            this.idPull[a].style.borderTopRightRadius = this.idPull[a].style.borderBottomRightRadius = (br?"3px":"0px");

            this.idPull[a]._bl = bl;
            this.idPull[a]._br = br;

        }
    }

};

dhtmlXMenuObject.prototype._improveTerraceButton = function(id, state) {
    if (state) {
        this.idPull[id].style.borderBottomLeftRadius = (this.idPull[id]._bl ? "3px" : "0px");
        this.idPull[id].style.borderBottomRightRadius = (this.idPull[id]._br ? "3px" : "0px");
    } else {
        this.idPull[id].style.borderBottomLeftRadius = "0px";
        this.idPull[id].style.borderBottomRightRadius = "0px";
    }
};

if (typeof(window.dhtmlXCellObject) != "undefined") {

    dhtmlXCellObject.prototype._createNode_menu = function(obj, type, htmlString, append, node) {

        if (typeof(node) != "undefined") {
            obj = node;
        } else {
            obj = document.createElement("DIV");
            obj.className = "dhx_cell_menu_"+(this.conf.borders?"def":"no_borders");
            obj.appendChild(document.createElement("DIV"));
        }

        this.cell.insertBefore(obj, this.cell.childNodes[this.conf.idx.toolbar||this.conf.idx.cont]); // before toolbar or before cont, 0=hdr

        this.conf.ofs_nodes.t.menu = true;
        this._updateIdx();
        // adjust cont will performed after toolbar init

        return obj;

    };

    dhtmlXCellObject.prototype.attachMenu = function(conf) {

        if (this.dataNodes.menu) return; // return this.dataNodes.menu?

        if (typeof(conf) == "undefined") conf = {};
        if (typeof(conf.skin) == "undefined") conf.skin = this.conf.skin;
        conf.parent = this._attachObject("menu").firstChild;

        this.dataNodes.menu = new dhtmlXMenuObject(conf);
        this._adjustCont(this._idd);

        conf.parent = null;
        conf = null;

        return this.dataNodes.menu;

    };

    dhtmlXCellObject.prototype.detachMenu = function() {

        if (!this.dataNodes.menu) return;
        this.dataNodes.menu.unload();
        this.dataNodes.menu = null;
        delete this.dataNodes.menu;

        this._detachObject("menu");

    };

    dhtmlXCellObject.prototype.showMenu = function() {
        this._mtbShowHide("menu", "");
    };

    dhtmlXCellObject.prototype.hideMenu = function() {
        this._mtbShowHide("menu", "none");
    };

    dhtmlXCellObject.prototype.getAttachedMenu = function() {
        return this.dataNodes.menu;
    };

}

/*
Product Name: dhtmlxSuite
Version: 4.1.2
Edition: Standard
License: content of this file is covered by GPL. Usage outside GPL terms is prohibited. To obtain Commercial or Enterprise license contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXMenuObject.prototype.loadXML = function(xmlFile, onLoad) {
    this.loadStruct(xmlFile, onLoad);
};
dhtmlXMenuObject.prototype.loadXMLString = function(xmlString, onLoad) {
    this.loadStruct(xmlString, onLoad);
};
dhtmlXMenuObject.prototype.setIconPath = function(path) {
    this.setIconsPath(path);
};
dhtmlXMenuObject.prototype.setImagePath = function() {
    /* no more used, from 90226 */
};

/*
Product Name: dhtmlxSuite
Version: 4.1.2
Edition: Standard
License: content of this file is covered by GPL. Usage outside GPL terms is prohibited. To obtain Commercial or Enterprise license contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

// enable/disable

dhtmlXMenuObject.prototype.setItemEnabled = function(id) {
    this._changeItemState(id, "enabled", this._getItemLevelType(id));
};
dhtmlXMenuObject.prototype.setItemDisabled = function(id) {
    this._changeItemState(id, "disabled", this._getItemLevelType(id));
};
dhtmlXMenuObject.prototype.isItemEnabled = function(id) {
    return (this.itemPull[this.idPrefix+id]!=null?(this.itemPull[this.idPrefix+id]["state"]=="enabled"):false);
};

// enable/disable sublevel item
dhtmlXMenuObject.prototype._changeItemState = function(id, newState, levelType) {
    var t = false;
    var j = this.idPrefix + id;
    if ((this.itemPull[j] != null) && (this.idPull[j] != null)) {
        if (this.itemPull[j]["state"] != newState) {
            this.itemPull[j]["state"] = newState;
            if (this.itemPull[j]["parent"] == this.idPrefix+this.topId && !this.conf.context) {
                this.idPull[j].className = "dhtmlxMenu_"+this.conf.skin+"_TopLevel_Item_"+(this.itemPull[j]["state"]=="enabled"?"Normal":"Disabled");
            } else {
                this.idPull[j].className = "sub_item"+(this.itemPull[j]["state"]=="enabled"?"":"_dis");
            }

            this._updateItemComplexState(this.idPrefix+id, this.itemPull[this.idPrefix+id]["complex"], false);
            this._updateItemImage(id, levelType);
            // if changeItemState attached to onClick event and changing applies to selected item all selection should be reparsed
            if ((this.idPrefix + this.conf.last_click == j) && (levelType != "TopLevel")) {
                this._redistribSubLevelSelection(j, this.itemPull[j]["parent"]);
            }
            if (levelType == "TopLevel" && !this.conf.context) { // rebuild style.left and show nested polygons
                // this._redistribTopLevelSelection(id, "parent");
            }
        }
    }
    return t;
};


// set-get text
dhtmlXMenuObject.prototype.getItemText = function(id) {
    return (this.itemPull[this.idPrefix+id]!=null?this.itemPull[this.idPrefix+id]["title"]:"");
};

dhtmlXMenuObject.prototype.setItemText = function(id, text) {
    id = this.idPrefix + id;
    if ((this.itemPull[id] != null) && (this.idPull[id] != null)) {
        this._clearAndHide();
        this.itemPull[id]["title"] = text;
        if (this.itemPull[id]["parent"] == this.idPrefix+this.topId && !this.conf.context) {
            // top level
            var tObj = null;
            for (var q=0; q<this.idPull[id].childNodes.length; q++) {
                try { if (this.idPull[id].childNodes[q].className == "top_level_text") tObj = this.idPull[id].childNodes[q]; } catch(e) {}
            }
            if (String(this.itemPull[id]["title"]).length == "" || this.itemPull[id]["title"] == null) {
                if (tObj != null) tObj.parentNode.removeChild(tObj);
            } else {
                if (!tObj) {
                    tObj = document.createElement("DIV");
                    tObj.className = "top_level_text";
                    if (this.conf.rtl && this.idPull[id].childNodes.length > 0) this.idPull[id].insertBefore(tObj,this.idPull[id].childNodes[0]); else this.idPull[id].appendChild(tObj);
                }
                tObj.innerHTML = this.itemPull[id]["title"];
            }
        } else {
            // sub level
            var tObj = null;
            for (var q=0; q<this.idPull[id].childNodes[1].childNodes.length; q++) {
                if (String(this.idPull[id].childNodes[1].childNodes[q].className||"") == "sub_item_text") tObj = this.idPull[id].childNodes[1].childNodes[q];
            }
            if (String(this.itemPull[id]["title"]).length == "" || this.itemPull[id]["title"] == null) {
                if (tObj) {
                    tObj.parentNode.removeChild(tObj);
                    tObj = null;
                    this.idPull[id].childNodes[1].innerHTML = "&nbsp;";
                }
            } else {
                if (!tObj) {
                    tObj = document.createElement("DIV");
                    tObj.className = "sub_item_text";
                    this.idPull[id].childNodes[1].innerHTML = "";
                    this.idPull[id].childNodes[1].appendChild(tObj);
                }
                tObj.innerHTML = this.itemPull[id]["title"];
            }
        }
    }
};

// load from html
dhtmlXMenuObject.prototype.loadFromHTML = function(objId, clearAfterAdd, onLoad) {

    var t = this.conf.tags.item;
    this.conf.tags.item = "div";

    var node = (typeof(objId)=="string"?document.getElementById(objId):objId);
    var items = this._xmlToJson(node, this.idPrefix+this.topId);
    this._initObj(items);

    this.conf.tags.item = t;

    if (clearAfterAdd) node.parentNode.removeChild(node);
    node = objOd = null;

    if (onload != null) {
        if (typeof(onLoad) == "function") {
            onLoad();
        } else if (typeof(window[onLoad]) == "function") {
            window[onLoad]();
        }
    }
};

// show/hide items
dhtmlXMenuObject.prototype.hideItem = function(id) {
    this._changeItemVisible(id, false);
};

dhtmlXMenuObject.prototype.showItem = function(id) {
    this._changeItemVisible(id, true);
};

dhtmlXMenuObject.prototype.isItemHidden = function(id) {
    var isHidden = null;
    if (this.idPull[this.idPrefix+id] != null) { isHidden = (this.idPull[this.idPrefix+id].style.display == "none"); }
    return isHidden;
};

dhtmlXMenuObject.prototype._changeItemVisible = function(id, visible) {
    var itemId = this.idPrefix+id;
    if (this.itemPull[itemId] == null) return;
    if (this.itemPull[itemId]["type"] == "separator") { itemId = "separator_"+itemId; }
    if (this.idPull[itemId] == null) return;
    this.idPull[itemId].style.display = (visible?"":"none");
    this._redefineComplexState(this.itemPull[this.idPrefix+id]["parent"]);
};

// userdata
dhtmlXMenuObject.prototype.setUserData = function(id, name, value) {
    this.userData[this.idPrefix+id+"_"+name] = value;
};

dhtmlXMenuObject.prototype.getUserData = function(id, name) {
    return (this.userData[this.idPrefix+id+"_"+name]!=null?this.userData[this.idPrefix+id+"_"+name]:null);
};

// open-mode (win/web)
dhtmlXMenuObject.prototype.setOpenMode = function(mode) {
    this.conf.mode = (mode=="win"?"win":"web");
};

// web-mode timeout
dhtmlXMenuObject.prototype.setWebModeTimeout = function(tm) {
    this.conf.tm_sec = (!isNaN(tm)?tm:400);
};

// icons
dhtmlXMenuObject.prototype.getItemImage = function(id) {
    var imgs = new Array(null, null);
    id = this.idPrefix+id;
    if (this.itemPull[id]["type"] == "item") {
        imgs[0] = this.itemPull[id]["imgen"];
        imgs[1] = this.itemPull[id]["imgdis"];
    }
    return imgs;
};

dhtmlXMenuObject.prototype.setItemImage = function(id, img, imgDis) {
    if (this.itemPull[this.idPrefix+id]["type"] != "item") return;
    this.itemPull[this.idPrefix+id]["imgen"] = img;
    this.itemPull[this.idPrefix+id]["imgdis"] = imgDis;
    this._updateItemImage(id, this._getItemLevelType(id));
};

dhtmlXMenuObject.prototype.clearItemImage = function(id) {
    this.setItemImage(id, "", "");
};

// visible area
dhtmlXMenuObject.prototype.setVisibleArea = function(x1, x2, y1, y2) {
    this.conf.v_enabled = true;
    this.conf.v.x1 = x1;
    this.conf.v.x2 = x2;
    this.conf.v.y1 = y1;
    this.conf.v.y2 = y2;
};

// tooltips
dhtmlXMenuObject.prototype.setTooltip = function(id, tip) {
    id = this.idPrefix+id;
    if (!(this.itemPull[id] != null && this.idPull[id] != null)) return;
    this.idPull[id].title = (tip.length > 0 ? tip : null);
    this.itemPull[id]["tip"] = tip;
};

dhtmlXMenuObject.prototype.getTooltip = function(id) {
    if (this.itemPull[this.idPrefix+id] == null) return null;
    return this.itemPull[this.idPrefix+id]["tip"];
};



dhtmlXMenuObject.prototype.setTopText = function(text) {
    if (this.conf.context) return;
    if (this._topText == null) {
        this._topText = document.createElement("DIV");
        this._topText.className = "dhtmlxMenu_TopLevel_Text_"+(this.conf.rtl?"left":(this.conf.align=="left"?"right":"left"));
        this.base.appendChild(this._topText);
    }
    this._topText.innerHTML = text;
};

dhtmlXMenuObject.prototype.setAlign = function(align) {
    if (this.conf.align == align) return;
    if (align == "left" || align == "right") {
        // if (this.setRTL) this.setRTL(false);
        this.conf.align = align;
        if (this.cont) this.cont.className = (this.conf.align=="right"?"align_right":"align_left");
        if (this._topText != null) this._topText.className = "dhtmlxMenu_TopLevel_Text_"+(this.conf.align=="left"?"right":"left");
    }
};

dhtmlXMenuObject.prototype.setHref = function(itemId, href, target) {
    if (this.itemPull[this.idPrefix+itemId] == null) return;
    this.itemPull[this.idPrefix+itemId]["href_link"] = href;
    if (target != null) this.itemPull[this.idPrefix+itemId]["href_target"] = target;
};

dhtmlXMenuObject.prototype.clearHref = function(itemId) {
    if (this.itemPull[this.idPrefix+itemId] == null) return;
    delete this.itemPull[this.idPrefix+itemId]["href_link"];
    delete this.itemPull[this.idPrefix+itemId]["href_target"];
};
/*
File [id="file"] -> Open [id="open"] -> Last Save [id="lastsave"]
getCircuit("lastsave") will return Array("file", "open", "lastsave");
*/

dhtmlXMenuObject.prototype.getCircuit = function(id) {
    var parents = new Array(id);
    while (this.getParentId(id) != this.topId) {
        id = this.getParentId(id);
        parents[parents.length] = id;
    }
    return parents.reverse();
};

// checkboxes
dhtmlXMenuObject.prototype._getCheckboxState = function(id) {
    if (this.itemPull[this.idPrefix+id] == null) return null;
    return this.itemPull[this.idPrefix+id]["checked"];
};

dhtmlXMenuObject.prototype._setCheckboxState = function(id, state) {
    if (this.itemPull[this.idPrefix+id] == null) return;
    this.itemPull[this.idPrefix+id]["checked"] = state;
};

dhtmlXMenuObject.prototype._updateCheckboxImage = function(id) {
    if (this.idPull[this.idPrefix+id] == null) return;
    this.itemPull[this.idPrefix+id]["imgen"] = "chbx_"+(this._getCheckboxState(id)?"1":"0");
    this.itemPull[this.idPrefix+id]["imgdis"] = this.itemPull[this.idPrefix+id]["imgen"];
    try { this.idPull[this.idPrefix+id].childNodes[(this.conf.rtl?2:0)].childNodes[0].className = "sub_icon "+this.itemPull[this.idPrefix+id]["imgen"]; } catch(e){}
};

dhtmlXMenuObject.prototype._checkboxOnClickHandler = function(id, type, casState) {
    if (type.charAt(1)=="d") return;
    if (this.itemPull[this.idPrefix+id] == null) return;
    var state = this._getCheckboxState(id);
    if (this.checkEvent("onCheckboxClick")) {
        if (this.callEvent("onCheckboxClick", [id, state, this.conf.ctx_zoneid, casState])) {
            this.setCheckboxState(id, !state);
        }
    } else {
        this.setCheckboxState(id, !state);
    }
    // call onClick if exists
    if (this.checkEvent("onClick")) this.callEvent("onClick", [id]);
};

dhtmlXMenuObject.prototype.setCheckboxState = function(id, state) {
    this._setCheckboxState(id, state);
    this._updateCheckboxImage(id);
};

dhtmlXMenuObject.prototype.getCheckboxState = function(id) {
    return this._getCheckboxState(id);
};

dhtmlXMenuObject.prototype.addCheckbox = function(mode, nextToId, pos, itemId, itemText, state, disabled) {
    // checks
    if (this.conf.context && nextToId == this.topId) {
        // adding checkbox as first element to context menu
        // do nothing
    } else {
        if (this.itemPull[this.idPrefix+nextToId] == null) return;
        if (mode == "child" && this.itemPull[this.idPrefix+nextToId]["type"] != "item") return;
    }
    //
    var img = "chbx_"+(state?"1":"0");
    var imgDis = img;
    //

    if (mode == "sibling") {

        var id = this.idPrefix+(itemId!=null?itemId:this._genStr(24));
        var parentId = this.idPrefix+this.getParentId(nextToId);
        this._addItemIntoGlobalStrorage(id, parentId, itemText, "checkbox", disabled, img, imgDis);
        this.itemPull[id]["checked"] = state;
        this._renderSublevelItem(id, this.getItemPosition(nextToId));
    } else {

        var id = this.idPrefix+(itemId!=null?itemId:this._genStr(24));
        var parentId = this.idPrefix+nextToId;
        this._addItemIntoGlobalStrorage(id, parentId, itemText, "checkbox", disabled, img, imgDis);
        this.itemPull[id]["checked"] = state;
        if (this.idPull["polygon_"+parentId] == null) { this._renderSublevelPolygon(parentId, parentId); }
        this._renderSublevelItem(id, pos-1);
        this._redefineComplexState(parentId);
    }
};


// hot-keys
dhtmlXMenuObject.prototype.setHotKey = function(id, hkey) {

    id = this.idPrefix+id;

    if (!(this.itemPull[id] != null && this.idPull[id] != null)) return;
    if (this.itemPull[id]["parent"] == this.idPrefix+this.topId && !this.conf.context) return;
    if (this.itemPull[id]["complex"]) return;
    var t = this.itemPull[id]["type"];
    if (!(t == "item" || t == "checkbox" || t == "radio")) return;

    // retrieve obj
    var hkObj = null;
    try { if (this.idPull[id].childNodes[this.conf.rtl?0:2].childNodes[0].className == "sub_item_hk") hkObj = this.idPull[id].childNodes[this.conf.rtl?0:2].childNodes[0]; } catch(e){}

    if (hkey.length == 0) {
        // remove if exists
        this.itemPull[id]["hotkey_backup"] = this.itemPull[id]["hotkey"];
        this.itemPull[id]["hotkey"] = "";
        if (hkObj != null) hkObj.parentNode.removeChild(hkObj);

    } else {

        // add if needed or change
        this.itemPull[id]["hotkey"] = hkey;
        this.itemPull[id]["hotkey_backup"] = null;
        //
        if (hkObj == null) {
            hkObj = document.createElement("DIV");
            hkObj.className = "sub_item_hk";
            var item = this.idPull[id].childNodes[this.conf.rtl?0:2];
            while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
            item.appendChild(hkObj);
        }
        hkObj.innerHTML = hkey;

    }
};

dhtmlXMenuObject.prototype.getHotKey = function(id) {
    if (this.itemPull[this.idPrefix+id] == null) return null;
    return this.itemPull[this.idPrefix+id]["hotkey"];
};


// overflow control
dhtmlXMenuObject.prototype._clearAllSelectedSubItemsInPolygon = function(polygon) {
    var subIds = this._getSubItemToDeselectByPolygon(polygon);
    // hide opened polygons and selected items
    for (var q=0; q<this.conf.opened_poly.length; q++) {
        if (this.conf.opened_poly[q] != polygon) this._hidePolygon(this.conf.opened_poly[q]);
    }
    for (var q=0; q<subIds.length; q++) {
        if (this.idPull[subIds[q]] != null && this.itemPull[subIds[q]]["state"] == "enabled") {
            this.idPull[subIds[q]].className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_Item_Normal";
        }
    }
};

// define normal/disabled arrows in polygon
dhtmlXMenuObject.prototype._checkArrowsState = function(id) {
    var polygon = this.idPull["polygon_"+id].childNodes[1];
    var arrowUp = this.idPull["arrowup_"+id];
    var arrowDown = this.idPull["arrowdown_"+id];
    if (polygon.scrollTop == 0) {
        arrowUp.className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_ArrowUp_Disabled";
    } else {
        arrowUp.className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_ArrowUp" + (arrowUp.over ? "_Over" : "");
    }
    if (polygon.scrollTop + polygon.offsetHeight < polygon.scrollHeight) {
        arrowDown.className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_ArrowDown" + (arrowDown.over ? "_Over" : "");
    } else {
        arrowDown.className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_ArrowDown_Disabled";
    }
    polygon = arrowUp = arrowDown = null;
};

// add up-limit-arrow
dhtmlXMenuObject.prototype._addUpArrow = function(id) {
    var that = this;
    var arrow = document.createElement("DIV");
    arrow.pId = this.idPrefix+id;
    arrow.id = "arrowup_"+this.idPrefix+id;
    arrow.className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_ArrowUp";

    arrow.over = false;
    arrow.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
    arrow.oncontextmenu = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
    // actions
    arrow.onmouseover = function() {
        if (that.conf.mode == "web") { window.clearTimeout(that.conf.tm_handler); }
        that._clearAllSelectedSubItemsInPolygon(this.pId);
        if (this.className == "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowUp_Disabled") return;
        this.className = "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowUp_Over";
        this.over = true;
        that._canScrollUp = true;
        that._doScrollUp(this.pId, true);
    }
    arrow.onmouseout = function() {
        if (that.conf.mode == "web") {
            window.clearTimeout(that.conf.tm_handler);
            that.conf.tm_handler = window.setTimeout(function(){that._clearAndHide();}, that.conf.tm_sec, "JavaScript");
        }
        this.over = false;
        that._canScrollUp = false;
        if (this.className == "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowUp_Disabled") return;
        this.className = "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowUp";
        window.clearTimeout(that.conf.of_utm);
    }
    arrow.onclick = function(e) {
        e = e||event;
        if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
        e.cancelBubble = true;
        return false;
    }

    var polygon = this.idPull["polygon_"+this.idPrefix+id];
    polygon.childNodes[0].appendChild(arrow);

    this.idPull[arrow.id] = arrow;
    polygon = arrow = null;
};

dhtmlXMenuObject.prototype._addDownArrow = function(id) {

    var that = this;
    var arrow = document.createElement("DIV");
    arrow.pId = this.idPrefix+id;
    arrow.id = "arrowdown_"+this.idPrefix+id;
    arrow.className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_ArrowDown";

    arrow.over = false;
    arrow.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
    arrow.oncontextmenu = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }

    // actions
    arrow.onmouseover = function() {
        if (that.conf.mode == "web") { window.clearTimeout(that.conf.tm_handler); }
        that._clearAllSelectedSubItemsInPolygon(this.pId);
        if (this.className == "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowDown_Disabled") return;
        this.className = "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowDown_Over";
        this.over = true;
        that._canScrollDown = true;
        that._doScrollDown(this.pId, true);
    }
    arrow.onmouseout = function() {
        if (that.conf.mode == "web") {
            window.clearTimeout(that.conf.tm_handler);
            that.conf.tm_handler = window.setTimeout(function(){that._clearAndHide();}, that.conf.tm_sec, "JavaScript");
        }
        this.over = false;
        that._canScrollDown = false;
        if (this.className == "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowDown_Disabled") return;
        this.className = "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowDown";
        window.clearTimeout(that.conf.of_dtm);
    }
    arrow.onclick = function(e) {
        e = e||event;
        if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
        e.cancelBubble = true;
        return false;
    }

    var polygon = this.idPull["polygon_"+this.idPrefix+id];
    polygon.childNodes[2].appendChild(arrow);

    this.idPull[arrow.id] = arrow;
    polygon = arrow = null;
};

dhtmlXMenuObject.prototype._removeUpArrow = function(id) {
    var fullId = "arrowup_"+this.idPrefix+id;
    this._removeArrow(fullId);
};

dhtmlXMenuObject.prototype._removeDownArrow = function(id) {
    var fullId = "arrowdown_"+this.idPrefix+id;
    this._removeArrow(fullId);
};

dhtmlXMenuObject.prototype._removeArrow = function(fullId) {
    var arrow = this.idPull[fullId];
    arrow.onselectstart = null;
    arrow.oncontextmenu = null;
    arrow.onmouseover = null;
    arrow.onmouseout = null;
    arrow.onclick = null;
    if (arrow.parentNode) arrow.parentNode.removeChild(arrow);
    arrow = null;
    this.idPull[fullId] = null;
    try { delete this.idPull[fullId]; } catch(e) {}
};

dhtmlXMenuObject.prototype._isArrowExists = function(id) {
    if (this.idPull["arrowup_"+id] != null && this.idPull["arrowdown_"+id] != null) return true;
    return false;
};

// scroll down
dhtmlXMenuObject.prototype._doScrollUp = function(id, checkArrows) {
    var polygon = this.idPull["polygon_"+id].childNodes[1];
    if (this._canScrollUp && polygon.scrollTop > 0) {
        var theEnd = false;
        var nextScrollTop = polygon.scrollTop - this.conf.of_ustep;
        if (nextScrollTop < 0) {
            theEnd = true;
            nextScrollTop = 0;
        }
        polygon.scrollTop = nextScrollTop;
        if (!theEnd) {
            var that = this;
            this.conf.of_utm = window.setTimeout(function() {
                that._doScrollUp(id, false);
                that = null;
            }, this.conf.of_utime);
        } else {
            checkArrows = true;
        }
    } else {
        this._canScrollUp = false;
        this._checkArrowsState(id);
    }
    if (checkArrows) {
        this._checkArrowsState(id);
    }
};

dhtmlXMenuObject.prototype._doScrollDown = function(id, checkArrows) {
    var polygon = this.idPull["polygon_"+id].childNodes[1];
    if (this._canScrollDown && polygon.scrollTop + polygon.offsetHeight <= polygon.scrollHeight) {
        var theEnd = false;
        var nextScrollTop = polygon.scrollTop + this.conf.of_dstep;
        if (nextScrollTop + polygon.offsetHeight >= polygon.scrollHeight) {
            theEnd = true;
            nextScrollTop = polygon.scrollHeight - polygon.offsetHeight;
        }
        polygon.scrollTop = nextScrollTop;
        if (!theEnd) {
            var that = this;
            this.conf.of_dtm = window.setTimeout(function() {
                that._doScrollDown(id, false);
                that = null;
            }, this.conf.of_dtime);
        } else {
            checkArrows = true;
        }
    } else {
        this._canScrollDown = false;
        this._checkArrowsState(id);
    }
    if (checkArrows) {
        this._checkArrowsState(id);
    }
};

dhtmlXMenuObject.prototype._countPolygonItems = function(id) {
    var count = 0;
    for (var a in this.itemPull) {
        var par = this.itemPull[a]["parent"];
        var tp = this.itemPull[a]["type"];
        if (par == this.idPrefix+id && (tp == "item" || tp == "radio" || tp == "checkbox")) { count++; }
    }
    return count;
};

dhtmlXMenuObject.prototype.setOverflowHeight = function(itemsNum) {

    // set auto overflow mode
    if (itemsNum === "auto") {
        this.conf.overflow_limit = 0;
        this.conf.auto_overflow = true;
        return;
    }

    // no existing limitation, now new limitation
    if (this.conf.overflow_limit == 0 && itemsNum <= 0) return;

    // hide menu to prevent visible changes
    this._clearAndHide();

    // redefine existing limitation, arrows will added automatically with showPlygon
    if (this.conf.overflow_limit >= 0 && itemsNum > 0) {
        this.conf.overflow_limit = itemsNum;
        return;
    }

    // remove existing limitation
    if (this.conf.overflow_limit > 0 && itemsNum <= 0) {
        for (var a in this.itemPull) {
            if (this._isArrowExists(a)) {
                var b = String(a).replace(this.idPrefix, "");
                this._removeUpArrow(b);
                this._removeDownArrow(b);
                // remove polygon's height
                this.idPull["polygon_"+a].childNodes[1].style.height = "";
            }
        }
        this.conf.overflow_limit = 0;
        return;
    }
};


// radiobuttons
dhtmlXMenuObject.prototype._getRadioImgObj = function(id) {
    try { var imgObj = this.idPull[this.idPrefix+id].childNodes[(this.conf.rtl?2:0)].childNodes[0] } catch(e) { var imgObj = null; }
    return imgObj;
};

dhtmlXMenuObject.prototype._setRadioState = function(id, state) {
    // if (this.itemPull[this.idPrefix+id]["state"] != "enabled") return;
    var imgObj = this._getRadioImgObj(id);
    if (imgObj != null) {
        // fix, added in 0.4
        var rObj = this.itemPull[this.idPrefix+id];
        rObj["checked"] = state;
        rObj["imgen"] = "rdbt_"+(rObj["checked"]?"1":"0");
        rObj["imgdis"] = rObj["imgen"];
        imgObj.className = "sub_icon "+rObj["imgen"];
    }
};

dhtmlXMenuObject.prototype._radioOnClickHandler = function(id, type, casState) {
    if (type.charAt(1)=="d" || this.itemPull[this.idPrefix+id]["group"]==null) return;
    // deselect all from the same group
    var group = this.itemPull[this.idPrefix+id]["group"];
    if (this.checkEvent("onRadioClick")) {
        if (this.callEvent("onRadioClick", [group, this.getRadioChecked(group), id, this.conf.ctx_zoneid, casState])) {
            this.setRadioChecked(group, id);
        }
    } else {
        this.setRadioChecked(group, id);
    }
    // call onClick if exists
    if (this.checkEvent("onClick")) this.callEvent("onClick", [id]);
};

dhtmlXMenuObject.prototype.getRadioChecked = function(group) {
    var id = null;
    for (var q=0; q<this.radio[group].length; q++) {
        var itemId = this.radio[group][q].replace(this.idPrefix, "");
        var imgObj = this._getRadioImgObj(itemId);
        if (imgObj != null) {
            var checked = (imgObj.className).match(/rdbt_1$/gi);
            if (checked != null) id = itemId;
        }
    }
    return id;
};

dhtmlXMenuObject.prototype.setRadioChecked = function(group, id) {
    if (this.radio[group] == null) return;
    for (var q=0; q<this.radio[group].length; q++) {
        var itemId = this.radio[group][q].replace(this.idPrefix, "");
        this._setRadioState(itemId, (itemId==id));
    }
}

dhtmlXMenuObject.prototype.addRadioButton = function(mode, nextToId, pos, itemId, itemText, group, state, disabled) {
    // radiobutton
    if (this.conf.context && nextToId == this.topId) {
        // adding radiobutton as first element to context menu
        // do nothing
    } else {
        if (this.itemPull[this.idPrefix+nextToId] == null) return;
        if (mode == "child" && this.itemPull[this.idPrefix+nextToId]["type"] != "item") return;
    }

    var id = this.idPrefix+(itemId!=null?itemId:this._genStr(24));
    var img = "rdbt_"+(state?"1":"0");
    var imgDis = img;
    //
    if (mode == "sibling") {
        var parentId = this.idPrefix+this.getParentId(nextToId);
        this._addItemIntoGlobalStrorage(id, parentId, itemText, "radio", disabled, img, imgDis);
        this._renderSublevelItem(id, this.getItemPosition(nextToId));
    } else {
        var parentId = this.idPrefix+nextToId;
        this._addItemIntoGlobalStrorage(id, parentId, itemText, "radio", disabled, img, imgDis);
        if (this.idPull["polygon_"+parentId] == null) { this._renderSublevelPolygon(parentId, parentId); }
        this._renderSublevelItem(id, pos-1);
        this._redefineComplexState(parentId);
    }
    //
    var gr = (group!=null?group:this._genStr(24));
    this.itemPull[id]["group"] = gr;
    //
    if (this.radio[gr]==null) { this.radio[gr] = new Array(); }
    this.radio[gr][this.radio[gr].length] = id;
    //
    if (state == true) this.setRadioChecked(gr, String(id).replace(this.idPrefix, ""));
};


// serialize
dhtmlXMenuObject.prototype.serialize = function() {
    var xml = "<menu>"+this._readLevel(this.idPrefix+this.topId)+"</menu>";
    return xml;
};

dhtmlXMenuObject.prototype._readLevel = function(parentId) {
    var xml = "";
    for (var a in this.itemPull) {
        if (this.itemPull[a]["parent"] == parentId) {
            var imgEn = "";
            var imgDis = "";
            var hotKey = "";
            var itemId = String(this.itemPull[a]["id"]).replace(this.idPrefix,"");
            var itemType = "";
            var itemText = (this.itemPull[a]["title"]!=""?' text="'+this.itemPull[a]["title"]+'"':"");
            var itemState = "";
            if (this.itemPull[a]["type"] == "item") {
                if (this.itemPull[a]["imgen"] != "") imgEn = ' img="'+this.itemPull[a]["imgen"]+'"';
                if (this.itemPull[a]["imgdis"] != "") imgDis = ' imgdis="'+this.itemPull[a]["imgdis"]+'"';
                if (this.itemPull[a]["hotkey"] != "") hotKey = '<hotkey>'+this.itemPull[a]["hotkey"]+'</hotkey>';
            }
            if (this.itemPull[a]["type"] == "separator") {
                itemType = ' type="separator"';
            } else {
                if (this.itemPull[a]["state"] == "disabled") itemState = ' enabled="false"';
            }
            if (this.itemPull[a]["type"] == "checkbox") {
                itemType = ' type="checkbox"'+(this.itemPull[a]["checked"]?' checked="true"':"");
            }
            if (this.itemPull[a]["type"] == "radio") {
                itemType = ' type="radio" group="'+this.itemPull[a]["group"]+'" '+(this.itemPull[a]["checked"]?' checked="true"':"");
            }
            xml += "<item id='"+itemId+"'"+itemText+itemType+imgEn+imgDis+itemState+">";
            xml += hotKey;
            if (this.itemPull[a]["complex"]) xml += this._readLevel(a);
            xml += "</item>";
        }
    }
    return xml;
};

/*
Product Name: dhtmlxTree
Version: 4.5
Edition: Standard
License: content of this file is covered by GPL. Usage outside GPL terms is prohibited. To obtain Commercial or Enterprise license contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/*_TOPICS_
@0:Initialization
@1:Selection control
@2:Add/delete
@3:Private
@4:Node/level control
@5:Checkboxes/user data manipulation
@6:Appearence control
@7: Handlers
*/

function xmlPointer(data){
    this.d=data;
}
xmlPointer.prototype={
    text:function(){ if (!_isFF) return this.d.xml; var x = new XMLSerializer();   return x.serializeToString(this.d); },
    get:function(name){return this.d.getAttribute(name); },
    exists:function(){return !!this.d },
    content:function(){return this.d.firstChild?(this.d.firstChild.wholeText||this.d.firstChild.data):""; }, // <4k in FF
    each:function(name,f,t,i){  var a=this.d.childNodes; var c=new xmlPointer(); if (a.length) for (i=i||0; i<a.length; i++) if (a[i].tagName==name) { c.d=a[i]; if(f.apply(t,[c,i])==-1) return; } },
    get_all:function(){ var a={}; var b=this.d.attributes; for (var i=0; i<b.length; i++) a[b[i].name]=b[i].value; return a; },
    sub:function(name){ var a=this.d.childNodes; var c=new xmlPointer(); if (a.length) for (var i=0; i<a.length; i++) if (a[i].tagName==name) { c.d=a[i]; return c; } },
    up:function(name){ return new xmlPointer(this.d.parentNode);  },
    set:function(name,val){ this.d.setAttribute(name,val);  },
    clone:function(name){ return new xmlPointer(this.d); },
    sub_exists:function(name){ var a=this.d.childNodes; if (a.length) for (var i=0; i<a.length; i++) if (a[i].tagName==name) return true;  return false;  },
    through:function(name,rule,v,f,t){  var a=this.d.childNodes; if (a.length) for (var i=0; i<a.length; i++) { if (a[i].tagName==name && a[i].getAttribute(rule)!=null && a[i].getAttribute(rule)!="" &&  (!v || a[i].getAttribute(rule)==v )) { var c=new xmlPointer(a[i]);  f.apply(t,[c,i]); } var w=this.d; this.d=a[i]; this.through(name,rule,v,f,t); this.d=w;  } }
}



/**
 *     @desc: tree constructor
 *     @param: htmlObject - parent html object or id of parent html object
 *     @param: width - tree width
 *     @param: height - tree height
 *     @param: rootId - id of virtual root node (same as tree node id attribute in xml)
 *     @type: public
 *     @topic: 0
 */
function dhtmlXTreeObject(htmlObject, width, height, rootId){
    if (dhtmlxEvent.initTouch)
        dhtmlxEvent.initTouch();

    if (_isIE) try { document.execCommand("BackgroundImageCache", false, true); } catch (e){}
    if (typeof(htmlObject)!="object")
        this.parentObject=document.getElementById(htmlObject);
    else
        this.parentObject=htmlObject;

    this.parentObject.style.overflow="hidden";
    this._itim_dg=true;
    this.dlmtr=",";
    this.dropLower=false;
    this.enableIEImageFix(true);

    this.xmlstate=0;
    this.mytype="tree";
    this.smcheck=true;   //smart checkboxes
    this.width=width;
    this.height=height;
    this.rootId=rootId;
    this.childCalc=null;
    this.def_img_x="18px";
    this.def_img_y="18px";
    this.def_line_img_x="18px";
    this.def_line_img_y="24px";

    this._dragged=new Array();
    this._selected=new Array();

    this.style_pointer="pointer";

    this._aimgs=true;
    this.htmlcA=" [";
    this.htmlcB="]";
    this.lWin=window;
    this.cMenu=0;
    this.mlitems=0;
    this.iconURL="";
    this.dadmode=0;
    this.slowParse=false;
    this.autoScroll=true;
    this.hfMode=0;
    this.nodeCut=new Array();
    this.XMLsource=0;
    this.XMLloadingWarning=0;
    this._idpull={};
    this._pullSize=0;
    this.treeLinesOn=true;
    this.tscheck=false;
    this.timgen=true;
    this.dpcpy=false;
    this._ld_id=null;
    this._dynDeleteBranches={};
    this._oie_onXLE=[];
    this.imPath=window.dhx_globalImgPath||"";
    this.checkArray=new Array("iconUncheckAll.gif","iconCheckAll.gif","iconCheckGray.gif","iconUncheckDis.gif","iconCheckDis.gif","iconCheckDis.gif");
    this.radioArray=new Array("radio_off.gif","radio_on.gif","radio_on.gif","radio_off.gif","radio_on.gif","radio_on.gif");

    this.lineArray=new Array("line2.gif","line3.gif","line4.gif","blank.gif","blank.gif","line1.gif");
    this.minusArray=new Array("minus2.gif","minus3.gif","minus4.gif","minus.gif","minus5.gif");
    this.plusArray=new Array("plus2.gif","plus3.gif","plus4.gif","plus.gif","plus5.gif");
    this.imageArray=new Array("leaf.gif","folderOpen.gif","folderClosed.gif");
    this.cutImg= new Array(0,0,0);
    this.cutImage="but_cut.gif";

    dhx4._eventable(this);

    this.dragger= new dhtmlDragAndDropObject();
//create root
    this.htmlNode=new dhtmlXTreeItemObject(this.rootId,"",0,this);
    this.htmlNode.htmlNode.childNodes[0].childNodes[0].style.display="none";
    this.htmlNode.htmlNode.childNodes[0].childNodes[0].childNodes[0].className="hiddenRow";
//init tree structures
    this.allTree=this._createSelf();
    this.allTree.appendChild(this.htmlNode.htmlNode);

    if (dhtmlx.$customScroll)
        dhtmlx.CustomScroll.enable(this);

    if(_isFF){
        this.allTree.childNodes[0].width="100%";
        this.allTree.childNodes[0].style.overflow="hidden";
    }

    var self=this;
    this.allTree.onselectstart=new Function("return false;");
    if (_isMacOS)
        this.allTree.oncontextmenu = function(e){
            return self._doContClick(e||window.event, true);
        };
    this.allTree.onmousedown = function(e){ return self._doContClick(e||window.event); };

    this.XMLLoader=this._parseXMLTree;
    if (_isIE) this.preventIECashing(true);

//#__pro_feature:01112006{
//#complex_move:01112006{
    this.selectionBar=document.createElement("DIV");
    this.selectionBar.className="selectionBar";
    this.selectionBar.innerHTML="&nbsp;";
    this.selectionBar.style.display="none";
    this.allTree.appendChild(this.selectionBar);
//#}
//#}


    if (window.addEventListener) window.addEventListener("unload",function(){try{  self.destructor(); } catch(e){}},false);
    if (window.attachEvent) window.attachEvent("onunload",function(){ try{ self.destructor(); } catch(e){}});

    this.setImagesPath=this.setImagePath;
    this.setIconsPath=this.setIconPath;

    if (dhtmlx.image_path) this.setImagePath(dhtmlx.image_path);
    this.setSkin(window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhxtree")||"dhx_skyblue");

    return this;
};


/**
 *     @desc: set default data transfer mode
 *     @param: mode - data mode (json,xml,csv)
 *     @type: public
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.setDataMode=function(mode){
    this._datamode=mode;
}



dhtmlXTreeObject.prototype._doContClick=function(ev, force){
    if (!force && ev.button!=2) {
        if(this._acMenu){
            if (this._acMenu.hideContextMenu)
                this._acMenu.hideContextMenu()
            else
                this.cMenu._contextEnd();
        }
        return true;
    }




    var el=(_isIE?ev.srcElement:ev.target);
    while ((el)&&(el.tagName!="BODY")) {
        if (el.parentObject) break;
        el=el.parentNode;
    }

    if ((!el)||(!el.parentObject)) return true;

    var obj=el.parentObject;

    if (!this.callEvent("onRightClick",[obj.id,ev]))
        (ev.srcElement||ev.target).oncontextmenu = function(e){ (e||event).cancelBubble=true; return false; };

    this._acMenu=(obj.cMenu||this.cMenu);
    if (this._acMenu){
        if (!(this.callEvent("onBeforeContextMenu", [
            obj.id
        ]))) return true;
        if(!_isMacOS)
            (ev.srcElement||ev.target).oncontextmenu = function(e){ (e||event).cancelBubble=true; return false; };

        if (this._acMenu.showContextMenu){

            var dEl0=window.document.documentElement;
            var dEl1=window.document.body;
            var corrector = new Array((dEl0.scrollLeft||dEl1.scrollLeft),(dEl0.scrollTop||dEl1.scrollTop));
            if (_isIE){
                var x= ev.clientX+corrector[0];
                var y = ev.clientY+corrector[1];
            } else {
                var x= ev.pageX;
                var y = ev.pageY;
            }

            this._acMenu.showContextMenu(x-1,y-1)
            this.contextID=obj.id;
            ev.cancelBubble=true;
            this._acMenu._skip_hide=true;
        } else {
            el.contextMenuId=obj.id;
            el.contextMenu=this._acMenu;
            el.a=this._acMenu._contextStart;
            el.a(el, ev);
            el.a=null;
        }

        return false;
    }
    return true;
}


/**
 *     @desc: replace IMG tag with background images - solve problem with IE image caching , not works for IE6 SP1
 *     @param: mode - true/false - enable/disable fix
 *     @type: public
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.enableIEImageFix=function(mode){
    if (!mode){

        this._getImg=function(id){ return document.createElement((id==this.rootId)?"div":"img"); }
        //this._setSrc=function(a,b){ a.src=b; }
        this._setSrc=function(a,b){ a.src=b; }
        this._getSrc=function(a){ return a.src; }
    }	else	{

        this._getImg=function(){ var z=document.createElement("DIV"); z.innerHTML="&nbsp;"; z.className="dhx_bg_img_fix"; return z; }
        this._setSrc=function(a,b){ a.style.backgroundImage="url("+b+")"; }
        this._getSrc=function(a){ var z=a.style.backgroundImage;  return z.substr(4,z.length-5).replace(/(^")|("$)/g,""); }
    }
}

/**
 *	@desc: deletes tree and clears memory
 *	@type: public
 */
dhtmlXTreeObject.prototype.destructor=function(){
    for (var a in this._idpull){
        var z=this._idpull[a];
        if (!z) continue;
        z.parentObject=null;z.treeNod=null;z.childNodes=null;z.span=null;z.tr.nodem=null;z.tr=null;z.htmlNode.objBelong=null;z.htmlNode=null;
        this._idpull[a]=null;
    }
    this.parentObject.innerHTML="";

    this.allTree.onselectstart = null;
    this.allTree.oncontextmenu = null;
    this.allTree.onmousedown = null;

    for(var a in this){
        this[a]=null;
    }
}

function cObject(){
    return this;
}
cObject.prototype= new Object;
cObject.prototype.clone = function () {
    function _dummy(){};
    _dummy.prototype=this;
    return new _dummy();
}

/**
 *   @desc: tree node constructor
 *   @param: itemId - node id
 *   @param: itemText - node label
 *   @param: parentObject - parent item object
 *   @param: treeObject - tree object
 *   @param: actionHandler - onclick event handler(optional)
 *   @param: mode - do not show images
 *   @type: private
 *   @topic: 0
 */
function dhtmlXTreeItemObject(itemId,itemText,parentObject,treeObject,actionHandler,mode){
    this.htmlNode="";
    this.acolor="";
    this.scolor="";
    this.tr=0;
    this.childsCount=0;
    this.tempDOMM=0;
    this.tempDOMU=0;
    this.dragSpan=0;
    this.dragMove=0;
    this.span=0;
    this.closeble=1;
    this.childNodes=new Array();
    this.userData=new cObject();


    this.checkstate=0;
    this.treeNod=treeObject;
    this.label=itemText;
    this.parentObject=parentObject;
    this.actionHandler=actionHandler;
    this.images=new Array(treeObject.imageArray[0],treeObject.imageArray[1],treeObject.imageArray[2]);


    this.id=treeObject._globalIdStorageAdd(itemId,this);
    if (this.treeNod.checkBoxOff ) this.htmlNode=this.treeNod._createItem(1,this,mode);
    else  this.htmlNode=this.treeNod._createItem(0,this,mode);

    this.htmlNode.objBelong=this;
    return this;
};


/**
 *     @desc: register node
 *     @type: private
 *     @param: itemId - node id
 *     @param: itemObject - node object
 *     @topic: 3
 */
dhtmlXTreeObject.prototype._globalIdStorageAdd=function(itemId,itemObject){
    if (this._globalIdStorageFind(itemId,1,1)) {   itemId=itemId +"_"+(new Date()).valueOf(); return this._globalIdStorageAdd(itemId,itemObject); }
    this._idpull[itemId]=itemObject;
    this._pullSize++;
    return itemId;
};

/**
 *     @desc: unregister node
 *     @type: private
 *     @param: itemId - node id
 *     @topic: 3
 */
dhtmlXTreeObject.prototype._globalIdStorageSub=function(itemId){
    if (this._idpull[itemId]){
        this._unselectItem(this._idpull[itemId]);
        this._idpull[itemId]=null;
        this._pullSize--;
    }
    if ((this._locker)&&(this._locker[itemId])) this._locker[itemId]=false;
};

/**
 *     @desc: return node object
 *     @param: itemId - node id
 *     @type: private
 *     @topic: 3
 */
dhtmlXTreeObject.prototype._globalIdStorageFind=function(itemId,skipXMLSearch,skipParsing,isreparse){
    var z=this._idpull[itemId];
    if (z){
//#__pro_feature:01112006{
//#smart_parsing:01112006{
        if ((z.unParsed)&&(!skipParsing))
        {
            this.reParse(z,0);
        }
        if (this._srnd && !z.htmlNode) this._buildSRND(z,skipParsing);
        if ((isreparse)&&(this._edsbpsA)){
            for (var j=0; j<this._edsbpsA.length; j++)
                if (this._edsbpsA[j][2]==itemId){
                    dhx4.callEvent("ongetItemError",["Requested item still in parsing process.",itemId]);
                    return null;
                }
        }
//#}
//#}
        return z;
    }
//#__pro_feature:01112006{
//#smart_parsing:01112006{
    if ((this.slowParse)&&(itemId!=0)&&(!skipXMLSearch)) return this.preParse(itemId);
    else
//#}
//#}
        return null;
};
//#__pro_feature:01112006{
//#smart_parsing:01112006{
dhtmlXTreeObject.prototype._getSubItemsXML=function(p){
    var z=[];
    p.each("item",function(c){
        z.push(c.get("id"));
    },this)
    return z.join(this.dlmtr);
}

/**
 *     @desc: enable/disable smart XML parsing mode (usefull for big, well structured XML)
 *     @beforeInit: 1
 *     @param: mode - 1 - on, 0 - off;
 *     @type: public
 *     @edition: Professional
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.enableSmartXMLParsing=function(mode) { this.slowParse=dhx4.s2b(mode); };
dhtmlXTreeObject.prototype.findXML=function(node,par,val){  }

dhtmlXTreeObject.prototype._getAllCheckedXML=function(p,list,mode){
    var z=[];

    if (mode==2)
        p.through("item","checked",-1,function(c){
            z.push(c.get("id"));
        },this);

    if (mode==1)
        p.through("item","id",null,function(c){
            if (c.get("checked") && (c.get("checked") !=-1))
                z.push(c.get("id"));
        },this);

    if (mode==0)
        p.through("item","id",null,function(c){
            if (!c.get("checked") || c.get("checked")==0 )
                z.push(c.get("id"));
        },this);
    if(z.length)
        return list+(list?this.dlmtr:"")+z.join(this.dlmtr);
    if (list) return list; else return "";
};


/**
 *     @desc: change state of node's checkbox and all childnodes checkboxes
 *     @type: private
 *     @param: itemId - target node id
 *     @param: state - checkbox state
 *     @param: sNode - target node object (optional, used by private methods)
 *     @topic: 5
 */
dhtmlXTreeObject.prototype._setSubCheckedXML=function(state,p){
    var val= state?"1":"";
    p.through("item","id",null,function(c){
        if (!c.get("disabled") || c.get("disabled")==0 )
            c.set("checked",val);
    },this);
}

dhtmlXTreeObject.prototype._getAllScraggyItemsXML=function(p,x){
    var z=[];
    var fff=function(c){
        if (!c.sub_exists("item"))
            z.push(c.get("id"));
        else
            c.each("item",fff,this);
    }
    fff(p);
    return z.join(",");
}

dhtmlXTreeObject.prototype._getAllFatItemsXML=function(p,x){
    var z=[];
    var fff=function(c){
        if (!c.sub_exists("item"))
            return;
        z.push(c.get("id"));
        c.each("item",fff,this);
    }
    fff(p);
    return z.join(",");
}

dhtmlXTreeObject.prototype._getAllSubItemsXML=function(itemId,z,p){
    var z=[];
    p.through("item","id",null,function(c){
        z.push(c.get("id"));
    },this)
    return z.join(",");
}

/**
 *     @desc: parse stored xml
 *     @param: node - XML node
 *     @type: private
 *     @edition: Professional
 *     @topic: 3
 */
dhtmlXTreeObject.prototype.reParse=function(node){
    var that=this;
    if (!this.parsCount) that.callEvent("onXLS",[that,node.id]);
    this.xmlstate=1;

    var tmp=node.unParsed;
    node.unParsed=0;
//               if (confirm("reParse "+node.id)) { window.asdasd.asdasd(); }
    this.XMLloadingWarning=1;
    var oldpid=this.parsingOn;
    var oldmd=this.waitUpdateXML;
    var oldpa=this.parsedArray;

    this.parsedArray=new Array();
    this.waitUpdateXML=false;
    this.parsingOn=node.id;
    this.parsedArray=new Array();

    this.setCheckList="";
    this._parse(tmp,node.id,2);
    var chArr=this.setCheckList.split(this.dlmtr);

    for (var i=0; i<this.parsedArray.length; i++)
        node.htmlNode.childNodes[0].appendChild(this.parsedArray[i]);

    if (tmp.get("order") && tmp.get("order")!="none")
        this._reorderBranch(node,tmp.get("order"),true);

    this.oldsmcheck=this.smcheck;
    this.smcheck=false;

    for (var n=0; n<chArr.length; n++)
        if (chArr[n])  this.setCheck(chArr[n],1);
    this.smcheck=this.oldsmcheck;

    this.parsingOn=oldpid;
    this.waitUpdateXML=oldmd;
    this.parsedArray=oldpa;
    this.XMLloadingWarning=0;
    this._redrawFrom(this,node);
    if (this._srnd && !node._sready)
        this.prepareSR(node.id);
    this.xmlstate=0;
    return true;
}

/**
 *     @desc: search for item in unparsed chunks
 *     @param: itemId - item ID
 *     @type: private
 *     @edition: Professional
 *     @topic: 3
 */
dhtmlXTreeObject.prototype.preParse=function(itemId){
    if (!itemId || !this._p) return null;
    var result=false;
    this._p.clone().through("item","id",itemId,function(c){
        this._globalIdStorageFind(c.up().get("id"));
        return result=true;
    },this);
    if (result){
        var n=this._globalIdStorageFind(itemId,true,false);
        if (!n)
            dhx4.callEvent("ongetItemError",["The item "+itemId+" not operable. Seems you have non-unique|incorrect IDs in tree's XML.",itemId]);
    }
    return n;
}

//#}
//#}

/**
 *     @desc: escape string
 *     @param: itemId - item ID
 *     @type: private
 *     @topic: 3
 */
dhtmlXTreeObject.prototype._escape=function(str){
    switch(this.utfesc){
        case "none":
            return str;
            break;
        case "utf8":
            return encodeURIComponent(str);
            break;
        default:
            return escape(str);
            break;
    }
}



/**
 *     @desc: create and return  new line in tree
 *     @type: private
 *     @param: htmlObject - parent Node object
 *     @param: node - item object
 *     @topic: 2
 */
dhtmlXTreeObject.prototype._drawNewTr=function(htmlObject,node)
{
    var tr =document.createElement('tr');
    var td1=document.createElement('td');
    var td2=document.createElement('td');
    td1.appendChild(document.createTextNode(" "));
    td2.colSpan=3;
    td2.appendChild(htmlObject);
    tr.appendChild(td1);  tr.appendChild(td2);
    return tr;
};
/**
 *     @desc: load tree from xml string
 *     @type: public
 *     @param: xmlString - XML string
 *     @param: afterCall - function which will be called after xml loading
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.parse=function(xmlString,afterCall,type){
    if (typeof afterCall == "string"){
        type = afterCall;
        afterCall = null;
    }

    if (type === "json")
        return this._loadJSONObject(xmlString, afterCall)
    else if (type === "csv")
        return this._loadCSVString(xmlString, afterCall);
    else if (type === "jsarray")
        return this._loadJSArray(xmlString, afterCall);

    var that=this;
    if (!this.parsCount) this.callEvent("onXLS",[that,null]);
    this.xmlstate=1;
    this.XMLLoader({ responseXML:dhx4.ajax.parse(xmlString)}, afterCall);
};

dhtmlXTreeObject.prototype.loadXMLString = function(){
    //if (window.console && window.console.info)
    //window.console.info("loadXMLString was deprecated", "http://docs.dhtmlx.com/migration__index.html#migrationfrom43to44");
    return this.parse.apply(this, arguments);
}

/**
 *     @desc: load tree from xml file
 *     @type: public
 *     @param: file - link to XML file
 *     @param: afterCall - function which will be called after xml loading
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.load=function(file,afterCall,type){
    if (typeof afterCall == "string"){
        type = afterCall;
        afterCall = null;
    }

    type = type || this._datamode;
    if (type === "json")
        return this._loadJSON(file, afterCall)
    else if (type === "csv")
        return this._loadCSV(file, afterCall);
    else if (type === "jsarray")
        return this._loadJSArrayFile(xmlString, afterCall);

    var that=this;
    if (!this.parsCount) this.callEvent("onXLS",[that,this._ld_id]);
    this._ld_id=null;
    this.xmlstate=1;
    this.XMLLoader=this._parseXMLTree;

    var self = this;
    dhx4.ajax.get(file, function(data){
        self.XMLLoader(data.xmlDoc, afterCall);
        self = null;
    });
};
dhtmlXTreeObject.prototype.loadXML = function(){
    if (window.console && window.console.info)
        window.console.info("loadXML was deprecated", "http://docs.dhtmlx.com/migration__index.html#migrationfrom43to44");
    return this.load.apply(this, arguments);
}
/**
 *     @desc: create new child node
 *     @type: private
 *     @param: parentObject - parent node object
 *     @param: itemId - new node id
 *     @param: itemText - new node text
 *     @param: itemActionHandler - function fired on node select event
 *     @param: image1 - image for node without children;
 *     @param: image2 - image for closed node;
 *     @param: image3 - image for opened node
 *     @param: optionStr - string of otions
 *     @param: childs - node childs flag (for dynamical trees) (optional)
 *     @param: beforeNode - node, after which new node will be inserted (optional)
 *     @topic: 2
 */
dhtmlXTreeObject.prototype._attachChildNode=function(parentObject,itemId,itemText,itemActionHandler,image1,image2,image3,optionStr,childs,beforeNode,afterNode){

    if (beforeNode && beforeNode.parentObject) parentObject=beforeNode.parentObject;
    if (((parentObject.XMLload==0)&&(this.XMLsource))&&(!this.XMLloadingWarning))
    {
        parentObject.XMLload=1;
        this._loadDynXML(parentObject.id);

    }

    var Count=parentObject.childsCount;
    var Nodes=parentObject.childNodes;


    if (afterNode && afterNode.tr.previousSibling){
        if (afterNode.tr.previousSibling.previousSibling){
            beforeNode=afterNode.tr.previousSibling.nodem;
        }
        else
            optionStr=optionStr.replace("TOP","")+",TOP";
    }

    if (beforeNode)
    {
        var ik,jk;
        for (ik=0; ik<Count; ik++)
            if (Nodes[ik]==beforeNode)
            {
                for (jk=Count; jk!=ik; jk--)
                    Nodes[1+jk]=Nodes[jk];
                break;
            }
        ik++;
        Count=ik;
    }


    if (optionStr) {
        var tempStr=optionStr.split(",");
        for (var i=0; i<tempStr.length; i++)
        {
            switch(tempStr[i])
            {
                case "TOP": if (parentObject.childsCount>0) { beforeNode=new Object; beforeNode.tr=parentObject.childNodes[0].tr.previousSibling; }
                    parentObject._has_top=true;
                    for  (ik=Count; ik>0; ik--)
                        Nodes[ik]=Nodes[ik-1];
                    Count=0;
                    break;
            }
        };
    };

    var n;
    if (!(n=this._idpull[itemId]) || n.span!=-1){
        n=Nodes[Count]=new dhtmlXTreeItemObject(itemId,itemText,parentObject,this,itemActionHandler,1);
        itemId = Nodes[Count].id;
        parentObject.childsCount++;
    }

    if(!n.htmlNode) {
        n.label=itemText;
        n.htmlNode=this._createItem((this.checkBoxOff?1:0),n);
        n.htmlNode.objBelong=n;
    }

    if(image1) n.images[0]=image1;
    if(image2) n.images[1]=image2;
    if(image3) n.images[2]=image3;


    var tr=this._drawNewTr(n.htmlNode);
    if ((this.XMLloadingWarning)||(this._hAdI))
        n.htmlNode.parentNode.parentNode.style.display="none";


    if ((beforeNode)&&beforeNode.tr&&(beforeNode.tr.nextSibling))
        parentObject.htmlNode.childNodes[0].insertBefore(tr,beforeNode.tr.nextSibling);
    else
    if (this.parsingOn==parentObject.id){
        this.parsedArray[this.parsedArray.length]=tr;
    }
    else
        parentObject.htmlNode.childNodes[0].appendChild(tr);


    if ((beforeNode)&&(!beforeNode.span)) beforeNode=null;

    if (this.XMLsource) if ((childs)&&(childs!=0)) n.XMLload=0; else n.XMLload=1;
    n.tr=tr;
    tr.nodem=n;

    if (parentObject.itemId==0)
        tr.childNodes[0].className="hiddenRow";

    if ((parentObject._r_logic)||(this._frbtr))
        this._setSrc(n.htmlNode.childNodes[0].childNodes[0].childNodes[1].childNodes[0],this.imPath+this.radioArray[0]);


    if (optionStr) {
        var tempStr=optionStr.split(",");

        for (var i=0; i<tempStr.length; i++)
        {
            switch(tempStr[i])
            {
                case "SELECT": this.selectItem(itemId,false); break;
                case "CALL": this.selectItem(itemId,true);   break;
                case "CHILD":  n.XMLload=0;  break;
                case "CHECKED":
                    if (this.XMLloadingWarning)
                        this.setCheckList+=this.dlmtr+itemId;
                    else
                        this.setCheck(itemId,1);
                    break;
                case "HCHECKED":
                    this._setCheck(n,"unsure");
                    break;
                case "OPEN": n.openMe=1;  break;
            }
        };
    };

    if (!this.XMLloadingWarning)
    {
        if ((this._getOpenState(parentObject)<0)&&(!this._hAdI)) this.openItem(parentObject.id);

        if (beforeNode)
        {
            this._correctPlus(beforeNode);
            this._correctLine(beforeNode);
        }
        this._correctPlus(parentObject);
        this._correctLine(parentObject);
        this._correctPlus(n);
        if (parentObject.childsCount>=2)
        {
            this._correctPlus(Nodes[parentObject.childsCount-2]);
            this._correctLine(Nodes[parentObject.childsCount-2]);
        }
        if (parentObject.childsCount!=2) this._correctPlus(Nodes[0]);

        if (this.tscheck) this._correctCheckStates(parentObject);

        if (this._onradh){
            if (this.xmlstate==1){
                var old=this.onXLE;
                this.onXLE=function(id){ this._onradh(itemId); if (old) old(id); }
            }
            else
                this._onradh(itemId);
        }

    }
    return n;
};


//#__pro_feature:01112006{
//#context_menu:01112006{

/**
 *     @desc: enable context menu
 *     @param: menu - dhtmlXMenu object
 *     @edition: Professional
 *     @type: public
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.enableContextMenu=function(menu){  if (menu) this.cMenu=menu; };

/**
 *     @desc: set context menu to individual nodes
 *     @type: public
 *     @param: itemId - node id
 *     @param: cMenu - context menu object
 *     @edition: Professional
 *     @topic: 2
 */
dhtmlXTreeObject.prototype.setItemContextMenu=function(itemId,cMenu){
    var l=itemId.toString().split(this.dlmtr);
    for (var i=0; i<l.length; i++)
    {
        var temp=this._globalIdStorageFind(l[i]);
        if (!temp) continue;
        temp.cMenu=cMenu;
    }
}

//#}
//#}

/**
 *     @desc: create new node as a child to specified with parentId
 *     @type: deprecated
 *     @param: parentId - parent node id
 *     @param: itemId - new node id
 *     @param: itemText - new node text
 *     @param: itemActionHandler - function fired on node select event (optional)
 *     @param: image1 - image for node without children; (optional)
 *     @param: image2 - image for closed node; (optional)
 *     @param: image3 - image for opened node (optional)
 *     @param: optionStr - options string (optional)
 *     @param: children - node children flag (for dynamical trees) (optional)
 *     @topic: 2
 */
dhtmlXTreeObject.prototype.insertNewItem=function(parentId,itemId,itemText,itemActionHandler,image1,image2,image3,optionStr,children){
    var parentObject=this._globalIdStorageFind(parentId);
    if (!parentObject) return (-1);
    var nodez=this._attachChildNode(parentObject,itemId,itemText,itemActionHandler,image1,image2,image3,optionStr,children);
    if(!this._idpull[this.rootId].XMLload)
        this._idpull[this.rootId].XMLload = 1;
//#__pro_feature:01112006{
//#child_calc:01112006{
    if ((!this.XMLloadingWarning)&&(this.childCalc))  this._fixChildCountLabel(parentObject);
//#}
//#}
    return nodez;
};
/**
 *     @desc: create new node as a child to specified with parentId
 *     @type: public
 *     @param: parentId - parent node id
 *     @param: itemId - new node id
 *     @param: itemText - new node label
 *     @param: itemActionHandler - function fired on node select event (optional)
 *     @param: image1 - image for node without children; (optional)
 *     @param: image2 - image for closed node; (optional)
 *     @param: image3 - image for opened node (optional)
 *     @param: optionStr - options string (optional)
 *     @param: children - node children flag (for dynamical trees) (optional)
 *     @topic: 2
 */
dhtmlXTreeObject.prototype.insertNewChild=function(parentId,itemId,itemText,itemActionHandler,image1,image2,image3,optionStr,children){
    return this.insertNewItem(parentId,itemId,itemText,itemActionHandler,image1,image2,image3,optionStr,children);
}
/**
 *     @desc: parse xml
 *     @type: private
 *     @param: dhtmlObject - jsTree object
 *     @param: node - top XML node
 *     @param: parentId - parent node id
 *     @param: level - level of tree
 *     @topic: 2
 */
dhtmlXTreeObject.prototype._parseXMLTree=function(xml, callback){
    var p=new xmlPointer(dhx4.ajax.xmltop("tree", xml));
    this._parse(p);
    this._p=p;
    if (callback) callback.call(this, xml);
}

dhtmlXTreeObject.prototype._parseItem=function(c,temp,preNode,befNode){
    var id;
    if (this._srnd && (!this._idpull[id=c.get("id")] || !this._idpull[id].span))
    {
        this._addItemSRND(temp.id,id,c);
        return;
    }

    var a=c.get_all();

    if ((typeof(this.waitUpdateXML)=="object")&&(!this.waitUpdateXML[a.id])){
        this._parse(c,a.id,1);
        return;
    }

//#__pro_feature:01112006{
    if ((a.text===null)||(typeof(a.text)=="undefined")){
        a.text=c.sub("itemtext");
        if (a.text) a.text=a.text.content();
    }
//#}




    var zST=[];
    if (a.select) zST.push("SELECT");
    if (a.top) zST.push("TOP");
    if (a.call) this.nodeAskingCall=a.id;
    if (a.checked==-1) zST.push("HCHECKED");
    else if (a.checked) zST.push("CHECKED");
    if (a.open) zST.push("OPEN");

    if (this.waitUpdateXML){
        if (this._globalIdStorageFind(a.id))
            var newNode=this.updateItem(a.id,a.text,a.im0,a.im1,a.im2,a.checked,a.child);
        else{
            if (this.npl==0) zST.push("TOP");
            else preNode=temp.childNodes[this.npl];

            var newNode=this._attachChildNode(temp,a.id,a.text,0,a.im0,a.im1,a.im2,zST.join(","),a.child,0,preNode);
            a.id = newNode.id;
            preNode=null;
        }
    }
    else
        var newNode=this._attachChildNode(temp,a.id,a.text,0,a.im0,a.im1,a.im2,zST.join(","),a.child,(befNode||0),preNode);
    if (a.tooltip)
        newNode.span.parentNode.parentNode.title=a.tooltip;

    if (a.style)
        if (newNode.span.style.cssText)
            newNode.span.style.cssText+=(";"+a.style);
        else
            newNode.span.setAttribute("style",newNode.span.getAttribute("style")+"; "+a.style);

    if (a.radio) newNode._r_logic=true;

    if (a.nocheckbox){
        var check_node=newNode.span.parentNode.previousSibling.previousSibling;
        check_node.style.display="none";
        newNode.nocheckbox=true;
    }
    if (a.disabled){
        if (a.checked!=null) this._setCheck(newNode,a.checked);
        this.disableCheckbox(newNode,1);
    }


    newNode._acc=a.child||0;

    if (this.parserExtension) this.parserExtension._parseExtension.call(this,c,a,(temp?temp.id:0));

    this.setItemColor(newNode,a.aCol,a.sCol);
    if (a.locked=="1")    this.lockItem(newNode.id,true,true);

    if ((a.imwidth)||(a.imheight))   this.setIconSize(a.imwidth,a.imheight,newNode);
    if ((a.closeable=="0")||(a.closeable=="1"))  this.setItemCloseable(newNode,a.closeable);
    var zcall="";
    if (a.topoffset) this.setItemTopOffset(newNode,a.topoffset);
    if ((!this.slowParse)||(typeof(this.waitUpdateXML)=="object")){
        if (c.sub_exists("item"))
            zcall=this._parse(c,a.id,1);
    }
//#__pro_feature:01112006{
//#smart_parsing:01112006{
    else {
        if ((!newNode.childsCount) && c.sub_exists("item"))
            newNode.unParsed=c.clone();

        c.each("userdata",function(u){
            this.setUserData(a.id,u.get("name"),u.content());
        },this);
    }
//#}
//#}
    if (zcall!="") this.nodeAskingCall=zcall;


    c.each("userdata",function(u){
        this.setUserData(c.get("id"),u.get("name"),u.content());
    },this)


}
dhtmlXTreeObject.prototype._parse=function(p,parentId,level,start){
    if (this._srnd && !this.parentObject.offsetHeight) {
        var self=this;
        return window.setTimeout(function(){
            self._parse(p,parentId,level,start);
        },100);
    }
    if (!p.exists()) return;

    this.skipLock=true; //disable item locking
    //loading flags


    if (!parentId) {          //top level
        parentId=p.get("id");

        // deleting child items for refreshed branches
        if(this._dynDeleteBranches[parentId]){
            this.deleteChildItems(parentId);
            this._dynDeleteBranches[parentId]--;
            if(!this._dynDeleteBranches[parentId]){
                delete this._dynDeleteBranches[parentId];
            }
        }

        var skey = p.get("dhx_security");
        if (skey)
            dhtmlx.security_key = skey;

        if (p.get("radio"))
            this.htmlNode._r_logic=true;
        this.parsingOn=parentId;
        this.parsedArray=new Array();
        this.setCheckList="";
        this.nodeAskingCall="";
    }

    var temp=this._globalIdStorageFind(parentId);
    if (!temp) return dhx4.callEvent("onDataStructureError",["XML refers to not existing parent"]);

    this.parsCount=this.parsCount?(this.parsCount+1):1;
    this.XMLloadingWarning=1;

    if ((temp.childsCount)&&(!start)&&(!this._edsbps)&&(!temp._has_top))
        var preNode=0;//temp.childNodes[temp.childsCount-1];
    else
        var preNode=0;

    this.npl=0;

    p.each("item",function(c,i){

        temp.XMLload=1;

        this._parseItem(c,temp,0,preNode);

//#__pro_feature:01112006{
//#distributed_load:01112006{
        if ((this._edsbps)&&(this.npl==this._edsbpsC)){
            this._distributedStart(p,i+1,parentId,level,temp.childsCount);
            return -1;
        }
//#}
//#}
        this.npl++;



    },this,start);


    if (!level) {
        p.each("userdata",function(u){
            this.setUserData(p.get("id"),u.get("name"),u.content());
        },this);

        temp.XMLload=1;
        if (this.waitUpdateXML){
            this.waitUpdateXML=false;
            for (var i=temp.childsCount-1; i>=0; i--)
                if (temp.childNodes[i]._dmark)
                    this.deleteItem(temp.childNodes[i].id);
        }

        var parsedNodeTop=this._globalIdStorageFind(this.parsingOn);

        for (var i=0; i<this.parsedArray.length; i++)
            temp.htmlNode.childNodes[0].appendChild(this.parsedArray[i]);
        this.parsedArray = [];

        this.lastLoadedXMLId=parentId;
        this.XMLloadingWarning=0;

        var chArr=this.setCheckList.split(this.dlmtr);
        for (var n=0; n<chArr.length; n++)
            if (chArr[n]) this.setCheck(chArr[n],1);

        if ((this.XMLsource)&&(this.tscheck)&&(this.smcheck)&&(temp.id!=this.rootId)){
            if (temp.checkstate===0)
                this._setSubChecked(0,temp);
            else if (temp.checkstate===1)
                this._setSubChecked(1,temp);
        }

        this._redrawFrom(this,null,start)
        if (p.get("order") && p.get("order")!="none")
            this._reorderBranch(temp,p.get("order"),true);

        if (this.nodeAskingCall!="") this.callEvent("onClick",[this.nodeAskingCall,this.getSelectedItemId()]);
        if (this._branchUpdate) this._branchUpdateNext(p);
    }


    if (this.parsCount==1) {
        this.parsingOn=null;
//#__pro_feature:01112006{
//#smart_parsing:01112006{
        //if ((this.slowParse)&&(this.parsingOn==this.rootId))
        if (this._srnd && temp.id!=this.rootId){
            this.prepareSR(temp.id);
            if (this.XMLsource) this.openItem(temp.id)
        }

        p.through("item","open",null,function(c){
            this.openItem(c.get("id"));
        },this);
//#}
//#}


        if ((!this._edsbps)||(!this._edsbpsA.length)){
            var that=this;
            window.setTimeout( function(){  that.callEvent("onXLE",[that,parentId]); },1);
            this.xmlstate=0;
        }
        this.skipLock=false;
    }
    this.parsCount--;

//#__pro_feature:01112006{
//#distributed_load:01112006{
    var that=this;
    if (this._edsbps) window.setTimeout(function(){ that._distributedStep(parentId); },this._edsbpsD);
//#}
//#}



    if (!level && this.onXLE) this.onXLE(this,parentId);
    return this.nodeAskingCall;
};


dhtmlXTreeObject.prototype._branchUpdateNext=function(p){
    p.each("item",function(c){
        var nid=c.get("id");
        if (this._idpull[nid] && (!this._idpull[nid].XMLload))  return;
        this._branchUpdate++;
        this.smartRefreshItem(c.get("id"),c);
    },this)
    this._branchUpdate--;
}

dhtmlXTreeObject.prototype.checkUserData=function(node,parentId){
    if ((node.nodeType==1)&&(node.tagName == "userdata"))
    {
        var name=node.getAttribute("name");
        if ((name)&&(node.childNodes[0]))
            this.setUserData(parentId,name,node.childNodes[0].data);
    }
}




/**
 *     @desc: reset tree images from selected level
 *     @type: private
 *     @param: dhtmlObject - tree
 *     @param: itemObject - current item
 *     @topic: 6
 */
dhtmlXTreeObject.prototype._redrawFrom=function(dhtmlObject,itemObject,start,visMode){
    if (!itemObject) {
        var tempx=dhtmlObject._globalIdStorageFind(dhtmlObject.lastLoadedXMLId);
        dhtmlObject.lastLoadedXMLId=-1;
        if (!tempx) return 0;
    }
    else tempx=itemObject;
    var acc=0;
    for (var i=(start?start-1:0); i<tempx.childsCount; i++)
    {
        if ((!this._branchUpdate)||(this._getOpenState(tempx)==1))
            if ((!itemObject)||(visMode==1)) tempx.childNodes[i].htmlNode.parentNode.parentNode.style.display="";
        if (tempx.childNodes[i].openMe==1)
        {
            this._openItem(tempx.childNodes[i]);
            tempx.childNodes[i].openMe=0;
        }

        dhtmlObject._redrawFrom(dhtmlObject,tempx.childNodes[i]);
//#__pro_feature:01112006{
//#child_calc:01112006{
        if (this.childCalc!=null){

            if ((tempx.childNodes[i].unParsed)||((!tempx.childNodes[i].XMLload)&&(this.XMLsource)))
            {

                if (tempx.childNodes[i]._acc)
                    tempx.childNodes[i].span.innerHTML=tempx.childNodes[i].label+this.htmlcA+tempx.childNodes[i]._acc+this.htmlcB;
                else
                    tempx.childNodes[i].span.innerHTML=tempx.childNodes[i].label;
            }
            if ((tempx.childNodes[i].childNodes.length)&&(this.childCalc))
            {
                if (this.childCalc==1)
                {
                    tempx.childNodes[i].span.innerHTML=tempx.childNodes[i].label+this.htmlcA+tempx.childNodes[i].childsCount+this.htmlcB;
                }
                if (this.childCalc==2)
                {
                    var zCount=tempx.childNodes[i].childsCount-(tempx.childNodes[i].pureChilds||0);
                    if (zCount)
                        tempx.childNodes[i].span.innerHTML=tempx.childNodes[i].label+this.htmlcA+zCount+this.htmlcB;
                    if (tempx.pureChilds) tempx.pureChilds++; else tempx.pureChilds=1;
                }
                if (this.childCalc==3)
                {
                    tempx.childNodes[i].span.innerHTML=tempx.childNodes[i].label+this.htmlcA+tempx.childNodes[i]._acc+this.htmlcB;
                }
                if (this.childCalc==4)
                {
                    var zCount=tempx.childNodes[i]._acc;
                    if (zCount)
                        tempx.childNodes[i].span.innerHTML=tempx.childNodes[i].label+this.htmlcA+zCount+this.htmlcB;
                }
            }
            else if (this.childCalc==4)   {
                acc++;
            }

            acc+=tempx.childNodes[i]._acc;

            if (this.childCalc==3){
                acc++;
            }

        }
//#}
//#}

    };

    if ((!tempx.unParsed)&&((tempx.XMLload)||(!this.XMLsource)))
        tempx._acc=acc;
    dhtmlObject._correctLine(tempx);
    dhtmlObject._correctPlus(tempx);
//#__pro_feature:01112006{
//#child_calc:01112006{
    if ((this.childCalc)&&(!itemObject)) dhtmlObject._fixChildCountLabel(tempx);
//#}
//#}
};

/**
 *     @desc: create and return main html element of tree
 *     @type: private
 *     @topic: 0
 */
dhtmlXTreeObject.prototype._createSelf=function(){
    var div=document.createElement('div');
    div.className="containerTableStyle";
    div.style.width=this.width;
    div.style.height=this.height;
    this.parentObject.appendChild(div);
    return div;
};

/**
 *     @desc: collapse target node
 *     @type: private
 *     @param: itemObject - item object
 *     @topic: 4
 */
dhtmlXTreeObject.prototype._xcloseAll=function(itemObject)
{
    if (itemObject.unParsed) return;
    if (this.rootId!=itemObject.id) {
        if (!itemObject.htmlNode) return;//srnd
        var Nodes=itemObject.htmlNode.childNodes[0].childNodes;
        var Count=Nodes.length;

        for (var i=1; i<Count; i++)
            Nodes[i].style.display="none";

        this._correctPlus(itemObject);
    }

    for (var i=0; i<itemObject.childsCount; i++)
        if (itemObject.childNodes[i].childsCount)
            this._xcloseAll(itemObject.childNodes[i]);
};
/**
 *     @desc: expand target node
 *     @type: private
 *     @param: itemObject - item object
 *     @topic: 4
 */
dhtmlXTreeObject.prototype._xopenAll=function(itemObject)
{
    this._HideShow(itemObject,2);
    for (var i=0; i<itemObject.childsCount; i++)
        this._xopenAll(itemObject.childNodes[i]);
};
/**
 *     @desc: set correct tree-line and node images
 *     @type: private
 *     @param: itemObject - item object
 *     @topic: 6
 */
dhtmlXTreeObject.prototype._correctPlus=function(itemObject){
    if (!itemObject.htmlNode) return;
    var imsrc=itemObject.htmlNode.childNodes[0].childNodes[0].childNodes[0].lastChild;
    var imsrc2=itemObject.htmlNode.childNodes[0].childNodes[0].childNodes[2].childNodes[0];

    var workArray=this.lineArray;
    if ((this.XMLsource)&&(!itemObject.XMLload)) {
        var workArray=this.plusArray;
        this._setSrc(imsrc2,this.iconURL+itemObject.images[2]);
        if (this._txtimg) return (imsrc.innerHTML="[+]");
    } else if ((itemObject.childsCount)||(itemObject.unParsed)) {
        if ((itemObject.htmlNode.childNodes[0].childNodes[1])&&( itemObject.htmlNode.childNodes[0].childNodes[1].style.display!="none" )) {
            if (!itemObject.wsign) var workArray=this.minusArray;
            this._setSrc(imsrc2,this.iconURL+itemObject.images[1]);
            if (this._txtimg) return (imsrc.innerHTML="[-]");
        } else {
            if (!itemObject.wsign) var workArray=this.plusArray;
            this._setSrc(imsrc2,this.iconURL+itemObject.images[2]);
            if (this._txtimg) return (imsrc.innerHTML="[+]");
        }
    } else {
        this._setSrc(imsrc2,this.iconURL+itemObject.images[0]);
    }


    var tempNum=2;
    if (!itemObject.treeNod.treeLinesOn) {
        this._setSrc(imsrc,this.imPath+workArray[3]);
    } else {
        if (itemObject.parentObject) tempNum=this._getCountStatus(itemObject.id,itemObject.parentObject);
        this._setSrc(imsrc,this.imPath+workArray[tempNum]);
    }
};

/**
 *     @desc: set correct tree-line images
 *     @type: private
 *     @param: itemObject - item object
 *     @topic: 6
 */
dhtmlXTreeObject.prototype._correctLine=function(itemObject){
    if (!itemObject.htmlNode) return;
    var sNode=itemObject.parentObject;
    if (sNode)
        if ((this._getLineStatus(itemObject.id,sNode)==0)||(!this.treeLinesOn))
            for(var i=1; i<=itemObject.childsCount; i++){
                if (!itemObject.htmlNode.childNodes[0].childNodes[i]) break;
                itemObject.htmlNode.childNodes[0].childNodes[i].childNodes[0].style.backgroundImage="";
                itemObject.htmlNode.childNodes[0].childNodes[i].childNodes[0].style.backgroundRepeat="";
            }
        else
            for(var i=1; i<=itemObject.childsCount; i++){
                if (!itemObject.htmlNode.childNodes[0].childNodes[i]) break;
                itemObject.htmlNode.childNodes[0].childNodes[i].childNodes[0].style.backgroundImage="url("+this.imPath+this.lineArray[5]+")";
                itemObject.htmlNode.childNodes[0].childNodes[i].childNodes[0].style.backgroundRepeat="repeat-y";
            }
};
/**
 *     @desc: return type of node
 *     @type: private
 *     @param: itemId - item id
 *     @param: itemObject - parent node object
 *     @topic: 6
 */
dhtmlXTreeObject.prototype._getCountStatus=function(itemId,itemObject){
    if (itemObject.childsCount<=1) { if (itemObject.id==this.rootId) return 4; else  return 0; }

    if (itemObject.childNodes[0].id==itemId) if (itemObject.id==this.rootId) return 2; else return 1;
    if (itemObject.childNodes[itemObject.childsCount-1].id==itemId) return 0;

    return 1;
};
/**
 *     @desc: return type of node
 *     @type: private
 *     @param: itemId - node id
 *     @param: itemObject - parent node object
 *     @topic: 6
 */
dhtmlXTreeObject.prototype._getLineStatus =function(itemId,itemObject){
    if (itemObject.childNodes[itemObject.childsCount-1].id==itemId) return 0;
    return 1;
}

/**
 *     @desc: open/close node
 *     @type: private
 *     @param: itemObject - node object
 *     @param: mode - open/close mode [1-close 2-open](optional)
 *     @topic: 6
 */
dhtmlXTreeObject.prototype._HideShow=function(itemObject,mode){
    if ((this.XMLsource)&&(!itemObject.XMLload)) {
        if (mode==1) return; //close for not loaded node - ignore it
        itemObject.XMLload=1;
        this._loadDynXML(itemObject.id);
        return; };
//#__pro_feature:01112006{
//#smart_parsing:01112006{
    if (itemObject.unParsed) this.reParse(itemObject);
//#}
//#}
    var Nodes=itemObject.htmlNode.childNodes[0].childNodes; var Count=Nodes.length;
    if (Count>1){
        if ( ( (Nodes[1].style.display!="none") || (mode==1) ) && (mode!=2) ) {
//nb:solves standard doctype prb in IE
            this.allTree.childNodes[0].border = "1";
            this.allTree.childNodes[0].border = "0";
            nodestyle="none";
        }
        else  nodestyle="";

        for (var i=1; i<Count; i++)
            Nodes[i].style.display=nodestyle;
    }
    this._correctPlus(itemObject);
}

/**
 *     @desc: return node state
 *     @type: private
 *     @param: itemObject - node object
 *     @topic: 6
 */
dhtmlXTreeObject.prototype._getOpenState=function(itemObject){
    if (!itemObject.htmlNode) return 0; //srnd
    var z=itemObject.htmlNode.childNodes[0].childNodes;
    if (z.length<=1) return 0;
    if    (z[1].style.display!="none") return 1;
    else return -1;
}



/**
 *     @desc: ondblclick item  event handler
 *     @type: private
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.onRowClick2=function(){
    var that=this.parentObject.treeNod;
    if (!that.callEvent("onDblClick",[this.parentObject.id,that])) return false;
    if ((this.parentObject.closeble)&&(this.parentObject.closeble!="0"))
        that._HideShow(this.parentObject);
    else
        that._HideShow(this.parentObject,2);

    if    (that.checkEvent("onOpenEnd"))
        if (!that.xmlstate)
            that.callEvent("onOpenEnd",[this.parentObject.id,that._getOpenState(this.parentObject)]);
        else{
            that._oie_onXLE.push(that.onXLE);
            that.onXLE=that._epnFHe;
        }
    return false;
};
/**
 *     @desc: onclick item event handler
 *     @type: private
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.onRowClick=function(){
    var that=this.parentObject.treeNod;
    if (!that.callEvent("onOpenStart",[this.parentObject.id,that._getOpenState(this.parentObject)])) return 0;
    if ((this.parentObject.closeble)&&(this.parentObject.closeble!="0"))
        that._HideShow(this.parentObject);
    else
        that._HideShow(this.parentObject,2);


    if    (that.checkEvent("onOpenEnd"))
        if (!that.xmlstate)
            that.callEvent("onOpenEnd",[this.parentObject.id,that._getOpenState(this.parentObject)]);
        else{
            that._oie_onXLE.push(that.onXLE);
            that.onXLE=that._epnFHe;
        }

};

dhtmlXTreeObject.prototype._epnFHe=function(that,id,flag){
    if (id!=this.rootId)
        this.callEvent("onOpenEnd",[id,that.getOpenState(id)]);
    that.onXLE=that._oie_onXLE.pop();

    if (!flag && !that._oie_onXLE.length)
        if (that.onXLE) that.onXLE(that,id);
}



/**
 *     @desc: onclick item image event handler
 *     @type: private
 *     @edition: Professional
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.onRowClickDown=function(e){
    e=e||window.event;
    var that=this.parentObject.treeNod;
    that._selectItem(this.parentObject,e);
};


/*****
 SELECTION
 *****/

/**
 *     @desc: retun selected item id
 *     @type: public
 *     @return: id of selected item
 *     @topic: 1
 */
dhtmlXTreeObject.prototype.getSelectedItemId=function()
{
    var str=new Array();
    for (var i=0; i<this._selected.length; i++) str[i]=this._selected[i].id;
    return (str.join(this.dlmtr));
};

/**
 *     @desc: visual select item in tree
 *     @type: private
 *     @param: node - tree item object
 *     @edition: Professional
 *     @topic: 0
 */
dhtmlXTreeObject.prototype._selectItem=function(node,e){
    if (this.checkEvent("onSelect")) this._onSSCFold=this.getSelectedItemId();
//#__pro_feature:01112006{
//#multiselect:01112006{
    if ((!this._amsel)||(!e)||((!e.ctrlKey)&&(!e.metaKey)&&(!e.shiftKey)))
//#}
//#}
        this._unselectItems();
//#__pro_feature:01112006{
//#multiselect:01112006{
    if ((node.i_sel)&&(this._amsel)&&(e)&&(e.ctrlKey || e.metaKey))
        this._unselectItem(node);
    else
    if ((!node.i_sel)&&((!this._amselS)||(this._selected.length==0)||(this._selected[0].parentObject==node.parentObject)))
        if ((this._amsel)&&(e)&&(e.shiftKey)&&(this._selected.length!=0)&&(this._selected[this._selected.length-1].parentObject==node.parentObject)){
            var a=this._getIndex(this._selected[this._selected.length-1]);
            var b=this._getIndex(node);
            if (b<a) { var c=a; a=b; b=c; }
            for (var i=a; i<=b; i++)
                if (!node.parentObject.childNodes[i].i_sel)
                    this._markItem(node.parentObject.childNodes[i]);
        }
        else
//#}
//#}
            this._markItem(node);
    if (this.checkEvent("onSelect")) {
        var z=this.getSelectedItemId();
        if (z!=this._onSSCFold)
            this.callEvent("onSelect",[z]);
    }
}
dhtmlXTreeObject.prototype._markItem=function(node){
    if (node.scolor)  node.span.style.color=node.scolor;
    node.span.className="selectedTreeRow";
    node.i_sel=true;
    this._selected[this._selected.length]=node;
}

/**
 *     @desc: retun node index in children collection by Id
 *     @type: public
 *     @param: itemId - node id
 *     @return: node index
 *     @topic: 2
 */
dhtmlXTreeObject.prototype.getIndexById=function(itemId){
    var z=this._globalIdStorageFind(itemId);
    if (!z) return null;
    return this._getIndex(z);
};
dhtmlXTreeObject.prototype._getIndex=function(w){
    var z=w.parentObject;
    for (var i=0; i<z.childsCount; i++)
        if (z.childNodes[i]==w) return i;
};





/**
 *     @desc: visual unselect item in tree
 *     @type: private
 *     @param: node - tree item object
 *     @edition: Professional
 *     @topic: 0
 */
dhtmlXTreeObject.prototype._unselectItem=function(node){
    if ((node)&&(node.i_sel))
    {

        node.span.className="standartTreeRow";
        if (node.acolor)  node.span.style.color=node.acolor;
        node.i_sel=false;
        for (var i=0; i<this._selected.length; i++)
            if (!this._selected[i].i_sel) {
                this._selected.splice(i,1);
                break;
            }
    }
}

/**
 *     @desc: visual unselect items in tree
 *     @type: private
 *     @param: node - tree item object
 *     @edition: Professional
 *     @topic: 0
 */
dhtmlXTreeObject.prototype._unselectItems=function(){
    for (var i=0; i<this._selected.length; i++){
        var node=this._selected[i];
        node.span.className="standartTreeRow";
        if (node.acolor)  node.span.style.color=node.acolor;
        node.i_sel=false;
    }
    this._selected=new Array();
}


/**
 *     @desc: select node text event handler
 *     @type: private
 *     @param: e - event object
 *     @param: htmlObject - node object
 *     @param: mode - if false - call onSelect event
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.onRowSelect=function(e,htmlObject,mode){
    e=e||window.event;

    var obj=this.parentObject;
    if (htmlObject) obj=htmlObject.parentObject;
    var that=obj.treeNod;

    var lastId=that.getSelectedItemId();
    if ((!e)||(!e.skipUnSel))
        that._selectItem(obj,e);

    if (!mode) {
        if (obj.actionHandler) obj.actionHandler(obj.id,lastId);
        else that.callEvent("onClick",[obj.id,lastId]);
    }
};





/**
 *     @desc: fix checkbox state
 *     @type: private
 *     @topic: 0
 */
dhtmlXTreeObject.prototype._correctCheckStates=function(dhtmlObject){

    if (!this.tscheck) return;
    if (!dhtmlObject) return;
    if (dhtmlObject.id==this.rootId) return;
    //calculate state
    var act=dhtmlObject.childNodes;
    var flag1=0; var flag2=0;
    if (dhtmlObject.childsCount==0) return;
    for (var i=0; i<dhtmlObject.childsCount; i++){
        if (act[i].dscheck) continue;
        if (act[i].checkstate==0) flag1=1;
        else if (act[i].checkstate==1) flag2=1;
        else { flag1=1; flag2=1; break; }
    }

    if ((flag1)&&(flag2)) this._setCheck(dhtmlObject,"unsure");
    else if (flag1)  this._setCheck(dhtmlObject,false);
    else  this._setCheck(dhtmlObject,true);

    this._correctCheckStates(dhtmlObject.parentObject);
}

/**
 *     @desc: checbox select action
 *     @type: private
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.onCheckBoxClick=function(e){
    if (!this.treeNod.callEvent("onBeforeCheck",[this.parentObject.id,this.parentObject.checkstate]))
        return;

    if (this.parentObject.dscheck) return true;
    if (this.treeNod.tscheck)
        if (this.parentObject.checkstate==1) this.treeNod._setSubChecked(false,this.parentObject);
        else this.treeNod._setSubChecked(true,this.parentObject);
    else
    if (this.parentObject.checkstate==1) this.treeNod._setCheck(this.parentObject,false);
    else this.treeNod._setCheck(this.parentObject,true);
    this.treeNod._correctCheckStates(this.parentObject.parentObject);

    return this.treeNod.callEvent("onCheck",[this.parentObject.id,this.parentObject.checkstate]);
};
/**
 *     @desc: create HTML elements for tree node
 *     @type: private
 *     @param: acheck - enable/disable checkbox
 *     @param: itemObject - item object
 *     @param: mode - mode
 *     @topic: 0
 */
dhtmlXTreeObject.prototype._createItem=function(acheck,itemObject,mode){

    var table=document.createElement('table');
    table.cellSpacing = 0;
    table.cellPadding = 0;
    table.border = 0;

    if (this.hfMode) table.style.tableLayout="fixed";
    table.style.margin = 0;
    table.style.padding = 0;

    var tbody=document.createElement('tbody');
    var tr=document.createElement('tr');

    var td1=document.createElement('td');
    td1.className="standartTreeImage";

    if(this._txtimg){
        var img0=document.createElement("div");
        td1.appendChild(img0);
        img0.className="dhx_tree_textSign";
    } else {
        var img0 = this._getImg(itemObject.id);
        img0.border = "0";
        if (img0.tagName == "IMG") {
            img0.align="absmiddle";
        }
        td1.appendChild(img0);
        img0.style.padding = 0;
        img0.style.margin = 0;
        img0.style.width = this.def_line_img_x;
        //img0.style.height = this.def_line_img_y;
    }

    var td11=document.createElement('td');
    //         var inp=document.createElement("input");            inp.type="checkbox"; inp.style.width="12px"; inp.style.height="12px";
    var inp=this._getImg(this.cBROf?this.rootId:itemObject.id);
    inp.checked=0; this._setSrc(inp,this.imPath+this.checkArray[0]); inp.style.width="18px"; inp.style.height="18px";
    //can cause problems with hide/show check

    if (!acheck) td11.style.display="none";

    // td11.className="standartTreeImage";
    //if (acheck)
    td11.appendChild(inp);
    if ((!this.cBROf)&&(inp.tagName=="IMG")) inp.align="absmiddle";
    inp.onclick=this.onCheckBoxClick;
    inp.treeNod=this;
    inp.parentObject=itemObject;
    if (!window._KHTMLrv) td11.width="20px";
    else td11.width="16px";

    var td12=document.createElement('td');
    td12.className="standartTreeImage";
    var img=this._getImg(this.timgen?itemObject.id:this.rootId);
    img.onmousedown=this._preventNsDrag; img.ondragstart=this._preventNsDrag;
    img.border="0";
    if (this._aimgs){
        img.parentObject=itemObject;
        if (img.tagName=="IMG") img.align="absmiddle";
        img.onclick=this.onRowSelect; }
    if (!mode) this._setSrc(img,this.iconURL+this.imageArray[0]);
    td12.appendChild(img); img.style.padding=0; img.style.margin=0;
    if (this.timgen)
    {
        td12.style.width=img.style.width=this.def_img_x; img.style.height=this.def_img_y; }
    else
    {
        img.style.width="0px"; img.style.height="0px";
        if (_isOpera || window._KHTMLrv )    td12.style.display="none";
    }


    var td2=document.createElement('td');
    td2.className="standartTreeRow";

    itemObject.span=document.createElement('span');
    itemObject.span.className="standartTreeRow";
    if (this.mlitems) {
        itemObject.span.style.width=this.mlitems;
        //	if (!_isIE)
        itemObject.span.style.display="block";
    }
    else td2.noWrap=true;
    if (dhx4.isIE8) td2.style.width="99999px";
    else if (!window._KHTMLrv) td2.style.width="100%";

    //      itemObject.span.appendChild(document.createTextNode(itemObject.label));
    itemObject.span.innerHTML=itemObject.label;
    td2.appendChild(itemObject.span);
    td2.parentObject=itemObject;        td1.parentObject=itemObject;
    td2.onclick=this.onRowSelect; td1.onclick=this.onRowClick; td2.ondblclick=this.onRowClick2;
    if (this.ettip)
        tr.title=itemObject.label;

    if (this.dragAndDropOff) {
        if (this._aimgs) { this.dragger.addDraggableItem(td12,this); td12.parentObject=itemObject; }
        this.dragger.addDraggableItem(td2,this);
    }

    itemObject.span.style.paddingLeft="5px";      itemObject.span.style.paddingRight="5px";   td2.style.verticalAlign="";
    td2.style.fontSize="10pt";       td2.style.cursor=this.style_pointer;
    tr.appendChild(td1);            tr.appendChild(td11);            tr.appendChild(td12);
    tr.appendChild(td2);
    tbody.appendChild(tr);
    table.appendChild(tbody);

    if (this.ehlt || this.checkEvent("onMouseIn") || this.checkEvent("onMouseOut")){//highlighting
        tr.onmousemove=this._itemMouseIn;
        tr[(_isIE)?"onmouseleave":"onmouseout"]=this._itemMouseOut;
    }
    return table;
};


/**
 *     @desc: set path to images directory
 *     @param: newPath - path to images directory (related to the page with tree or absolute http url)
 *     @type: public
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.setImagePath=function( newPath ){ this.imPath=newPath; this.iconURL=newPath; };
/**
 *   @desc: set path to external images used as tree icons
 *   @type: public
 *   @param: path - url (or relative path) of images folder with closing "/"
 *   @topic: 0,7
 */
dhtmlXTreeObject.prototype.setIconPath=function(path){
    this.iconURL=path;
}

//#__pro_feature:01112006{
//#child_calc:01112006{

/**
 *     @desc: return count of leafs
 *     @param: itemNode -  node object
 *     @type: private
 *     @edition: Professional
 *     @topic: 4
 */
dhtmlXTreeObject.prototype._getLeafCount=function(itemNode){
    var a=0;
    for (var b=0; b<itemNode.childsCount; b++)
        if (itemNode.childNodes[b].childsCount==0) a++;
    return a;
}

/**
 *     @desc: get value of child counter (child counter must be enabled)
 *     @type: private
 *     @param: itemId - id of selected item
 *     @edition: Professional
 *     @return: counter value (related to counter mode)
 *     @topic: 6
 */
dhtmlXTreeObject.prototype._getChildCounterValue=function(itemId){
    var temp=this._globalIdStorageFind(itemId);
    if (!temp) return 0;
    if ((temp.unParsed)||((!temp.XMLload)&&(this.XMLsource)))
        return temp._acc
    switch(this.childCalc)
    {
        case 1: return temp.childsCount; break;
        case 2: return this._getLeafCount(temp); break;
        case 3: return temp._acc; break;
        case 4: return temp._acc; break;
    }
}

/**
 *     @desc: fix node child counter
 *     @param: itemNode -  node object
 *     @type: private
 *     @edition: Professional
 *     @topic: 4
 */
dhtmlXTreeObject.prototype._fixChildCountLabel=function(itemNode,index){
    if (this.childCalc==null) return;
    if ((itemNode.unParsed)||((!itemNode.XMLload)&&(this.XMLsource)))
    {
        if (itemNode._acc)
            itemNode.span.innerHTML=itemNode.label+this.htmlcA+itemNode._acc+this.htmlcB;
        else
            itemNode.span.innerHTML=itemNode.label;

        return;
    }

    switch(this.childCalc){
        case 1:
            if (itemNode.childsCount!=0)
                itemNode.span.innerHTML=itemNode.label+this.htmlcA+itemNode.childsCount+this.htmlcB;
            else itemNode.span.innerHTML=itemNode.label;
            break;
        case 2:
            var z=this._getLeafCount(itemNode);
            if (z!=0)
                itemNode.span.innerHTML=itemNode.label+this.htmlcA+z+this.htmlcB;
            else itemNode.span.innerHTML=itemNode.label;
            break;
        case 3:
            if (itemNode.childsCount!=0)
            {
                var bcc=0;
                for (var a=0; a<itemNode.childsCount; a++)   {
                    if (!itemNode.childNodes[a]._acc) itemNode.childNodes[a]._acc=0;
                    bcc+=itemNode.childNodes[a]._acc*1;      }
                bcc+=itemNode.childsCount*1;

                itemNode.span.innerHTML=itemNode.label+this.htmlcA+bcc+this.htmlcB;
                itemNode._acc=bcc;
            }
            else { itemNode.span.innerHTML=itemNode.label;   itemNode._acc=0; }
            if ((itemNode.parentObject)&&(itemNode.parentObject!=this.htmlNode))
                this._fixChildCountLabel(itemNode.parentObject);
            break;
        case 4:
            if (itemNode.childsCount!=0)
            {
                var bcc=0;
                for (var a=0; a<itemNode.childsCount; a++)   {
                    if (!itemNode.childNodes[a]._acc) itemNode.childNodes[a]._acc=1;
                    bcc+=itemNode.childNodes[a]._acc*1;      }

                itemNode.span.innerHTML=itemNode.label+this.htmlcA+bcc+this.htmlcB;
                itemNode._acc=bcc;
            }
            else { itemNode.span.innerHTML=itemNode.label;   itemNode._acc=1; }
            if ((itemNode.parentObject)&&(itemNode.parentObject!=this.htmlNode))
                this._fixChildCountLabel(itemNode.parentObject);
            break;
    }
}

/**
 *     @desc: set children calculation mode
 *     @param: mode - mode name as string . Possible values: child - children, no recursive; leafs - children without subchildren, no recursive;  ,childrec - children, recursive; leafsrec - children without subchildren, recursive; disabled (disabled by default)
 *     @type: public
 *     @edition: Professional
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.setChildCalcMode=function( mode ){
    switch(mode){
        case "child": this.childCalc=1; break;
        case "leafs": this.childCalc=2; break;
        case "childrec": this.childCalc=3; break;
        case "leafsrec": this.childCalc=4; break;
        case "disabled": this.childCalc=null; break;
        default: this.childCalc=4;
    }
}
/**
 *     @desc: set children calculation prefix and postfix
 *     @param: htmlA - postfix ([ - by default)
 *     @param: htmlB - postfix (] - by default)
 *     @type: public
 *     @edition: Professional
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.setChildCalcHTML=function( htmlA,htmlB ){
    this.htmlcA=htmlA;      this.htmlcB=htmlB;
}
//#}
//#}

/**
 *     @desc: set function called when tree node selected
 *     @param: (function) func - event handling function
 *     @type: deprecated
 *     @topic: 0,7
 *     @event: onRightClick
 *     @depricated: use grid.attachEvent("onRightClick",func); instead
 *     @eventdesc:  Event occurs after right mouse button was clicked.
 Assigning this handler can disable default context menu, and incompattible with dhtmlXMenu integration.
 *     @eventparam: (string) ID of clicked item
 *     @eventparam: (object) event object
 */
dhtmlXTreeObject.prototype.setOnRightClickHandler=function(func){  this.attachEvent("onRightClick",func);   };

/**
 *     @desc: set function called when tree node clicked, also can be forced to call from API
 *     @param: func - event handling function
 *     @type: deprecated
 *     @topic: 0,7
 *     @event: onClick
 *     @depricated: use grid.attachEvent("onClick",func); instead
 *     @eventdesc: Event raises immideatly after text part of item in tree was clicked, but after default onClick functionality was processed.
 Richt mouse button click can be catched by onRightClick event handler.
 *     @eventparam:  ID of clicked item
 *     @eventparam:  ID of previously selected item
 */
dhtmlXTreeObject.prototype.setOnClickHandler=function(func){  this.attachEvent("onClick",func);  };

/**
 *     @desc: set function called when tree node selected or unselected, include any select change caused by any functionality
 *     @param: func - event handling function
 *     @type: deprecated
 *     @topic: 0,7
 *     @event: onSelect
 *     @depricated: use grid.attachEvent("onSelect",func); instead
 *     @eventdesc: Event raises immideatly after selection in tree was changed
 *     @eventparam:  selected item ID ( list of IDs in case of multiselection)
 */
dhtmlXTreeObject.prototype.setOnSelectStateChange=function(func){  this.attachEvent("onSelect",func); };


/**
 *     @desc: enables dynamic loading from XML
 *     @type: public
 *     @param: filePath - name of script returning XML; in case of virtual loading - user defined function
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.setXMLAutoLoading=function(filePath){  this.XMLsource=filePath; };

/**
 *     @desc: set function called before checkbox checked/unchecked
 *     @param: func - event handling function
 *     @type: deprecated
 *     @topic: 0,7
 *     @event: onCheck
 *     @depricated: use tree.attachEvent("onCheck",func); instead
 *     @eventdesc: Event raises right before item in tree was checked/unchecked. can be canceled (return false from event handler)
 *     @eventparam: ID of item which will be checked/unchecked
 *     @eventparam: Current checkbox state. 1 - item checked, 0 - item unchecked.
 *		@eventreturn: true - confirm changing checked state; false - deny chaning checked state;
 */
dhtmlXTreeObject.prototype.setOnCheckHandler=function(func){ this.attachEvent("onCheck",func);  };


/**
 *     @desc: set function called before tree node opened/closed
 *     @param: func - event handling function
 *     @type: deprecated
 *     @topic: 0,7
 *     @event:  onOpen
 *     @depricated: use grid.attachEvent("onOpenStart",func); instead
 *     @eventdesc: Event raises immideatly after item in tree got command to open/close , and before item was opened//closed. Event also raised for unclosable nodes and nodes without open/close functionality - in that case result of function will be ignored.
 Event does not occur if node was opened by dhtmlXtree API.
 *     @eventparam: ID of node which will be opened/closed
 *     @eventparam: Current open state of tree item. 0 - item has not children, -1 - item closed, 1 - item opened.
 *     @eventreturn: true - confirm opening/closing; false - deny opening/closing;
 */
dhtmlXTreeObject.prototype.setOnOpenHandler=function(func){  this.attachEvent("onOpenStart",func);   };
/**
 *     @desc: set function called before tree node opened/closed
 *     @param: func - event handling function
 *     @type: deprecated
 *     @topic: 0,7
 *     @event:  onOpenStart
 *     @depricated: use grid.attachEvent("onOpenStart",func); instead
 *     @eventdesc: Event raises immideatly after item in tree got command to open/close , and before item was opened//closed. Event also raised for unclosable nodes and nodes without open/close functionality - in that case result of function will be ignored.
 Event not raised if node opened by dhtmlXtree API.
 *     @eventparam: ID of node which will be opened/closed
 *     @eventparam: Current open state of tree item. 0 - item has not children, -1 - item closed, 1 - item opened.
 *     @eventreturn: true - confirm opening/closing; false - deny opening/closing;
 */
dhtmlXTreeObject.prototype.setOnOpenStartHandler=function(func){  this.attachEvent("onOpenStart",func);    };

/**
 *     @desc: set function called after tree node opened/closed
 *     @param: func - event handling function
 *     @type: deprecated
 *     @topic: 0,7
 *     @event:  onOpenEnd
 *     @depricated: use grid.attachEvent("onOpenEnd",func); instead
 *     @eventdesc: Event raises immideatly after item in tree was opened//closed. Event also raised for unclosable nodes and nodes without open/close functionality - in that case result of function will be ignored.
 Event not raised if node opened by dhtmlXtree API.
 *     @eventparam: ID of node which will be opened/closed
 *     @eventparam: Current open state of tree item. 0 - item has not children, -1 - item closed, 1 - item opened.
 */
dhtmlXTreeObject.prototype.setOnOpenEndHandler=function(func){  this.attachEvent("onOpenEnd",func);  };

/**
 *     @desc: set function called when tree node double clicked
 *     @param: func - event handling function
 *     @type: public
 *     @topic: 0,7
 *     @event: onDblClick
 *     @depricated: use grid.attachEvent("onDblClick",func); instead
 *     @eventdesc: Event raised immideatly after item in tree was doubleclicked, before default onDblClick functionality was processed.
 Beware using both onClick and onDblClick events, because component can  generate onClick event before onDblClick event while doubleclicking item in tree.
 ( that behavior depend on used browser )
 *     @eventparam:  ID of item which was doubleclicked
 *     @eventreturn:  true - confirm opening/closing; false - deny opening/closing;
 */
dhtmlXTreeObject.prototype.setOnDblClickHandler=function(func){ this.attachEvent("onDblClick",func);   };









/**
 *     @desc: expand target node and all sub nodes
 *     @type: public
 *     @param: itemId - node id
 *     @topic: 4
 */
dhtmlXTreeObject.prototype.openAllItems=function(itemId)
{
    var temp=this._globalIdStorageFind(itemId);
    if (!temp) return 0;
    this._xopenAll(temp);
};

/**
 *     @desc: return open/close state
 *     @type: public
 *     @param: itemId - node id
 *     @return: -1 - close, 1 - opened, 0 - node doesn't have children
 *     @topic: 4
 */
dhtmlXTreeObject.prototype.getOpenState=function(itemId){
    var temp=this._globalIdStorageFind(itemId);
    if (!temp) return "";
    return this._getOpenState(temp);
};

/**
 *     @desc: collapse target node and all sub nodes
 *     @type: public
 *     @param: itemId - node id
 *     @topic: 4
 */
dhtmlXTreeObject.prototype.closeAllItems=function(itemId)
{
    if (itemId===window.undefined) itemId=this.rootId;

    var temp=this._globalIdStorageFind(itemId);
    if (!temp) return 0;
    this._xcloseAll(temp);

//nb:solves standard doctype prb in IE
    this.allTree.childNodes[0].border = "1";
    this.allTree.childNodes[0].border = "0";

};


/**
 *     @desc: set user data for target node
 *     @type: public
 *     @param: itemId - target node id
 *     @param: name - key for user data
 *     @param: value - user data value
 *     @topic: 5
 */
dhtmlXTreeObject.prototype.setUserData=function(itemId,name,value){
    var sNode=this._globalIdStorageFind(itemId,0,true);
    if (!sNode) return;
    if(name=="hint")
        sNode.htmlNode.childNodes[0].childNodes[0].title=value;
    if (typeof(sNode.userData["t_"+name])=="undefined"){
        if (!sNode._userdatalist) sNode._userdatalist=name;
        else sNode._userdatalist+=","+name;
    }
    sNode.userData["t_"+name]=value;
};

/**
 *     @desc: get user data from target node
 *     @type: public
 *     @param: itemId - target node id
 *     @param: name - key for user data
 *     @return: value of user data
 *     @topic: 5
 */
dhtmlXTreeObject.prototype.getUserData=function(itemId,name){
    var sNode=this._globalIdStorageFind(itemId,0,true);
    if (!sNode) return;
    return sNode.userData["t_"+name];
};




/**
 *     @desc: get node color (text color)
 *     @param: itemId - id of node
 *     @type: public
 *     @return: color of node (empty string for default color);
 *     @topic: 6
 */
dhtmlXTreeObject.prototype.getItemColor=function(itemId)
{
    var temp=this._globalIdStorageFind(itemId);
    if (!temp) return 0;

    var res= new Object();
    if (temp.acolor) res.acolor=temp.acolor;
    if (temp.scolor) res.scolor=temp.scolor;
    return res;
};
/**
 *     @desc: set node text color
 *     @param: itemId - id of node
 *     @param: defaultColor - node color
 *     @param: selectedColor - selected node color
 *     @type: public
 *     @topic: 6
 */
dhtmlXTreeObject.prototype.setItemColor=function(itemId,defaultColor,selectedColor)
{
    if ((itemId)&&(itemId.span))
        var temp=itemId;
    else
        var temp=this._globalIdStorageFind(itemId);
    if (!temp) return 0;
    else {
        if (temp.i_sel)
        {  if (selectedColor) temp.span.style.color=selectedColor; }
        else
        {  if (defaultColor) temp.span.style.color=defaultColor;  }

        if (selectedColor) temp.scolor=selectedColor;
        if (defaultColor) temp.acolor=defaultColor;
    }
};

/**
 *     @desc: return node text
 *     @param: itemId - id of node
 *     @type: public
 *     @return: text of item (with HTML formatting, if any)
 *     @topic: 6
 */
dhtmlXTreeObject.prototype.getItemText=function(itemId)
{
    var temp=this._globalIdStorageFind(itemId);
    if (!temp) return 0;
    return(temp.htmlNode.childNodes[0].childNodes[0].childNodes[3].childNodes[0].innerHTML);
};
/**
 *     @desc: return parent item id
 *     @param: itemId - id of node
 *     @type: public
 *     @return: id of parent item
 *     @topic: 4
 */
dhtmlXTreeObject.prototype.getParentId=function(itemId)
{
    var temp=this._globalIdStorageFind(itemId);
    if ((!temp)||(!temp.parentObject)) return "";
    return temp.parentObject.id;
};



/**
 *     @desc: change item id
 *     @type: public
 *     @param: itemId - old node id
 *     @param: newItemId - new node id
 *     @topic: 4
 */
dhtmlXTreeObject.prototype.changeItemId=function(itemId,newItemId)
{
    if (itemId==newItemId) return;
    var temp=this._globalIdStorageFind(itemId);
    if (!temp) return 0;
    temp.id=newItemId;
    temp.span.contextMenuId=newItemId;
    this._idpull[newItemId]=this._idpull[itemId];
    delete this._idpull[itemId];
};


/**
 *     @desc: mark selected item as cut
 *     @type: public
 *     @topic: 2
 */
dhtmlXTreeObject.prototype.doCut=function(){
    if (this.nodeCut) this.clearCut();
    this.nodeCut=(new Array()).concat(this._selected);
    for (var i=0; i<this.nodeCut.length; i++){
        var tempa=this.nodeCut[i];
        tempa._cimgs=new Array();
        tempa._cimgs[0]=tempa.images[0];
        tempa._cimgs[1]=tempa.images[1];
        tempa._cimgs[2]=tempa.images[2];
        tempa.images[0]=tempa.images[1]=tempa.images[2]=this.cutImage;
        this._correctPlus(tempa);
    }
};

/**
 *     @desc: insert previously cut branch
 *     @param: itemId - id of new parent node
 *     @type: public
 *     @topic: 2
 */
dhtmlXTreeObject.prototype.doPaste=function(itemId){
    var tobj=this._globalIdStorageFind(itemId);
    if (!tobj) return 0;
    for (var i=0; i<this.nodeCut.length; i++){
        if (this._checkPNodes(tobj,this.nodeCut[i])) continue;
        this._moveNode(this.nodeCut[i],tobj);
    }
    this.clearCut();
};

/**
 *     @desc: clear cut
 *     @type: public
 *     @topic: 2
 */
dhtmlXTreeObject.prototype.clearCut=function(){
    for (var i=0; i<this.nodeCut.length; i++)
    {
        var tempa=this.nodeCut[i];
        tempa.images[0]=tempa._cimgs[0];
        tempa.images[1]=tempa._cimgs[1];
        tempa.images[2]=tempa._cimgs[2];
        this._correctPlus(tempa);
    }
    this.nodeCut=new Array();
};



/**
 *     @desc: move node with subnodes
 *     @type: private
 *     @param: itemObject - moved node object
 *     @param: targetObject - new parent node
 *     @topic: 2
 */
dhtmlXTreeObject.prototype._moveNode=function(itemObject,targetObject){
//#__pro_feature:01112006{
//#complex_move:01112006{
    var mode=this.dadmodec;
    if (mode==1)
    {
        var z=targetObject;
        if (this.dadmodefix<0)
        {

            while (true){
                z=this._getPrevNode(z);
                if ((z==-1)) { z=this.htmlNode; break; }
                if ((z.tr==0)||(z.tr.style.display=="")||(!z.parentObject)) break;
            }

            var nodeA=z;
            var nodeB=targetObject;

        }
        else
        {
            if ((z.tr)&&(z.tr.nextSibling)&&(z.tr.nextSibling.nodem)&&(this._getOpenState(z)<1)){
                z = z.tr.nextSibling.nodem;
            }
            else{
                z=this._getNextNode(z);
                if ((z==-1)) z=this.htmlNode;
            }

            var nodeB=z;
            var nodeA=targetObject;
        }


        if (this._getNodeLevel(nodeA,0)>this._getNodeLevel(nodeB,0))
        {
            if (!this.dropLower)
                return this._moveNodeTo(itemObject,nodeA.parentObject);
            else
            if  (nodeB.id!=this.rootId)
                return this._moveNodeTo(itemObject,nodeB.parentObject,nodeB);
            else
                return this._moveNodeTo(itemObject,this.htmlNode,null);
        }
        else
        {
            return this._moveNodeTo(itemObject,nodeB.parentObject,nodeB);
        }


    }
    else
//#}
//#}
        return this._moveNodeTo(itemObject,targetObject);

}

/**
 *     @desc: fix order of nodes in collection
 *     @type: private
 *     @param: target - parent item node
 *     @param: zParent - before node
 *     @edition: Professional
 *     @topic: 2
 */

dhtmlXTreeObject.prototype._fixNodesCollection=function(target,zParent){
    var flag=0; var icount=0;
    var Nodes=target.childNodes;
    var Count=target.childsCount-1;

    if (zParent==Nodes[Count]) return;
    for (var i=0; i<Count; i++)
        if (Nodes[i]==Nodes[Count]) {  Nodes[i]=Nodes[i+1]; Nodes[i+1]=Nodes[Count]; }

//         Count=target.childsCount;
    for (var i=0; i<Count+1; i++)
    {
        if (flag) {
            var temp=Nodes[i];
            Nodes[i]=flag;
            flag=temp;
        }
        else
        if (Nodes[i]==zParent) {   flag=Nodes[i]; Nodes[i]=Nodes[Count];  }
    }
};

/**
 *     @desc: recreate branch
 *     @type: private
 *     @param: itemObject - moved node object
 *     @param: targetObject - new parent node
 *     @param: level - top level flag
 *     @param: beforeNode - node for sibling mode
 *     @mode: mode - DragAndDrop mode (0 - as child, 1 as sibling)
 *     @edition: Professional
 *     @topic: 2
 */
dhtmlXTreeObject.prototype._recreateBranch=function(itemObject,targetObject,beforeNode,level){
    var i; var st="";
    if (beforeNode){
        for (i=0; i<targetObject.childsCount; i++)
            if (targetObject.childNodes[i]==beforeNode) break;

        if (i!=0)
            beforeNode=targetObject.childNodes[i-1];
        else{
            st="TOP";
            beforeNode="";
        }
    }

    var t2=this._onradh; this._onradh=null;
    var newNode=this._attachChildNode(targetObject,itemObject.id,itemObject.label,0,itemObject.images[0],itemObject.images[1],itemObject.images[2],st,0,beforeNode);

    //copy user data
    newNode._userdatalist=itemObject._userdatalist;
    newNode.userData=itemObject.userData.clone();
    if(itemObject._attrs){
        newNode._attrs={};
        for(var attr in itemObject._attrs)
            newNode._attrs[attr] = itemObject._attrs[attr];
    }

    newNode.XMLload=itemObject.XMLload;
    if (t2){
        this._onradh=t2; this._onradh(newNode.id); }

//#__pro_feature:01112006{
//#smart_parsing:01112006{
    //copy unparsed chunk
    if (itemObject.treeNod.dpcpy) itemObject.treeNod._globalIdStorageFind(itemObject.id);
    else newNode.unParsed=itemObject.unParsed;
    this._correctPlus(newNode);
    //this._correctLine(newNode);

//#}
//#}
    for (var i=0; i<itemObject.childsCount; i++)
        this._recreateBranch(itemObject.childNodes[i],newNode,0,1);

//#__pro_feature:01112006{
//#child_calc:01112006{
    if ((!level)&&(this.childCalc)) { this._redrawFrom(this,targetObject);  }
//#}
//#}
    return newNode;
}

/**
 *     @desc: move single node
 *     @type: private
 *     @param: itemObject - moved node object
 *     @param: targetObject - new parent node
 *     @mode: mode - DragAndDrop mode (0 - as child, 1 as sibling)
 *     @topic: 2
 */
dhtmlXTreeObject.prototype._moveNodeTo=function(itemObject,targetObject,beforeNode){
    //return;
    if   (itemObject.treeNod._nonTrivialNode)
        return itemObject.treeNod._nonTrivialNode(this,targetObject,beforeNode,itemObject);

    if (this._checkPNodes(targetObject,itemObject))
        return false;

    if    (targetObject.mytype)
        var framesMove=(itemObject.treeNod.lWin!=targetObject.lWin);
    else
        var framesMove=(itemObject.treeNod.lWin!=targetObject.treeNod.lWin);

    if (!this.callEvent("onDrag",[itemObject.id,targetObject.id,(beforeNode?beforeNode.id:null),itemObject.treeNod,targetObject.treeNod])) return false;
    if ((targetObject.XMLload==0)&&(this.XMLsource))
    {
        targetObject.XMLload=1;
        this._loadDynXML(targetObject.id);
    }
    this.openItem(targetObject.id);

    var oldTree=itemObject.treeNod;
    var c=itemObject.parentObject.childsCount;
    var z=itemObject.parentObject;


    if ((framesMove)||(oldTree.dpcpy)) {//interframe drag flag
        var _otiid=itemObject.id;
        itemObject=this._recreateBranch(itemObject,targetObject,beforeNode);
        if (!oldTree.dpcpy) oldTree.deleteItem(_otiid);
    }
    else
    {

        var Count=targetObject.childsCount; var Nodes=targetObject.childNodes;
        if (Count==0) targetObject._open=true;
        oldTree._unselectItem(itemObject);
        Nodes[Count]=itemObject;
        itemObject.treeNod=targetObject.treeNod;
        targetObject.childsCount++;

        var tr=this._drawNewTr(Nodes[Count].htmlNode);

        if (!beforeNode)
        {
            targetObject.htmlNode.childNodes[0].appendChild(tr);
            if (this.dadmode==1) this._fixNodesCollection(targetObject,beforeNode);
        }
        else
        {
            targetObject.htmlNode.childNodes[0].insertBefore(tr,beforeNode.tr);
            this._fixNodesCollection(targetObject,beforeNode);
            Nodes=targetObject.childNodes;
        }


    }

    if ((!oldTree.dpcpy)&&(!framesMove))   {
        var zir=itemObject.tr;

        if ((document.all)&&(navigator.appVersion.search(/MSIE\ 5\.0/gi)!=-1))
        {
            window.setTimeout(function() { zir.parentNode.removeChild(zir); } , 250 );
        }
        else   //if (zir.parentNode) zir.parentNode.removeChild(zir,true);

            itemObject.parentObject.htmlNode.childNodes[0].removeChild(itemObject.tr);

        //itemObject.tr.removeNode(true);
        if ((!beforeNode)||(targetObject!=itemObject.parentObject)){
            for (var i=0; i<z.childsCount; i++){
                if (z.childNodes[i].id==itemObject.id) {
                    z.childNodes[i]=0;
                    break;            }}}
        else z.childNodes[z.childsCount-1]=0;

        oldTree._compressChildList(z.childsCount,z.childNodes);
        z.childsCount--;
    }


    if ((!framesMove)&&(!oldTree.dpcpy)) {
        itemObject.tr=tr;
        tr.nodem=itemObject;
        itemObject.parentObject=targetObject;

        if (oldTree!=targetObject.treeNod) {
            if(itemObject.treeNod._registerBranch(itemObject,oldTree)) return;      this._clearStyles(itemObject);  this._redrawFrom(this,itemObject.parentObject);
            if(this._onradh) this._onradh(itemObject.id);
        };

        this._correctPlus(targetObject);
        this._correctLine(targetObject);

        this._correctLine(itemObject);
        this._correctPlus(itemObject);

        //fix target siblings
        if (beforeNode)
        {

            this._correctPlus(beforeNode);
            //this._correctLine(beforeNode);
        }
        else
        if (targetObject.childsCount>=2)
        {

            this._correctPlus(Nodes[targetObject.childsCount-2]);
            this._correctLine(Nodes[targetObject.childsCount-2]);
        }

        this._correctPlus(Nodes[targetObject.childsCount-1]);
        //this._correctLine(Nodes[targetObject.childsCount-1]);


        if (this.tscheck) this._correctCheckStates(targetObject);
        if (oldTree.tscheck) oldTree._correctCheckStates(z);

    }

    //fix source parent

    if (c>1) { oldTree._correctPlus(z.childNodes[c-2]);
        oldTree._correctLine(z.childNodes[c-2]);
    }


//      if (z.childsCount==0)
    oldTree._correctPlus(z);
    oldTree._correctLine(z);

//#__pro_feature:01112006{
//#child_calc:01112006{
    this._fixChildCountLabel(targetObject);
    oldTree._fixChildCountLabel(z);
//#}
//#}
    this.callEvent("onDrop",[itemObject.id,targetObject.id,(beforeNode?beforeNode.id:null),oldTree,targetObject.treeNod]);
    return itemObject.id;
};



/**
 *     @desc: recursive set default styles for node
 *     @type: private
 *     @param: itemObject - target node object
 *     @topic: 6
 */
dhtmlXTreeObject.prototype._clearStyles=function(itemObject){
    if (!itemObject.htmlNode) return; //some weird case in SRND mode
    var td1=itemObject.htmlNode.childNodes[0].childNodes[0].childNodes[1];
    var td3=td1.nextSibling.nextSibling;

    itemObject.span.innerHTML=itemObject.label;
    itemObject.i_sel=false;

    if (itemObject._aimgs)
        this.dragger.removeDraggableItem(td1.nextSibling);

    if (this.checkBoxOff) {
        td1.childNodes[0].style.display="";
        td1.childNodes[0].onclick=this.onCheckBoxClick;
        this._setSrc(td1.childNodes[0],this.imPath+this.checkArray[itemObject.checkstate]);
    }
    else td1.style.display="none";
    td1.childNodes[0].treeNod=this;

    this.dragger.removeDraggableItem(td3);
    if (this.dragAndDropOff) this.dragger.addDraggableItem(td3,this);
    if (this._aimgs) this.dragger.addDraggableItem(td1.nextSibling,this);

    td3.childNodes[0].className="standartTreeRow";
    td3.onclick=this.onRowSelect; td3.ondblclick=this.onRowClick2;
    td1.previousSibling.onclick=this.onRowClick;

    this._correctLine(itemObject);
    this._correctPlus(itemObject);
    for (var i=0; i<itemObject.childsCount; i++) this._clearStyles(itemObject.childNodes[i]);

};
/**
 *     @desc: register node and all children nodes
 *     @type: private
 *     @param: itemObject - node object
 *     @topic: 2
 */
dhtmlXTreeObject.prototype._registerBranch=function(itemObject,oldTree){
    if (oldTree) oldTree._globalIdStorageSub(itemObject.id);
    itemObject.id=this._globalIdStorageAdd(itemObject.id,itemObject);
    itemObject.treeNod=this;
    for (var i=0; i<itemObject.childsCount; i++)
        this._registerBranch(itemObject.childNodes[i],oldTree);
    return 0;
};


/**
 *     @desc: enable three state checkboxes
 *     @beforeInit: 1
 *     @param: mode - 1 - on, 0 - off;
 *     @type: public
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.enableThreeStateCheckboxes=function(mode) { this.tscheck=dhx4.s2b(mode); };


/**
 *     @desc: set function called when mouse is over tree node
 *     @param: func - event handling function
 *     @type: deprecated
 *     @topic: 0,7
 *     @event: onMouseIn
 *     @depricated: use grid.attachEvent("onMouseIn",func); instead
 *     @eventdesc: Event raised immideatly after mouse started moving over item
 *     @eventparam:  ID of item
 */
dhtmlXTreeObject.prototype.setOnMouseInHandler=function(func){
    this.ehlt=true;
    this.attachEvent("onMouseIn",func);
};

/**
 *     @desc: set function called when mouse is out of tree node
 *     @param: func - event handling function
 *     @type: deprecated
 *     @topic: 0,7
 *     @event: onMouseOut
 *     @depricated: use grid.attachEvent("onMouseOut",func); instead
 *     @eventdesc: Event raised immideatly after mouse moved out of item
 *     @eventparam:  ID of clicked item
 */
dhtmlXTreeObject.prototype.setOnMouseOutHandler=function(func){
    this.ehlt=true;
    this.attachEvent("onMouseOut",func);
};





//#__pro_feature:01112006{
/**
 *     @desc: enable drag without removing (copy instead of move)
 *     @beforeInit: 1
 *     @param: mode - 1 - on, 0 - off;
 *     @type: public
 *     @edition:Professional
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.enableMercyDrag=function(mode){ this.dpcpy=dhx4.s2b(mode); };
//#}



/**
 *     @desc: enable tree images
 *     @beforeInit: 1
 *     @param: mode - 1 - on, 0 - off;
 *     @type: public
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.enableTreeImages=function(mode) { this.timgen=dhx4.s2b(mode); };



/**
 *     @desc: enable mode with fixed tables (looks better, but has no horisontal scrollbar)
 *     @beforeInit: 1
 *     @param: mode - 1 - on, 0 - off;
 *     @type: private
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.enableFixedMode=function(mode) { this.hfMode=dhx4.s2b(mode); };

/**
 *     @desc: show/hide checkboxes (all checkboxes in tree)
 *     @type: public
 *     @param: mode - true/false
 *     @param: hidden - if set to true, checkboxes not rendered but can be shown by showItemCheckbox
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.enableCheckBoxes=function(mode, hidden){ this.checkBoxOff=dhx4.s2b(mode); this.cBROf=(!(this.checkBoxOff||dhx4.s2b(hidden)));
};
/**
 *     @desc: set default images for nodes (must be called before XML loading)
 *     @type: public
 *     @param: a0 - image for node without children;
 *     @param: a1 - image for closed node;
 *     @param: a2 - image for opened node
 *     @topic: 6
 */
dhtmlXTreeObject.prototype.setStdImages=function(image1,image2,image3){
    this.imageArray[0]=image1; this.imageArray[1]=image2; this.imageArray[2]=image3;};

/**
 *     @desc: enable/disable tree lines (parent-child threads)
 *     @type: public
 *     @param: mode - enable/disable tree lines
 *     @topic: 6
 */
dhtmlXTreeObject.prototype.enableTreeLines=function(mode){
    this.treeLinesOn=dhx4.s2b(mode);
}

/**
 *     @desc: set images used for parent-child threads drawing (lines, plus, minus)
 *     @type: public
 *     @param: arrayName - name of array: plus, minus
 *     @param: image1 - line crossed image
 *     @param: image2 - image with top line
 *     @param: image3 - image with bottom line
 *     @param: image4 - image without line
 *     @param: image5 - single root image
 *     @topic: 6
 */
dhtmlXTreeObject.prototype.setImageArrays=function(arrayName,image1,image2,image3,image4,image5){
    switch(arrayName){
        case "plus": this.plusArray[0]=image1; this.plusArray[1]=image2; this.plusArray[2]=image3; this.plusArray[3]=image4; this.plusArray[4]=image5; break;
        case "minus": this.minusArray[0]=image1; this.minusArray[1]=image2; this.minusArray[2]=image3; this.minusArray[3]=image4;  this.minusArray[4]=image5; break;
    }
};

/**
 *     @desc: expand node
 *     @param: itemId - id of node
 *     @type: public
 *     @topic: 4
 */
dhtmlXTreeObject.prototype.openItem=function(itemId){
    this.skipLock = true;
    var temp=this._globalIdStorageFind(itemId);
    if (!temp) return 0;
    else return this._openItem(temp);
    this.skipLock = false;
};

/**
 *     @desc: expand node
 *     @param: item - tree node object
 *     @type: private
 *     @editing: pro
 *     @topic: 4
 */
dhtmlXTreeObject.prototype._openItem=function(item){
    var state=this._getOpenState(item);
    if ((state<0)||(((this.XMLsource)&&(!item.XMLload)))){
        if    (!this.callEvent("onOpenStart",[item.id,state])) return 0;
        this._HideShow(item,2);
        if    (this.checkEvent("onOpenEnd")){
            if (this.onXLE==this._epnFHe) this._epnFHe(this,item.id,true);
            if (!this.xmlstate || !this.XMLsource)
                this.callEvent("onOpenEnd",[item.id,this._getOpenState(item)]);
            else{
                this._oie_onXLE.push(this.onXLE);
                this.onXLE=this._epnFHe;
            }
        }
    } else if (this._srnd) this._HideShow(item,2);
    if (item.parentObject && !this._skip_open_parent) this._openItem(item.parentObject);
};

/**
 *     @desc: collapse node
 *     @param: itemId - id of node
 *     @type: public
 *     @topic: 4
 */
dhtmlXTreeObject.prototype.closeItem=function(itemId){
    if (this.rootId==itemId) return 0;
    this.skipLock = true;
    var temp=this._globalIdStorageFind(itemId);
    if (!temp) return 0;
    if (temp.closeble)
        this._HideShow(temp,1);
    this.skipLock = false;
};


























/**
 *     @desc: get node level (position in hierarchy)
 *     @param: itemId - id of node
 *     @type: public
 *     @return: node level (0 if no such item in hierarchy - probably super root)
 *     @topic: 4
 */
dhtmlXTreeObject.prototype.getLevel=function(itemId){
    var temp=this._globalIdStorageFind(itemId);
    if (!temp) return 0;
    return this._getNodeLevel(temp,0);
};



/**
 *     @desc: prevent node from closing
 *     @param: itemId - id of node
 *     @param: flag -  if 0 - node can't be closed, else node can be closed
 *     @type: public
 *     @topic: 4
 */
dhtmlXTreeObject.prototype.setItemCloseable=function(itemId,flag)
{
    flag=dhx4.s2b(flag);
    if ((itemId)&&(itemId.span))
        var temp=itemId;
    else
        var temp=this._globalIdStorageFind(itemId);
    if (!temp) return 0;
    temp.closeble=flag;
};

/**
 *     @desc: recursive function used for node level calculation
 *     @param: itemObject - pointer to node object
 *     @param: count - counter of levels
 *     @type: private
 *     @topic: 4
 */
dhtmlXTreeObject.prototype._getNodeLevel=function(itemObject,count){
    if (itemObject.parentObject) return this._getNodeLevel(itemObject.parentObject,count+1);
    return(count);
};

/**
 *     @desc: return number of children
 *     @param: itemId - id of node
 *     @type: public
 *     @return: number of child items for loaded branches; true - for not loaded branches
 *     @topic: 4
 */
dhtmlXTreeObject.prototype.hasChildren=function(itemId){
    var temp=this._globalIdStorageFind(itemId);
    if (!temp) return 0;
    else
    {
        if ( (this.XMLsource)&&(!temp.XMLload) ) return true;
        else
            return temp.childsCount;
    };
};


/**
 *     @desc: get number of leafs (nodes without children)
 *     @param: itemNode -  node object
 *     @type: private
 *     @edition: Professional
 *     @topic: 4
 */
dhtmlXTreeObject.prototype._getLeafCount=function(itemNode){
    var a=0;
    for (var b=0; b<itemNode.childsCount; b++)
        if (itemNode.childNodes[b].childsCount==0) a++;
    return a;
}


/**
 *     @desc: set new node text (HTML allowed)
 *     @param: itemId - id of node
 *     @param: newLabel - node text
 *     @param: newTooltip - (optional)tooltip for the node
 *     @type: public
 *     @topic: 6
 */
dhtmlXTreeObject.prototype.setItemText=function(itemId,newLabel,newTooltip)
{
    var temp=this._globalIdStorageFind(itemId);
    if (!temp) return 0;
    temp.label=newLabel;
    temp.span.innerHTML=newLabel;
//#__pro_feature:01112006{
//#child_calc:01112006{
    if (this.childCalc) this._fixChildCountLabel(temp);
//#}
//#}
    temp.span.parentNode.parentNode.title=newTooltip||"";
};

/**
 *     @desc: get item's tooltip
 *     @param: itemId - id of node
 *     @type: public
 *     @topic: 6
 */
dhtmlXTreeObject.prototype.getItemTooltip=function(itemId){
    var temp=this._globalIdStorageFind(itemId);
    if (!temp) return "";
    return (temp.span.parentNode.parentNode._dhx_title||temp.span.parentNode.parentNode.title||"");
};

/**
 *     @desc: refresh tree branch from xml (XML with child nodes rerequested from server)
 *     @param: itemId - id of node, if not defined tree super root used.
 *     @type: public
 *     @topic: 6
 */
dhtmlXTreeObject.prototype.refreshItem=function(itemId){
    if (!itemId) itemId=this.rootId;
    var temp=this._globalIdStorageFind(itemId);
    this._dynDeleteBranches[itemId] = (this._dynDeleteBranches[itemId]||0) + 1;
    this._loadDynXML(itemId);
};

/**
 *     @desc: set item images
 *     @param: itemId - id of node
 *     @param: image1 - node without children icon
 *     @param: image2 - closed node icon
 *     @param: image3 - open node icon
 *     @type: public
 *     @topic: 6
 */
dhtmlXTreeObject.prototype.setItemImage2=function(itemId, image1,image2,image3){
    var temp=this._globalIdStorageFind(itemId);
    if (!temp) return 0;
    temp.images[1]=image2;
    temp.images[2]=image3;
    temp.images[0]=image1;
    this._correctPlus(temp);
};
/**
 *     @desc: set item icons (mostly usefull for childless nodes)
 *     @param: itemId - id of node
 *     @param: image1 - node without children icon or closed node icon (if image2 specified)
 *     @param: image2 - open node icon (optional)
 *     @type: public
 *     @topic: 6
 */
dhtmlXTreeObject.prototype.setItemImage=function(itemId,image1,image2)
{
    var temp=this._globalIdStorageFind(itemId);
    if (!temp) return 0;
    if (image2)
    {
        temp.images[1]=image1;
        temp.images[2]=image2;
    }
    else temp.images[0]=image1;
    this._correctPlus(temp);
};


/**
 *     @desc: Returns the list of all subitems Ids from the next level of tree, separated by commas.
 *     @param: itemId - id of node
 *     @type: public
 *     @return: list of all subitems from the next level of tree, separated by commas.
 *     @topic: 6
 */
dhtmlXTreeObject.prototype.getSubItems =function(itemId)
{
    var temp=this._globalIdStorageFind(itemId,0,1);
    if (!temp) return 0;
//#__pro_feature:01112006{
//#smart_parsing:01112006{
    if(temp.unParsed)
        return (this._getSubItemsXML(temp.unParsed));
//#}
//#}
    var z="";
    for (i=0; i<temp.childsCount; i++){
        if (!z) z= ""+temp.childNodes[i].id;
        else z+=this.dlmtr+temp.childNodes[i].id;

    }

    return z;
};




/**
 *     @desc: Returns the list of all sub items from all next levels of tree, separated by commas.
 *     @param: itemId - id of node
 *     @edition: Professional
 *     @type: private
 *     @topic: 6
 */
dhtmlXTreeObject.prototype._getAllScraggyItems =function(node)
{
    var z="";
    for (var i=0; i<node.childsCount; i++)
    {
        if ((node.childNodes[i].unParsed)||(node.childNodes[i].childsCount>0))
        {
            if (node.childNodes[i].unParsed)
                var zb=this._getAllScraggyItemsXML(node.childNodes[i].unParsed,1);
            else
                var zb=this._getAllScraggyItems(node.childNodes[i])

            if (zb)
                if (z) z+=this.dlmtr+zb;
                else z=zb;
        }
        else
        if (!z) z=""+node.childNodes[i].id;
        else z+=this.dlmtr+node.childNodes[i].id;
    }
    return z;
};





/**
 *     @desc: Returns the list of all children items from all next levels of tree, separated by commas.
 *     @param: itemId - id of node
 *     @type: private
 *     @edition: Professional
 *     @topic: 6
 */

dhtmlXTreeObject.prototype._getAllFatItems =function(node)
{
    var z="";
    for (var i=0; i<node.childsCount; i++)
    {
        if ((node.childNodes[i].unParsed)||(node.childNodes[i].childsCount>0))
        {
            if (!z) z=""+node.childNodes[i].id;
            else z+=this.dlmtr+node.childNodes[i].id;

            if (node.childNodes[i].unParsed)
                var zb=this._getAllFatItemsXML(node.childNodes[i].unParsed,1);
            else
                var zb=this._getAllFatItems(node.childNodes[i])

            if (zb) z+=this.dlmtr+zb;
        }
    }
    return z;
};


/**
 *     @desc: Returns the list of all children items from all next levels of tree, separated by commas.
 *     @param: itemId - id of node
 *     @type: private
 *     @topic: 6
 */
dhtmlXTreeObject.prototype._getAllSubItems =function(itemId,z,node)
{
    if (node) temp=node;
    else {
        var temp=this._globalIdStorageFind(itemId);
    };
    if (!temp) return 0;

    z="";
    for (var i=0; i<temp.childsCount; i++)
    {
        if (!z) z=""+temp.childNodes[i].id;
        else z+=this.dlmtr+temp.childNodes[i].id;
        var zb=this._getAllSubItems(0,z,temp.childNodes[i])

        if (zb) z+=this.dlmtr+zb;
    }

//#__pro_feature:01112006{
//#smart_parsing:01112006{
    if (temp.unParsed)
        z=this._getAllSubItemsXML(itemId,z,temp.unParsed);
//#}
//#}
    return z;
};





/**
 *     @desc: select node ( and optionaly fire onselect event)
 *     @type: public
 *     @param: itemId - node id
 *     @param: mode - If true, script function for selected node will be called.
 *     @param: preserve - preserve earlier selected nodes
 *     @topic: 1
 */
dhtmlXTreeObject.prototype.selectItem=function(itemId,mode,preserve){
    mode=dhx4.s2b(mode);
    var temp=this._globalIdStorageFind(itemId);
    if ((!temp)||(!temp.parentObject)) return 0;

    if (this.XMLloadingWarning)
        temp.parentObject.openMe=1;
    else
        this._openItem(temp.parentObject);

    //temp.onRowSelect(0,temp.htmlNode.childNodes[0].childNodes[0].childNodes[3],mode);
    var ze=null;
    if (preserve)  {
        ze=new Object; ze.ctrlKey=true;
        if (temp.i_sel) ze.skipUnSel=true;
    }
    if (mode)
        this.onRowSelect(ze,temp.htmlNode.childNodes[0].childNodes[0].childNodes[3],false);
    else
        this.onRowSelect(ze,temp.htmlNode.childNodes[0].childNodes[0].childNodes[3],true);
};

/**
 *     @desc: retun selected node text
 *     @type: public
 *     @return: text of selected node (or list of all selected nodes text if more than one selected)
 *     @topic: 1
 */
dhtmlXTreeObject.prototype.getSelectedItemText=function()
{
    var str=new Array();
    for (var i=0; i<this._selected.length; i++) str[i]=this._selected[i].span.innerHTML;
    return (str.join(this.dlmtr));
};




/**
 *     @desc: correct childNode list after node deleting
 *     @type: private
 *     @param: Count - childNodes collection length
 *     @param: Nodes - childNodes collection
 *     @topic: 4
 */
dhtmlXTreeObject.prototype._compressChildList=function(Count,Nodes)
{
    Count--;
    for (var i=0; i<Count; i++)
    {
        if (Nodes[i]==0) { Nodes[i]=Nodes[i+1]; Nodes[i+1]=0;}
    };
};
/**
 *     @desc: delete node
 *     @type: private
 *     @param: itemId - target node id
 *     @param: htmlObject - target node object
 *     @param: skip - node unregistration mode (optional, used by private methods)
 *     @topic: 2
 */
dhtmlXTreeObject.prototype._deleteNode=function(itemId,htmlObject,skip){
    if ((!htmlObject)||(!htmlObject.parentObject)) return 0;
    var tempos=0; var tempos2=0;
    if (htmlObject.tr.nextSibling)  tempos=htmlObject.tr.nextSibling.nodem;
    if (htmlObject.tr.previousSibling)  tempos2=htmlObject.tr.previousSibling.nodem;

    var sN=htmlObject.parentObject;
    var Count=sN.childsCount;
    var Nodes=sN.childNodes;
    for (var i=0; i<Count; i++)
    {
        if (Nodes[i].id==itemId) {
            if (!skip) sN.htmlNode.childNodes[0].removeChild(Nodes[i].tr);
            Nodes[i]=0;
            break;
        }
    }
    this._compressChildList(Count,Nodes);
    if (!skip) {
        sN.childsCount--;
    }

    if (tempos) {
        this._correctPlus(tempos);
        this._correctLine(tempos);
    }
    if (tempos2) {
        this._correctPlus(tempos2);
        this._correctLine(tempos2);
    }
    if (this.tscheck) this._correctCheckStates(sN);

    if (!skip) {
        this._globalIdStorageRecSub(htmlObject);
    }
};
/**
 *     @desc: set state of node's checkbox
 *     @type: public
 *     @param: itemId - target node id
 *     @param: state - checkbox state (0/1/"unsure")
 *     @topic: 5
 */
dhtmlXTreeObject.prototype.setCheck=function(itemId,state){
    var sNode=this._globalIdStorageFind(itemId,0,1);
    if (!sNode) return;

    if (state==="unsure")
        this._setCheck(sNode,state);
    else
    {
        state=dhx4.s2b(state);
        if ((this.tscheck)&&(this.smcheck)) this._setSubChecked(state,sNode);
        else this._setCheck(sNode,state);
    }
    if (this.smcheck)
        this._correctCheckStates(sNode.parentObject);
};

dhtmlXTreeObject.prototype._setCheck=function(sNode,state){
    if (!sNode) return;
    if (((sNode.parentObject._r_logic)||(this._frbtr))&&(state))
        if (this._frbtrs){
            if (this._frbtrL)   this.setCheck(this._frbtrL.id,0);
            this._frbtrL=sNode;
        } else
            for (var i=0; i<sNode.parentObject.childsCount; i++)
                this._setCheck(sNode.parentObject.childNodes[i],0);

    var z=sNode.htmlNode.childNodes[0].childNodes[0].childNodes[1].childNodes[0];

    if (state=="unsure") sNode.checkstate=2;
    else if (state) sNode.checkstate=1; else sNode.checkstate=0;
    if (sNode.dscheck) sNode.checkstate=sNode.dscheck;
    this._setSrc(z,this.imPath+((sNode.parentObject._r_logic||this._frbtr)?this.radioArray:this.checkArray)[sNode.checkstate]);
};

/**
 *     @desc: change state of node's checkbox and all children checkboxes
 *     @type: public
 *     @param: itemId - target node id
 *     @param: state - checkbox state
 *     @topic: 5
 */
dhtmlXTreeObject.prototype.setSubChecked=function(itemId,state){
    var sNode=this._globalIdStorageFind(itemId);
    this._setSubChecked(state,sNode);
    this._correctCheckStates(sNode.parentObject);
}



/**
 *     @desc: change state of node's checkbox and all childnodes checkboxes
 *     @type: private
 *     @param: itemId - target node id
 *     @param: state - checkbox state
 *     @param: sNode - target node object (optional, used by private methods)
 *     @topic: 5
 */
dhtmlXTreeObject.prototype._setSubChecked=function(state,sNode){
    state=dhx4.s2b(state);
    if (!sNode) return;
    if (((sNode.parentObject._r_logic)||(this._frbtr))&&(state))
        for (var i=0; i<sNode.parentObject.childsCount; i++)
            this._setSubChecked(0,sNode.parentObject.childNodes[i]);

//#__pro_feature:01112006{
//#smart_parsing:01112006{
    if (sNode.unParsed)
        this._setSubCheckedXML(state,sNode.unParsed)
//#}
//#}
    if (sNode._r_logic||this._frbtr)
        this._setSubChecked(state,sNode.childNodes[0]);
    else
        for (var i=0; i<sNode.childsCount; i++)
        {
            this._setSubChecked(state,sNode.childNodes[i]);
        };
    var z=sNode.htmlNode.childNodes[0].childNodes[0].childNodes[1].childNodes[0];

    if (state) sNode.checkstate=1;
    else    sNode.checkstate=0;
    if (sNode.dscheck)  sNode.checkstate=sNode.dscheck;



    this._setSrc(z,this.imPath+((sNode.parentObject._r_logic||this._frbtr)?this.radioArray:this.checkArray)[sNode.checkstate]);
};

/**
 *     @desc: get state of nodes's checkbox
 *     @type: public
 *     @param: itemId - target node id
 *     @return: node state (0 - unchecked,1 - checked, 2 - third state)
 *     @topic: 5
 */
dhtmlXTreeObject.prototype.isItemChecked=function(itemId){
    var sNode=this._globalIdStorageFind(itemId);
    if (!sNode) return;
    return   sNode.checkstate;
};







/**
 *     @desc: delete all children of node
 *     @type: public
 *     @param: itemId - node id
 *     @topic: 2
 */
dhtmlXTreeObject.prototype.deleteChildItems=function(itemId)
{
    var sNode=this._globalIdStorageFind(itemId);
    if (!sNode) return;
    var j=sNode.childsCount;
    for (var i=0; i<j; i++)
    {
        this._deleteNode(sNode.childNodes[0].id,sNode.childNodes[0]);
    };
};

/**
 *     @desc: delete node
 *     @type: public
 *     @param: itemId - node id
 *     @param: selectParent - If true parent of deleted item get selection, else no selected items leaving in tree.
 *     @topic: 2
 */
dhtmlXTreeObject.prototype.deleteItem=function(itemId,selectParent){
    if ((!this._onrdlh)||(this._onrdlh(itemId))){
        var z=this._deleteItem(itemId,selectParent);
//#__pro_feature:01112006{
//#child_calc:01112006{
        if (z)
            this._fixChildCountLabel(z);
//#}
//#}
    }

    //nb:solves standard doctype prb in IE
    this.allTree.childNodes[0].border = "1";
    this.allTree.childNodes[0].border = "0";
}
/**
 *     @desc: delete node
 *     @type: private
 *     @param: id - node id
 *     @param: selectParent - If true parent of deleted item get selection, else no selected items leaving in tree.
 *     @param: skip - unregistering mode (optional, used by private methods)
 *     @topic: 2
 */
dhtmlXTreeObject.prototype._deleteItem=function(itemId,selectParent,skip){
    selectParent=dhx4.s2b(selectParent);
    var sNode=this._globalIdStorageFind(itemId);
    if (!sNode) return;
    var pid=this.getParentId(itemId);

    var zTemp=sNode.parentObject;
    this._deleteNode(itemId,sNode,skip);
    if(this._editCell&&this._editCell.id==itemId)
        this._editCell = null;
    this._correctPlus(zTemp);
    this._correctLine(zTemp);

    if  ((selectParent)&&(pid!=this.rootId)) this.selectItem(pid,1);
    return    zTemp;
};

/**
 *     @desc: uregister all child nodes of target node
 *     @type: private
 *     @param: itemObject - node object
 *     @topic: 3
 */
dhtmlXTreeObject.prototype._globalIdStorageRecSub=function(itemObject){
    for(var i=0; i<itemObject.childsCount; i++)
    {
        this._globalIdStorageRecSub(itemObject.childNodes[i]);
        this._globalIdStorageSub(itemObject.childNodes[i].id);
    };
    this._globalIdStorageSub(itemObject.id);

    /*anti memory leaking*/
    var z=itemObject;
//		var par=z.span.parentNode.parentNode.childNodes;
//		par[0].parentObject=null;
//		par[1].childNodes[0].parentObject=null;
//		par[2].childNodes[0].parentObject=null;
//		par[2].childNodes[0].treeNod=null;
//		par[2].parentObject=null;
//		par[3].parentObject=null;
    z.span=null;
    z.tr.nodem=null;
    z.tr=null;
    z.htmlNode=null;
};

/**
 *     @desc: create new node next to specified
 *     @type: public
 *     @param: itemId - node id
 *     @param: newItemId - new node id
 *     @param: itemText - new node text
 *     @param: itemActionHandler - function fired on node select event (optional)
 *     @param: image1 - image for node without children; (optional)
 *     @param: image2 - image for closed node; (optional)
 *     @param: image3 - image for opened node (optional)
 *     @param: optionStr - options string (optional)
 *     @param: children - node children flag (for dynamical trees) (optional)
 *     @topic: 2
 */
dhtmlXTreeObject.prototype.insertNewNext=function(itemId,newItemId,itemText,itemActionHandler,image1,image2,image3,optionStr,children){
    var sNode=this._globalIdStorageFind(itemId);
    if ((!sNode)||(!sNode.parentObject)) return (0);

    var nodez=this._attachChildNode(0,newItemId,itemText,itemActionHandler,image1,image2,image3,optionStr,children,sNode);
//#__pro_feature:01112006{
//#child_calc:01112006{
    if ((!this.XMLloadingWarning)&&(this.childCalc))  this._fixChildCountLabel(sNode.parentObject);
//#}
//#}
    return nodez;
};



/**
 *     @desc: retun node id by index
 *     @type: public
 *     @param: itemId - parent node id
 *     @param: index - index of node, 0 based
 *     @return: node id
 *     @topic: 1
 */
dhtmlXTreeObject.prototype.getItemIdByIndex=function(itemId,index){
    var z=this._globalIdStorageFind(itemId);
    if ((!z)||(index>=z.childsCount)) return null;
    return z.childNodes[index].id;
};

/**
 *     @desc: retun child node id by index
 *     @type: public
 *     @param: itemId - parent node id
 *     @param: index - index of child node
 *     @return: node id
 *     @topic: 1
 */
dhtmlXTreeObject.prototype.getChildItemIdByIndex=function(itemId,index){
    var z=this._globalIdStorageFind(itemId);
    if ((!z)||(index>=z.childsCount)) return null;
    return z.childNodes[index].id;
};





/**
 *     @desc: set function called when drag-and-drop event occured
 *     @param: aFunc - event handling function
 *     @type: deprecated
 *     @topic: 0,7
 *     @event:    onDrag
 *     @depricated: use grid.attachEvent("onDrag",func); instead
 *     @eventdesc: Event occured after item was dragged and droped on another item, but before item moving processed.
 Event also raised while programmatic moving nodes.
 *     @eventparam:  ID of source item
 *     @eventparam:  ID of target item
 *     @eventparam:  if node droped as sibling then contain id of item before whitch source node will be inserted
 *     @eventparam:  source Tree object
 *     @eventparam:  target Tree object
 *     @eventreturn:  true - confirm drag-and-drop; false - deny drag-and-drop;
 */
dhtmlXTreeObject.prototype.setDragHandler=function(func){ this.attachEvent("onDrag",func); };

/**
 *     @desc: clear selection from node
 *     @param: htmlNode - pointer to node object
 *     @type: private
 *     @topic: 1
 */
dhtmlXTreeObject.prototype._clearMove=function(){
    if (this._lastMark){
        this._lastMark.className=this._lastMark.className.replace(/dragAndDropRow/g,"");
        this._lastMark=null;
    }
//#__pro_feature:01112006{
//#complex_move:01112006{
    this.selectionBar.style.display="none";
//#}
//#}
    this.allTree.className=this.allTree.className.replace(" selectionBox","");
};

/**
 *     @desc: enable/disable drag-and-drop
 *     @type: public
 *     @param: mode - enabled/disabled [ can be true/false/temporary_disabled - last value mean that tree can be D-n-D can be switched to true later ]
 *     @param: rmode - enabled/disabled drag and drop on super root
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.enableDragAndDrop=function(mode,rmode){
    if  (mode=="temporary_disabled"){
        this.dADTempOff=false;
        mode=true;                  }
    else
        this.dADTempOff=true;

    this.dragAndDropOff=dhx4.s2b(mode);
    if (this.dragAndDropOff) this.dragger.addDragLanding(this.allTree,this);
    if (arguments.length>1)
        this._ddronr=(!dhx4.s2b(rmode));
};

/**
 *     @desc: set selection on node
 *     @param: node - pointer to node object
 *     @type: private
 *     @topic: 1
 */
dhtmlXTreeObject.prototype._setMove=function(htmlNode,x,y){
    if (htmlNode.parentObject.span) {
        //window.status=x;
        var a1=dhx4.absTop(htmlNode);
        var a2=dhx4.absTop(this.allTree)-this.allTree.scrollTop;

        this.dadmodec=this.dadmode;//this.dadmode;
        this.dadmodefix=0;
//#__pro_feature:01112006{
//#complex_move:01112006{
        if (this.dadmode==2)
        {

            var z=y-a1+(document.body.scrollTop||document.documentElement.scrollTop)-2-htmlNode.offsetHeight/2;
            if ((Math.abs(z)-htmlNode.offsetHeight/6)>0)
            {
                this.dadmodec=1;
                //sibbling zone
                if (z<0)
                    this.dadmodefix=0-htmlNode.offsetHeight;
            }
            else this.dadmodec=0;

        }
        if (this.dadmodec==0)
        {
//#}
//#}

            var zN=htmlNode.parentObject.span;
            zN.className+=" dragAndDropRow";
            this._lastMark=zN;
//#__pro_feature:01112006{
//#complex_move:01112006{
        }
        else{
            this._clearMove();
            this.selectionBar.style.top=(a1-a2+((parseInt(htmlNode.parentObject.span.parentNode.previousSibling.childNodes[0].style.height)||18)-1)+this.dadmodefix)+"px";
            this.selectionBar.style.left="5px";
            if (this.allTree.offsetWidth>20)
                this.selectionBar.style.width=(this.allTree.offsetWidth-(_isFF?30:25))+"px";
            this.selectionBar.style.display="";
        }
//#}
//#}
        this._autoScroll(null,a1,a2);

    }
};

dhtmlXTreeObject.prototype._autoScroll=function(node,a1,a2){
    if (this.autoScroll)
    {
        if (node){
            a1=dhx4.absTop(node);
            a2=dhx4.absTop(this.allTree)-this.allTree.scrollTop;
        }
        //scroll down
        if ( (a1-a2-parseInt(this.allTree.scrollTop))>(parseInt(this.allTree.offsetHeight)-50) )
            this.allTree.scrollTop=parseInt(this.allTree.scrollTop)+20;
        //scroll top
        if ( (a1-a2)<(parseInt(this.allTree.scrollTop)+30) )
            this.allTree.scrollTop=parseInt(this.allTree.scrollTop)-20;
    }
}

/**
 *     @desc: create html element for dragging
 *     @type: private
 *     @param: htmlObject - html node object
 *     @topic: 1
 */
dhtmlXTreeObject.prototype._createDragNode=function(htmlObject,e){
    if (!this.dADTempOff) return null;

    var obj=htmlObject.parentObject;
    if (!this.callEvent("onBeforeDrag",[obj.id, e])) return null;
    if (!obj.i_sel){

        this._selectItem(obj,e);
    }
//#__pro_feature:01112006{
//#multiselect:01112006{
    this._checkMSelectionLogic();
//#}
//#}
    var dragSpan=document.createElement('div');

    var text=new Array();
    if (this._itim_dg)
        for (var i=0; i<this._selected.length; i++)
            text[i]="<table cellspacing='0' cellpadding='0'><tr><td><img width='18px' height='18px' src='"+this._getSrc(this._selected[i].span.parentNode.previousSibling.childNodes[0])+"'></td><td>"+this._selected[i].span.innerHTML+"</td></tr></table>";
    else
        text=this.getSelectedItemText().split(this.dlmtr);

    dragSpan.innerHTML=text.join("");
    dragSpan.style.position="absolute";
    dragSpan.className="dragSpanDiv";
    this._dragged=(new Array()).concat(this._selected);
    return dragSpan;
}



/**
 *     @desc: focus item in tree
 *     @type: private
 *     @param: item - node object
 *     @edition: Professional
 *     @topic: 0
 */
dhtmlXTreeObject.prototype._focusNode=function(item){
    var z=dhx4.absTop(item.htmlNode)-dhx4.absTop(this.allTree);
    if ((z>(this.allTree.offsetHeight-30)) || (z<0))
        this.allTree.scrollTop=z+this.allTree.scrollTop;
};













///DragAndDrop

dhtmlXTreeObject.prototype._preventNsDrag=function(e){
    if ((e)&&(e.preventDefault)) { e.preventDefault(); return false; }
    return false;
}

dhtmlXTreeObject.prototype._drag=function(sourceHtmlObject,dhtmlObject,targetHtmlObject){
    if (this._autoOpenTimer) clearTimeout(this._autoOpenTimer);

    if (!targetHtmlObject.parentObject){
        targetHtmlObject=this.htmlNode.htmlNode.childNodes[0].childNodes[0].childNodes[1].childNodes[0];
        this.dadmodec=0;
    }

    this._clearMove();
    var z=sourceHtmlObject.parentObject.treeNod;
    if ((z)&&(z._clearMove))   z._clearMove("");

    if ((!this.dragMove)||(this.dragMove()))
    {
        if ((!z)||(!z._clearMove)||(!z._dragged)) var col=new Array(sourceHtmlObject.parentObject);
        else var col=z._dragged;
        var trg=targetHtmlObject.parentObject;

        for (var i=0; i<col.length; i++){
            var newID=this._moveNode(col[i],trg);
            if ((this.dadmodec)&&(newID!==false)) trg=this._globalIdStorageFind(newID,true,true);
            if ((newID)&&(!this._sADnD)) this.selectItem(newID,0,1);
        }

    }
    if (z) z._dragged=new Array();


}

dhtmlXTreeObject.prototype._dragIn=function(htmlObject,shtmlObject,x,y){

    if (!this.dADTempOff) return 0;
    var fobj=shtmlObject.parentObject;
    var tobj=htmlObject.parentObject;
    if ((!tobj)&&(this._ddronr)) return;
    if (!this.callEvent("onDragIn",[fobj.id,tobj?tobj.id:null,fobj.treeNod,this])){
        if (tobj) this._autoScroll(htmlObject);
        return 0;
    }


    if (!tobj)
        this.allTree.className+=" selectionBox";
    else
    {
        if (fobj.childNodes==null){
            this._setMove(htmlObject,x,y);
            return htmlObject;
        }

        var stree=fobj.treeNod;
        for (var i=0; i<stree._dragged.length; i++)
            if (this._checkPNodes(tobj,stree._dragged[i])){
                this._autoScroll(htmlObject);
                return 0;
            }
//#__pro_feature:01112006{
//#complex_move:01112006{
        this.selectionBar.parentNode.removeChild(this.selectionBar);
        tobj.span.parentNode.appendChild(this.selectionBar);
//#}
//#}
        this._setMove(htmlObject,x,y);
        if (this._getOpenState(tobj)<=0){
            var self = this;
            this._autoOpenId=tobj.id;
            this._autoOpenTimer=window.setTimeout(function(){
                self._autoOpenItem(null, self);
                self = null;
            }, 1000);
        }
    }

    return htmlObject;

}
dhtmlXTreeObject.prototype._autoOpenItem=function(e,treeObject){
    treeObject.openItem(treeObject._autoOpenId);
};
dhtmlXTreeObject.prototype._dragOut=function(htmlObject){
    this._clearMove();
    if (this._autoOpenTimer) clearTimeout(this._autoOpenTimer);
}


//#__pro_feature:01112006{

/**
 *     @desc: return next node
 *     @type: private
 *     @param: item - node object
 *     @param: mode - inner flag
 *     @return: next node or -1
 *     @topic: 2
 */
dhtmlXTreeObject.prototype._getNextNode=function(item,mode){
    if ((!mode)&&(item.childsCount)) return item.childNodes[0];
    if (item==this.htmlNode)
        return -1;
    if ((item.tr)&&(item.tr.nextSibling)&&(item.tr.nextSibling.nodem))
        return item.tr.nextSibling.nodem;

    return this._getNextNode(item.parentObject,true);
};

/**
 *     @desc: return last child of item (include all sub-child collections)
 *     @type: private
 *     @param: item - node object
 *     @topic: 2
 */
dhtmlXTreeObject.prototype._lastChild=function(item){
    if (item.childsCount)
        return this._lastChild(item.childNodes[item.childsCount-1]);
    else return item;
};

/**
 *     @desc: return previous node
 *     @type: private
 *     @param: item - node object
 *     @param: mode - inner flag
 *     @return: previous node or -1
 *     @topic: 2
 */
dhtmlXTreeObject.prototype._getPrevNode=function(node,mode){
    if ((node.tr)&&(node.tr.previousSibling)&&(node.tr.previousSibling.nodem))
        return this._lastChild(node.tr.previousSibling.nodem);

    if (node.parentObject)
        return node.parentObject;
    else return -1;
};



//#find_item:01112006{

/**
 *     @desc: find tree item by text, select and focus it
 *     @type: public
 *     @param: searchStr - search text
 *     @param: direction - 0: top -> bottom; 1: bottom -> top
 *     @param: top - 1: start searching from top
 *     @return: node id
 *     @edition: Professional
 *     @topic: 2
 */
dhtmlXTreeObject.prototype.findItem=function(searchStr,direction,top){
    var z=this._findNodeByLabel(searchStr,direction,(top?this.htmlNode:null));
    if (z){
        this.selectItem(z.id,true);
        this._focusNode(z);
        return z.id;
    }
    else return null;
}

/**
 *     @desc: find tree item by text
 *     @type: public
 *     @param: searchStr - search text
 *     @param: direction - 0: top -> bottom; 1: bottom -> top
 *     @param: top - 1: start searching from top
 *     @return: node id
 *     @edition: Professional
 *     @topic: 2
 */
dhtmlXTreeObject.prototype.findItemIdByLabel=function(searchStr,direction,top){
    var z=this._findNodeByLabel(searchStr,direction,(top?this.htmlNode:null));
    if (z)
        return z.id
    else return null;
}

//#smart_parsing:01112006{
/**
 *     @desc: find tree item by text in unParsed XML
 *     @type: private
 *     @param: node - start xml node
 *     @param: field - name of xml attribute
 *     @param: cvalue - search text
 *     @return: true/false
 *     @topic: 2
 */
dhtmlXTreeObject.prototype.findStrInXML=function(node,field,cvalue){
    if (!node.childNodes && node.item) return this.findStrInJSON(node,field,cvalue);
    if(!node.childNodes)
        return false;
    for (var i=0; i<node.childNodes.length; i++)
    {
        if (node.childNodes[i].nodeType==1)
        {

            var z=node.childNodes[i].getAttribute(field);
            if (!z && node.childNodes[i].tagName=="itemtext")  z=node.childNodes[i].firstChild.data;
            if ((z)&&(z.toLowerCase().search(cvalue)!=-1))
                return true;
            if (this.findStrInXML(node.childNodes[i],field,cvalue)) return true;
        }
    }
    return false;
}
dhtmlXTreeObject.prototype.findStrInJSON=function(node,field,cvalue){
    for (var i=0; i<node.item.length; i++)
    {
        var z=node.item[i].text;
        if ((z)&&(z.toLowerCase().search(cvalue)!=-1))
            return true;
        if (node.item[i].item && this.findStrInJSON(node.item[i],field,cvalue)) return true;
    }
    return false;
}
//#}

/**
 *     @desc: find tree item by text
 *     @type: private
 *     @param: searchStr - search text
 *     @param: direction - 0: top -> bottom; 1: bottom -> top
 *     @param: fromNode - node from which search begin
 *     @return: node id
 *     @topic: 2
 */
dhtmlXTreeObject.prototype._findNodeByLabel=function(searchStr,direction,fromNode){
    //trim
    var searchStr=searchStr.replace(new RegExp("^( )+"),"").replace(new RegExp("( )+$"),"");
    searchStr =  new RegExp(searchStr.replace(/([\^\.\?\*\+\\\[\]\(\)]{1})/gi,"\\$1").replace(/ /gi,".*"),"gi");

    //get start node
    if (!fromNode)
    {
        fromNode=this._selected[0];
        if (!fromNode) fromNode=this.htmlNode;
    }

    var startNode=fromNode;

    //first step
    if (!direction){
        if ((fromNode.unParsed)&&(this.findStrInXML(fromNode.unParsed.d,"text",searchStr)))
            this.reParse(fromNode);
        fromNode=this._getNextNode(startNode);
        if (fromNode==-1) fromNode=this.htmlNode.childNodes[0];
    }
    else
    {
        var z2=this._getPrevNode(startNode);
        if (z2==-1) z2=this._lastChild(this.htmlNode);
        if ((z2.unParsed)&&(this.findStrInXML(z2.unParsed.d,"text",searchStr)))
        {   this.reParse(z2); fromNode=this._getPrevNode(startNode); }
        else fromNode=z2;
        if (fromNode==-1) fromNode=this._lastChild(this.htmlNode);
    }



    while ((fromNode)&&(fromNode!=startNode)){
        if ((fromNode.label)&&(fromNode.label.search(searchStr)!=-1))
            return (fromNode);

        if (!direction){
            if (fromNode==-1) { if (startNode==this.htmlNode) break; fromNode=this.htmlNode.childNodes[0]; }
            if ((fromNode.unParsed)&&(this.findStrInXML(fromNode.unParsed.d,"text",searchStr)))
                this.reParse(fromNode);
            fromNode=this._getNextNode(fromNode);
            if (fromNode==-1) fromNode=this.htmlNode;
        }
        else
        {
            var z2=this._getPrevNode(fromNode);
            if (z2==-1) z2=this._lastChild(this.htmlNode);
            if ((z2.unParsed)&&(this.findStrInXML(z2.unParsed.d,"text",searchStr)))
            {   this.reParse(z2); fromNode=this._getPrevNode(fromNode); }
            else fromNode=z2;
            if (fromNode==-1) fromNode=this._lastChild(this.htmlNode);
        }
    }
    return null;
};

//#}
//#}


//#complex_move:01112006{

/**
 *     @desc: move item (inside of tree)
 *     @type:  public
 *     @param: itemId - item Id
 *     @param: mode - moving mode (left,up,down,item_child,item_sibling,item_sibling_next,up_strict,down_strict)
 *     @param: targetId - target Node in item_child and item_sibling mode
 *     @param: targetTree - used for moving between trees (optional)
 *     @return: node id
 *     @topic: 2
 */
dhtmlXTreeObject.prototype.moveItem=function(itemId,mode,targetId,targetTree)
{
    var sNode=this._globalIdStorageFind(itemId);
    if (!sNode) return (0);
    var resultId = null;
    switch(mode){
        case "right":
            alert('Not supported yet');
            break;
        case "item_child":
            var tNode=(targetTree||this)._globalIdStorageFind(targetId);
            if (!tNode) return (0);
            resultId = (targetTree||this)._moveNodeTo(sNode,tNode,0);
            break;
        case "item_sibling":
            var tNode=(targetTree||this)._globalIdStorageFind(targetId);
            if (!tNode) return (0);
            resultId = (targetTree||this)._moveNodeTo(sNode,tNode.parentObject,tNode);
            break;
        case "item_sibling_next":
            var tNode=(targetTree||this)._globalIdStorageFind(targetId);
            if (!tNode) return (0);
            if ((tNode.tr)&&(tNode.tr.nextSibling)&&(tNode.tr.nextSibling.nodem))
                resultId = (targetTree||this)._moveNodeTo(sNode,tNode.parentObject,tNode.tr.nextSibling.nodem);
            else
                resultId = (targetTree||this)._moveNodeTo(sNode,tNode.parentObject);
            break;
        case "left":
            if (sNode.parentObject.parentObject)
                resultId = this._moveNodeTo(sNode,sNode.parentObject.parentObject,sNode.parentObject);
            break;
        case "up":
            var z=this._getPrevNode(sNode);
            if ((z==-1)||(!z.parentObject)) return null;
            resultId = this._moveNodeTo(sNode,z.parentObject,z);
            break;
        case "up_strict":
            var z=this._getIndex(sNode);
            if (z!=0)
                resultId = this._moveNodeTo(sNode,sNode.parentObject,sNode.parentObject.childNodes[z-1]);
            break;
        case "down_strict":
            var z=this._getIndex(sNode);
            var count=sNode.parentObject.childsCount-2;
            if (z==count)
                resultId = this._moveNodeTo(sNode,sNode.parentObject);
            else if (z<count)
                resultId = this._moveNodeTo(sNode,sNode.parentObject,sNode.parentObject.childNodes[z+2]);
            break;
        case "down":
            var z=this._getNextNode(this._lastChild(sNode));
            if ((z==-1)||(!z.parentObject)) return;
            if (z.parentObject==sNode.parentObject)
                var z=this._getNextNode(z);
            if (z==-1){
                resultId = this._moveNodeTo(sNode,sNode.parentObject);
            }
            else{
                if ((z==-1)||(!z.parentObject)) return;
                resultId = this._moveNodeTo(sNode,z.parentObject,z);
            }
            break;
    }
    if (_isIE && _isIE<8){
        this.allTree.childNodes[0].border = "1";
        this.allTree.childNodes[0].border = "0";
    }
    return resultId;
}

//#__pro_feature:01112006{

/**
 *     @desc: set Drag-And-Drop behavior (child - drop as chils, sibling - drop as sibling, complex - complex drop behaviour )
 *     @type: public
 *     @edition: Professional
 *     @param: mode - behavior name (child,sibling,complex)
 *     @param: select - select droped node after drag-n-drop, true by default
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.setDragBehavior=function(mode,select){
    this._sADnD=(!dhx4.s2b(select));
    switch (mode) {
        case "child": this.dadmode=0; break;
        case "sibling": this.dadmode=1; break;
        case "complex": this.dadmode=2; break;
    }    };




//#}
//#}







/**
 *     @desc: load xml for tree branch
 *     @param: id - id of parent node
 *     @param: src - path to xml, optional
 *     @type: private
 *     @topic: 1
 */
dhtmlXTreeObject.prototype._loadDynXML=function(id,src) {
    src=src||this.XMLsource;
    var sn=(new Date()).valueOf();
    this._ld_id=id;
//#__pro_feature:01112006{
    if (this.xmlalb=="function"){
        if (src) src(this._escape(id));
    }
    else
    if (this.xmlalb=="name")
        this.load(src+this._escape(id));
    else
    if (this.xmlalb=="xmlname")
        this.load(src+this._escape(id)+".xml?uid="+sn);
    else
//#}
        this.load(src+dhtmlx.url(src)+"uid="+sn+"&id="+this._escape(id));
};


//#__pro_feature:01112006{
//#multiselect:01112006{
/**
 *     @desc: enable multiselection
 *     @beforeInit: 1
 *     @param: mode - 1 - on, 0 - off;
 *     @param: strict - 1 - on, 0 - off; in strict mode only items on the same level can be selected
 *     @type: public
 *     @edition: Professional
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.enableMultiselection=function(mode,strict) {
    this._amsel=dhx4.s2b(mode);
    this._amselS=dhx4.s2b(strict);
};

/**
 *     @desc: check logic of selection
 *     @type: private
 *     @edition: Professional
 *     @topic: 0
 */
dhtmlXTreeObject.prototype._checkMSelectionLogic=function() {
    var usl=new Array();
    for (var i=0; i<this._selected.length; i++)
        for (var j=0; j<this._selected.length; j++)
            if ((i!=j)&&(this._checkPNodes(this._selected[j],this._selected[i])))
                usl[usl.length]=this._selected[j];

    for (var i=0; i<usl.length; i++)
        this._unselectItem(usl[i]);

};
//#}
//#}




/**
 *     @desc: check possibility of drag-and-drop
 *     @type: private
 *     @param: itemId - draged node id
 *     @param: htmlObject - droped node object
 *     @param: shtmlObject - sourse node object
 *     @topic: 6
 */
dhtmlXTreeObject.prototype._checkPNodes=function(item1,item2){
    if (this._dcheckf) return false;
    if (item2==item1) return 1
    if (item1.parentObject) return this._checkPNodes(item1.parentObject,item2); else return 0;
};
dhtmlXTreeObject.prototype.disableDropCheck = function(mode){
    this._dcheckf = dhx4.s2b(mode);
};


//#__pro_feature:01112006{
//#distributed_load:01112006{

/**
 *     @desc: enable distributed parsing of big tree (items loaded portion by portion with some timeouts)
 *     @type: public
 *     @edition: Professional
 *     @param: mode - true/false
 *     @param: count - critical count to start distibuting (optional)
 *     @param: delay - delay between distributed calls, ms (optional)
 *     @topic: 2
 */
dhtmlXTreeObject.prototype.enableDistributedParsing=function(mode,count,delay){
    this._edsbps=dhx4.s2b(mode);
    this._edsbpsA=new Array();
    this._edsbpsC=count||10;
    this._edsbpsD=delay||250;
}
/**
 *     @desc: get current state of distributed parsing
 *     @type: public
 *     @edition: Professional
 *     @returns: true - still parsing; false - parsing finished
 *     @topic: 2
 */
dhtmlXTreeObject.prototype.getDistributedParsingState=function(){
    return (!((!this._edsbpsA)||(!this._edsbpsA.length)));
}
/**
 *     @desc: get current parsing state of item
 *     @type: public
 *     @edition: Professional
 *     @returns: 1 - item already parsed; 0 - item not parsed yet; -1 - item in parsing process
 *     @topic: 2
 */
dhtmlXTreeObject.prototype.getItemParsingState=function(itemId){
    var z=this._globalIdStorageFind(itemId,true,true)
    if (!z) return 0;
    if (this._edsbpsA)
        for (var i=0; i<this._edsbpsA.length; i++)
            if (this._edsbpsA[i][2]==itemId) return -1;

    return 1;
}

dhtmlXTreeObject.prototype._distributedStart=function(node,start,parentId,level,start2){
    if (!this._edsbpsA)
        this._edsbpsA=new Array();
    this._edsbpsA[this._edsbpsA.length]=[node,start,parentId,level,start2];
}

dhtmlXTreeObject.prototype._distributedStep=function(pId){
    var self=this;
    if ((!this._edsbpsA)||(!this._edsbpsA.length)) {
        self.XMLloadingWarning=0;
        return;
    }
    var z=this._edsbpsA[0];
    this.parsedArray=new Array();
    this._parse(z[0],z[2],z[3],z[1]);
    var zkx=this._globalIdStorageFind(z[2]);
    this._redrawFrom(this,zkx,z[4],this._getOpenState(zkx));
    var chArr=this.setCheckList.split(this.dlmtr);
    for (var n=0; n<chArr.length; n++)
        if (chArr[n]) this.setCheck(chArr[n],1);

    this._edsbpsA=(new Array()).concat(this._edsbpsA.slice(1));


    if ((!this._edsbpsA.length)){
        window.setTimeout( function(){ if (self.onXLE) self.onXLE(self,pId); self.callEvent("onXLE",[self,pId]); },1);
        self.xmlstate=0;
    }
}

//#}
//#}




//#__pro_feature:01112006{

/**
 *     @desc: replace images with text signs
 *     @type: public
 *     @param: mode - true/false
 *     @edition: Professional
 *     @topic: 1
 */
dhtmlXTreeObject.prototype.enableTextSigns=function(mode){
    this._txtimg=dhx4.s2b(mode);
}

//#}

/**
 *   @desc:  prevent caching in IE  by adding random value to URL string
 *   @param: mode - enable/disable random value ( disabled by default )
 *   @type: public
 *   @topic: 0
 */
dhtmlXTreeObject.prototype.preventIECaching=function(mode){
    dhx4.ajax.cache = !mode;
}
dhtmlXTreeObject.prototype.preventIECashing=dhtmlXTreeObject.prototype.preventIECaching;





/**
 *     @desc: disable checkbox
 *     @param: itemId - Id of tree item
 *     @param: mode - 1 - on, 0 - off;
 *     @type: public
 *     @topic: 5
 */
dhtmlXTreeObject.prototype.disableCheckbox=function(itemId,mode) {
    if (typeof(itemId)!="object")
        var sNode=this._globalIdStorageFind(itemId,0,1);
    else
        var sNode=itemId;
    if (!sNode) return;
    sNode.dscheck=dhx4.s2b(mode)?(((sNode.checkstate||0)%3)+3):((sNode.checkstate>2)?(sNode.checkstate-3):sNode.checkstate);
    this._setCheck(sNode);
    if (sNode.dscheck<3) sNode.dscheck=false;
};

//#__pro_feature:01112006{


/**
 *     @desc: refresh specified tree branch (get XML from server, add new nodes, remove not used nodes)
 *     @param: itemId -  top node in branch
 *     @param: source - server side script , optional
 *     @type: public
 *     @edition: Professional
 *     @topic: 6
 */
dhtmlXTreeObject.prototype.smartRefreshBranch=function(itemId,source){
    this._branchUpdate=1;
    this.smartRefreshItem(itemId,source);
}

/**
 *     @desc: refresh specified tree item (get XML from server, add new nodes, remove not used nodes)
 *     @param: itemId -  top node in branch
 *     @param: source - server side script , optional
 *     @type: public
 *     @edition: Professional
 *     @topic: 6
 */
dhtmlXTreeObject.prototype.smartRefreshItem=function(itemId,source){
    var sNode=this._globalIdStorageFind(itemId);
    for (var i=0; i<sNode.childsCount; i++)
        sNode.childNodes[i]._dmark=true;

    this.waitUpdateXML=true;
    if (source && source.exists)
        this._parse(source,itemId);
    else
        this._loadDynXML(itemId,source);
};


/**
 *     @desc: refresh specified tree nodes (get XML from server and updat only nodes included in itemIdList)
 *     @param: itemIdList - list of node identificators
 *     @param: source - server side script
 *     @type: public
 *     @edition: Professional
 *     @topic: 6
 */
dhtmlXTreeObject.prototype.refreshItems=function(itemIdList,source){
    var z=itemIdList.toString().split(this.dlmtr);
    this.waitUpdateXML=new Array();
    for (var i=0; i<z.length; i++)
        this.waitUpdateXML[z[i]]=true;
    this.load((source||this.XMLsource)+dhtmlx.url(source||this.XMLsource)+"ids="+this._escape(itemIdList));
};


/**
 *     @desc: update item properties
 *     @param: itemId - list of node identificators
 *     @param: name - list of node identificators, optional
 *     @param: im0 - list of node identificators, optional
 *     @param: im1 - list of node identificators, optional
 *     @param: im2 - list of node identificators, optional
 *     @param: achecked - list of node identificators, optional
 *     @param: child - child attribute for dynamic loading
 *     @type: public
 *     @edition: Professional
 *     @topic: 6
 */
dhtmlXTreeObject.prototype.updateItem=function(itemId,name,im0,im1,im2,achecked,child){
    var sNode=this._globalIdStorageFind(itemId);
    sNode.userData=new cObject();
    if (name) sNode.label=name;
    sNode.images=new Array(im0||this.imageArray[0],im1||this.imageArray[1],im2||this.imageArray[2]);
    this.setItemText(itemId,name);
    if (achecked) this._setCheck(sNode,true);
    if(child=="1" && !this.hasChildren(itemId)) sNode.XMLload = 0;
    this._correctPlus(sNode);
    sNode._dmark=false;
    return sNode;
};

/**
 *     @desc: set function called after drag-and-drap event occured
 *     @param: func - event handling function
 *     @type: deprecated
 *     @edition: Professional
 *     @topic: 0,7
 *     @event:  onDrop
 *     @depricated: use grid.attachEvent("onDrop",func); instead
 *     @eventdesc:  Event raised after drag-and-drop processed. Event also raised while programmatic moving nodes.
 *     @eventparam:  ID of source item (ID after inserting in tree, my be not equal to initial ID)
 *     @eventparam:  ID of target item
 *     @eventparam:  if node droped as sibling then contain id of item before whitch source node will be inserted
 *     @eventparam:  source Tree object
 *     @eventparam:  target Tree object
 */
dhtmlXTreeObject.prototype.setDropHandler=function(func){  this.attachEvent("onDrop",func);  };

/**
 *     @desc: set function called before xml loading/parsing started
 *     @param: func - event handling function
 *     @type: deprecated
 *     @edition: Professional
 *     @topic: 0,7
 *     @event:  onXLS
 *     @depricated: use grid.attachEvent("onXLS",func); instead
 *     @eventdesc: event fired simultaneously with starting XML parsing
 *     @eventparam: tree object
 *     @eventparam: item id, for which xml loaded
 */
dhtmlXTreeObject.prototype.setOnLoadingStart=function(func){    this.attachEvent("onXLS",func);  };
/**
 *     @desc: set function called after xml loading/parsing ended
 *     @param: func - event handling function
 *     @type: deprecated
 *     @edition: Professional
 *     @topic: 0,7
 *     @event:  onXLE
 *     @depricated: use grid.attachEvent("onXLE",func); instead
 *     @eventdesc: event fired simultaneously with ending XML parsing, new items already available in tree
 *     @eventparam: tree object
 *     @eventparam: last parsed parent id
 */
dhtmlXTreeObject.prototype.setOnLoadingEnd=function(func){  this.attachEvent("onXLE",func); };



/**
 *     @desc: define which script be called on dynamic loading
 *     @param: mode - id for some_script?id=item_id ;  name for  some_scriptitem_id, xmlname for  some_scriptitem_id.xml ; function for calling user defined handler
 *     @type: public
 *     @edition: Professional
 *     @topic: 1
 */
dhtmlXTreeObject.prototype.setXMLAutoLoadingBehaviour=function(mode) {
    this.xmlalb=mode;
};


/**
 *     @desc: enable smart checkboxes ,true by default (auto checking children and parents for 3-state checkboxes)
 *     @param: mode - 1 - on, 0 - off;
 *     @type: public
 *     @edition: Professional
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.enableSmartCheckboxes=function(mode) { this.smcheck=dhx4.s2b(mode); };

/**
 *     @desc: return current state of XML loading
 *     @type: public
 *     @edition: Professional
 *     @return: current state, true - xml loading now
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.getXMLState=function(){ return (this.xmlstate==1); };

/**
 *     @desc: set top offset for item
 *     @type: public
 *     @param: itemId - id of item
 *     @param: value - value of top offset in px
 *     @edition: Professional
 *     @topic: 2
 */
dhtmlXTreeObject.prototype.setItemTopOffset=function(itemId,value){
    var node;
    if (typeof(itemId)!="object")
        node=this._globalIdStorageFind(itemId);
    else
        node=itemId;
    var z=node.span.parentNode.parentNode;
    node.span.style.paddingBottom="1px";

    for (var i=0; i<z.childNodes.length; i++){
        if (i!=0){

            if (_isIE){
                z.childNodes[i].style.height="18px";
                z.childNodes[i].style.paddingTop=parseInt(value)+"px";
            }else
                z.childNodes[i].style.height=18+parseInt(value)+"px";
        }
        else{
            var w=z.childNodes[i].firstChild;
            if (z.childNodes[i].firstChild.tagName!='DIV'){
                w=document.createElement("DIV");
                z.childNodes[i].insertBefore(w,z.childNodes[i].firstChild);
            }

            if ((node.parentObject.id!=this.rootId || node.parentObject.childNodes[0]!=node) && this.treeLinesOn){
                z.childNodes[i].style.backgroundImage="url("+this.imPath+this.lineArray[5]+")";
            }
            w.innerHTML="&nbsp;";
            w.style.overflow='hidden';

        }

        w.style.verticalAlign = z.childNodes[i].style.verticalAlign="bottom";
        if (_isIE){
            this.allTree.childNodes[0].border = "1";
            this.allTree.childNodes[0].border = "0";
        }
    }
}

/**
 *     @desc: set size of icons
 *     @type:  public
 *     @param: newWidth - new icon width
 *     @param: newHeight - new icon height
 *     @param: itemId - item Id, if skipped set default value for all new icons, optional
 *     @edition: Professional
 *     @topic: 2
 */
dhtmlXTreeObject.prototype.setIconSize=function(newWidth,newHeight,itemId)
{
    if (itemId){
        if ((itemId)&&(itemId.span))
            var sNode=itemId;
        else
            var sNode=this._globalIdStorageFind(itemId);

        if (!sNode) return (0);
        var img=sNode.span.parentNode.previousSibling.childNodes[0];
        if (newWidth) {
            img.style.width=newWidth+"px";
            if (window._KHTMLrv) img.parentNode.style.width=newWidth+"px";
        }
        if (newHeight) {
            img.style.height=newHeight+"px";
            if (window._KHTMLrv) img.parentNode.style.height=newHeight+"px";
        }
    }
    else{
        this.def_img_x=newWidth;
        this.def_img_y=newHeight;
    }
}

/**
 *     @desc: get url of item image
 *     @type: public
 *     @param: itemId - id of item
 *     @param: imageInd - index of image ( 0 - leaf, 1 - closed folder, 2 - opened folder)
 *     @param: value - value of top offset
 *     @edition: Professional
 *     @topic: 2
 */
dhtmlXTreeObject.prototype.getItemImage=function(itemId,imageInd,fullPath){
    var node=this._globalIdStorageFind(itemId);
    if (!node) return "";
    var img=node.images[imageInd||0];
    if (fullPath) img=this.iconURL+img;
    return img;
}

/**
 *     @desc: replace checkboxes with radio buttons
 *     @type: public
 *     @param: mode - true/false
 *     @param: itemId - node for which replacement called (optional)
 *     @edition: Professional
 *     @topic: 1
 */
dhtmlXTreeObject.prototype.enableRadioButtons=function(itemId,mode){
    if (arguments.length==1){
        this._frbtr=dhx4.s2b(itemId);
        this.checkBoxOff=this.checkBoxOff||this._frbtr;
        return;
    }


    var node=this._globalIdStorageFind(itemId);
    if (!node) return "";
    mode=dhx4.s2b(mode);
    if ((mode)&&(!node._r_logic)){
        node._r_logic=true;
        for (var i=0; i<node.childsCount; i++)
            this._setCheck(node.childNodes[i],node.childNodes[i].checkstate);
    }

    if ((!mode)&&(node._r_logic)){
        node._r_logic=false;
        for (var i=0; i<node.childsCount; i++)
            this._setCheck(node.childNodes[i],node.childNodes[i].checkstate);
    }
}
/**
 *     @desc: replace checkboxes with radio buttons
 *     @type: public
 *     @param: mode - true/false
 *     @param: itemId - node for which replacement called (optional)
 *     @edition: Professional
 *     @topic: 1
 */
dhtmlXTreeObject.prototype.enableSingleRadioMode=function(mode){
    this._frbtrs=dhx4.s2b(mode);
}


/**
 *     @desc: configure if parent node will be expanded immideatly after child item added
 *     @type: public
 *     @param: mode - true/false
 *     @edition: Professional
 *     @topic: 2
 */
dhtmlXTreeObject.prototype.openOnItemAdded=function(mode){
    this._hAdI=!dhx4.s2b(mode);
}
dhtmlXTreeObject.prototype.openOnItemAdding=function(mode){
    this._hAdI=!dhx4.s2b(mode);
}

/**
 *     @desc: enable multi line items
 *     @beforeInit: 1
 *     @param: width - text width, if equls zero then use single lines items;
 *     @type: public
 *     @edition: Professional
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.enableMultiLineItems=function(width) { if (width===true) this.mlitems="100%"; else this.mlitems=width; }

/**
 *     @desc: enable auto tooltips (node text as tooltip)
 *     @beforeInit: 1
 *     @param: mode - 1 - on, 0 - off;
 *     @type: public
 *     @edition:Professional
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.enableAutoTooltips=function(mode) { this.ettip=dhx4.s2b(mode); };


/**
 *     @desc: unselect item in tree
 *     @type: public
 *     @param: itemId - used in multi selection tree (optional)
 *     @edition: Professional
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.clearSelection=function(itemId){
    if (itemId)
        this._unselectItem(this._globalIdStorageFind(itemId));
    else
        this._unselectItems();
}

/**
 *     @desc: show/hide (+/-) icon (works only for individual items, not for entire tree )
 *     @type: public
 *     @param: itemId - id of selected item
 *     @param: state - show state : 0/1
 *     @edition: Professional
 *     @topic: 6
 */
dhtmlXTreeObject.prototype.showItemSign=function(itemId,state){
    var temp=this._globalIdStorageFind(itemId);
    if (!temp) return 0;

    var z=temp.span.parentNode.previousSibling.previousSibling.previousSibling;
    if (!dhx4.s2b(state)){
        this._openItem(temp)
        temp.closeble=false;
        temp.wsign=true;
    }
    else
    {
        temp.closeble=true;
        temp.wsign=false;
    }
    this._correctPlus(temp);
}
/**
 *     @desc: show/hide checkbox for tree item (works only for individual items, not for entire tree )
 *     @type: public
 *     @param: itemId - id of selected item, optional, set null to change states of all items
 *     @param: state - checkbox show state : 0/1
 *     @edition: Professional
 *     @topic: 5
 */
dhtmlXTreeObject.prototype.showItemCheckbox=function(itemId,state){
    if (!itemId)
        for (var a in this._idpull)
            this.showItemCheckbox(this._idpull[a],state);

    if (typeof(itemId)!="object")
        itemId=this._globalIdStorageFind(itemId,0,0);

    if (!itemId) return 0;
    itemId.nocheckbox=!dhx4.s2b(state);
    var t=itemId.span.parentNode.previousSibling.previousSibling.childNodes[0];
    t.parentNode.style.display=(!itemId.nocheckbox)?"":"none";
}

/**
 *     @desc: set list separator ("," by default)
 *     @type: public
 *     @param: separator - char or string to use for separating items in lists
 *     @edition: Professional
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.setListDelimeter=function(separator){
    this.dlmtr=separator;
}

//#}


/**
 *     @desc: set escaping mode (used for escaping ID in requests)
 *     @param: mode - escaping mode ("utf8" for UTF escaping)
 *     @type: public
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.setEscapingMode=function(mode){
    this.utfesc=mode;
}


/**
 *     @desc: enable item highlighting (item text highlited on mouseover)
 *     @beforeInit: 1
 *     @param: mode - 1 - on, 0 - off;
 *     @type: public
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.enableHighlighting=function(mode) { this.ehlt=true; this.ehlta=dhx4.s2b(mode); };

/**
 *     @desc: called on mouse out
 *     @type: private
 *     @topic: 0
 */
dhtmlXTreeObject.prototype._itemMouseOut=function(){
    var that=this.childNodes[3].parentObject;
    var tree=that.treeNod;
    tree.callEvent("onMouseOut",[that.id]);
    if (that.id==tree._l_onMSI) tree._l_onMSI=null;
    if (!tree.ehlta) return;
    that.span.className=that.span.className.replace("_lor","");
}
/**
 *     @desc: called on mouse in
 *     @type: private
 *     @topic: 0
 */
dhtmlXTreeObject.prototype._itemMouseIn=function(){
    var that=this.childNodes[3].parentObject;
    var tree=that.treeNod;

    if (tree._l_onMSI!=that.id) tree.callEvent("onMouseIn",[that.id]);
    tree._l_onMSI=that.id;
    if (!tree.ehlta) return;
    that.span.className=that.span.className.replace("_lor","");
    that.span.className=that.span.className.replace(/((standart|selected)TreeRow)/,"$1_lor");
}

/**
 *     @desc: enable active images (clickable and dragable). By default only text part of the node is active
 *     @beforeInit: 1
 *     @param: mode - 1 - on, 0 - off;
 *     @type: public
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.enableActiveImages=function(mode){this._aimgs=dhx4.s2b(mode); };

/**
 *     @desc: focus item in tree (scroll to it if necessary)
 *     @type: public
 *     @param: itemId - item Id
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.focusItem=function(itemId){
    var sNode=this._globalIdStorageFind(itemId);
    if (!sNode) return (0);
    this._focusNode(sNode);
};


/**
 *     @desc: Returns the list of all children from all next levels of tree, separated by default delimiter.
 *     @param: itemId - id of node
 *     @type: public
 *     @return: list of all children items from all next levels of tree, separated by default delimiter
 *     @topic: 6
 */
dhtmlXTreeObject.prototype.getAllSubItems =function(itemId){
    return this._getAllSubItems(itemId);
}

/**
 *     @desc: Returns the list of all items which doesn't have child nodes.
 *     @type: public
 *     @return: list of all items which doesn't have child nodes.
 *     @topic: 6
 */
dhtmlXTreeObject.prototype.getAllChildless =function(){
    return this._getAllScraggyItems(this.htmlNode);
}
dhtmlXTreeObject.prototype.getAllLeafs=dhtmlXTreeObject.prototype.getAllChildless;


/**
 *     @desc: Returns the list of all children from all next levels of tree, separated by default delimiter.
 *     @param: itemId - id of node
 *     @edition: Professional
 *     @type: private
 *     @topic: 6
 */
dhtmlXTreeObject.prototype._getAllScraggyItems =function(node)
{
    var z="";
    for (var i=0; i<node.childsCount; i++)
    {
        if ((node.childNodes[i].unParsed)||(node.childNodes[i].childsCount>0))
        {
            if (node.childNodes[i].unParsed)
                var zb=this._getAllScraggyItemsXML(node.childNodes[i].unParsed,1);
            else
                var zb=this._getAllScraggyItems(node.childNodes[i])

            if (zb)
                if (z) z+=this.dlmtr+zb;
                else z=zb;
        }
        else
        if (!z) z=""+node.childNodes[i].id;
        else z+=this.dlmtr+node.childNodes[i].id;
    }
    return z;
};





/**
 *     @desc: Returns the list of all children from all next levels of tree, separated by default delimiter.
 *     @param: itemId - id of node
 *     @type: private
 *     @edition: Professional
 *     @topic: 6
 */
dhtmlXTreeObject.prototype._getAllFatItems =function(node)
{
    var z="";
    for (var i=0; i<node.childsCount; i++)
    {
        if ((node.childNodes[i].unParsed)||(node.childNodes[i].childsCount>0))
        {
            if (!z) z=""+node.childNodes[i].id;
            else z+=this.dlmtr+node.childNodes[i].id;

            if (node.childNodes[i].unParsed)
                var zb=this._getAllFatItemsXML(node.childNodes[i].unParsed,1);
            else
                var zb=this._getAllFatItems(node.childNodes[i])

            if (zb) z+=this.dlmtr+zb;
        }
    }
    return z;
};

/**
 *     @desc: Returns the list of all items which have child nodes, separated by default delimiter.
 *     @type: public
 *     @return: list of all items which has child nodes, separated by default delimiter.
 *     @topic: 6
 */
dhtmlXTreeObject.prototype.getAllItemsWithKids =function(){
    return this._getAllFatItems(this.htmlNode);
}
dhtmlXTreeObject.prototype.getAllFatItems=dhtmlXTreeObject.prototype.getAllItemsWithKids;



/**
 *     @desc: return list of identificators of nodes with checked checkboxes, separated by default delimiter
 *     @type: public
 *     @return: list of ID of items with checked checkboxes, separated by default delimiter
 *     @topic: 5
 */
dhtmlXTreeObject.prototype.getAllChecked=function(){
    return this._getAllChecked("","",1);
}
/**
 *     @desc: return list of identificators of nodes with unchecked checkboxes, separated by default delimiter
 *     @type: public
 *     @return: list of ID of items with unchecked checkboxes, separated by default delimiter
 *     @topic: 5
 */
dhtmlXTreeObject.prototype.getAllUnchecked=function(itemId){
    if (itemId)
        itemId=this._globalIdStorageFind(itemId);
    return this._getAllChecked(itemId,"",0);
}


/**
 *     @desc: return list of identificators of nodes with third state checkboxes, separated by default delimiter
 *     @type: public
 *     @return: list of ID of items with third state checkboxes, separated by default delimiter
 *     @topic: 5
 */
dhtmlXTreeObject.prototype.getAllPartiallyChecked=function(){
    return this._getAllChecked("","",2);
}


/**
 *     @desc: return list of identificators of nodes with checked and third state checkboxes, separated by default delimiter
 *     @type: public
 *     @return: list of ID of items with checked and third state checkboxes, separated by default delimiter
 *     @topic: 5
 */
dhtmlXTreeObject.prototype.getAllCheckedBranches=function(){
    var temp = [this._getAllChecked("","",1)];
    var second = this._getAllChecked("","",2);
    if (second) temp.push(second);
    return temp.join(this.dlmtr);
}

/**
 *     @desc: return list of identificators of nodes with checked checkboxes
 *     @type: private
 *     @param: node - node object (optional, used by private methods)
 *     @param: list - initial identificators list (optional, used by private methods)
 *     @topic: 5
 */
dhtmlXTreeObject.prototype._getAllChecked=function(htmlNode,list,mode){
    if (!htmlNode) htmlNode=this.htmlNode;

    if (htmlNode.checkstate==mode)
        if (!htmlNode.nocheckbox)  { if (list) list+=this.dlmtr+htmlNode.id; else list=""+htmlNode.id;  }
    var j=htmlNode.childsCount;
    for (var i=0; i<j; i++)
    {
        list=this._getAllChecked(htmlNode.childNodes[i],list,mode);
    };
//#__pro_feature:01112006{
//#smart_parsing:01112006{
    if  (htmlNode.unParsed)
        list=this._getAllCheckedXML(htmlNode.unParsed,list,mode);
//#}
//#}

    if (list) return list; else return "";
};

/**
 *     @desc: set individual item style
 *     @type: public
 *     @param: itemId - node id
 *     @param: styleString - valid CSS string
 *     @param: resetCss - reset current style : 0/1
 *     @topic: 2
 */
dhtmlXTreeObject.prototype.setItemStyle=function(itemId,style_string,resetCss){
    var resetCss= resetCss|| false;
    var temp=this._globalIdStorageFind(itemId);
    if (!temp) return 0;
    if (!temp.span.style.cssText)
        temp.span.setAttribute("style",temp.span.getAttribute("style")+"; "+style_string);
    else
        temp.span.style.cssText = resetCss? style_string : temp.span.style.cssText+";"+style_string;
}

/**
 *     @desc: enable draging item image with item text
 *     @type: public
 *     @param: mode - true/false
 *     @topic: 1
 */
dhtmlXTreeObject.prototype.enableImageDrag=function(mode){
    this._itim_dg=dhx4.s2b(mode);
}

/**
 *     @desc: set function called when tree item draged over another item
 *     @param: func - event handling function
 *     @type: depricated
 *     @edition: Professional
 *     @topic: 4
 *     @event: onDragIn
 *     @depricated: use grid.attachEvent("onDragIn",func); instead
 *     @eventdesc: Event raised when item draged other other dropable target
 *     @eventparam:  ID draged item
 *     @eventparam:  ID potencial drop landing
 *     @eventparam:  source object
 *     @eventparam:  target object
 *     @eventreturn: true - allow drop; false - deny drop;
 */
dhtmlXTreeObject.prototype.setOnDragIn=function(func){
    this.attachEvent("onDragIn",func);
};

/**
 *     @desc: enable/disable auto scrolling while drag-and-drop
 *     @type: public
 *     @param: mode - enabled/disabled
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.enableDragAndDropScrolling=function(mode){ this.autoScroll=dhx4.s2b(mode); };


dhtmlXTreeObject.prototype.setSkin=function(name){
    var tmp = this.parentObject.className.replace(/dhxtree_[^ ]*/gi,"");
    this.parentObject.className= tmp+" dhxtree_"+name;
    if (name == "dhx_terrace" || name == "dhx_web")
        this.enableTreeLines(false);

};

//tree
(function(){

    dhtmlx.extend_api("dhtmlXTreeObject",{
        _init:function(obj){
            return [obj.parent,(obj.width||"100%"),(obj.height||"100%"),(obj.root_id||0)];
        },
        auto_save_selection:"enableAutoSavingSelected",
        auto_tooltip:"enableAutoTooltips",
        checkbox:"enableCheckBoxes",
        checkbox_3_state:"enableThreeStateCheckboxes",
        checkbox_smart:"enableSmartCheckboxes",
        context_menu:"enableContextMenu",
        distributed_parsing:"enableDistributedParsing",
        drag:"enableDragAndDrop",
        drag_copy:"enableMercyDrag",
        drag_image:"enableImageDrag",
        drag_scroll:"enableDragAndDropScrolling",
        editor:"enableItemEditor",
        hover:"enableHighlighting",
        images:"enableTreeImages",
        image_fix:"enableIEImageFix",
        image_path:"setImagePath",
        lines:"enableTreeLines",
        loading_item:"enableLoadingItem",
        multiline:"enableMultiLineItems",
        multiselect:"enableMultiselection",
        navigation:"enableKeyboardNavigation",
        radio:"enableRadioButtons",
        radio_single:"enableSingleRadioMode",
        rtl:"enableRTL",
        search:"enableKeySearch",
        smart_parsing:"enableSmartXMLParsing",
        smart_rendering:"enableSmartRendering",
        text_icons:"enableTextSigns",
        xml:"loadXML",
        skin:"setSkin"
    },{});

})();

dhtmlXTreeObject.prototype._dp_init=function(dp){
    dp.attachEvent("insertCallback", function(upd, id, parent) {
        var data = dhx4.ajax.xpath(".//item",upd);
        var text = data[0].getAttribute('text');
        this.obj.insertNewItem(parent, id, text, 0, 0, 0, 0, "CHILD");
    });

    dp.attachEvent("updateCallback", function(upd, id, parent) {
        var data = dhx4.ajax.xpath(".//item",upd);
        var text = data[0].getAttribute('text');
        this.obj.setItemText(id, text);
        if (this.obj.getParentId(id) != parent) {
            this.obj.moveItem(id, 'item_child', parent);
        }
        this.setUpdated(id, true, 'updated');
    });

    dp.attachEvent("deleteCallback", function(upd, id, parent) {
        this.obj.setUserData(id, this.action_param, "true_deleted");
        this.obj.deleteItem(id, false);
    });

    dp._methods=["setItemStyle","","changeItemId","deleteItem"];
    this.attachEvent("onEdit",function(state,id){
        if (state==3)
            dp.setUpdated(id,true)
        return true;
    });
    this.attachEvent("onDrop",function(id,id_2,id_3,tree_1,tree_2){
        if (tree_1==tree_2)
            dp.setUpdated(id,true);
    });
    this._onrdlh=function(rowId){
        var z=dp.getState(rowId);
        if (z=="inserted") {  dp.set_invalid(rowId,false); dp.setUpdated(rowId,false);	return true; }
        if (z=="true_deleted")  { dp.setUpdated(rowId,false); return true; }

        dp.setUpdated(rowId,true,"deleted")
        return false;
    };
    this._onradh=function(rowId){
        dp.setUpdated(rowId,true,"inserted")
    };
    dp._getRowData=function(rowId){
        var data = {};
        var z=this.obj._globalIdStorageFind(rowId);
        var z2=z.parentObject;

        var i=0;
        for (i=0; i<z2.childsCount; i++)
            if (z2.childNodes[i]==z) break;

        data["tr_id"] = z.id;
        data["tr_pid"] = z2.id;
        data["tr_order"] = i;
        data["tr_text"] = z.span.innerHTML;

        z2=(z._userdatalist||"").split(",");
        for (i=0; i<z2.length; i++)
            data[z2[i]]=z.userData["t_"+z2[i]];

        return data;
    };
};

//(c)dhtmlx ltd. www.dhtmlx.com
if (typeof(window.dhtmlXCellObject) != "undefined") {

    dhtmlXCellObject.prototype.attachTree = function(rootId) {

        this.callEvent("_onBeforeContentAttach",["tree"]);

        var obj = document.createElement("DIV");
        obj.style.width = "100%";
        obj.style.height = "100%";
        obj.style.position = "relative";
        obj.style.overflow = "hidden";

        this._attachObject(obj);

        this.dataType = "tree";
        this.dataObj = new dhtmlXTreeObject(obj, "100%", "100%", (rootId||0));
        this.dataObj.setSkin(this.conf.skin);

        // cosmetic fix
        this.dataObj.allTree.childNodes[0].style.marginTop = "2px";
        this.dataObj.allTree.childNodes[0].style.marginBottom = "2px";

        //obj.style.overflow = "auto";
        obj = null;

        this.callEvent("_onContentAttach",[]);

        return this.dataObj;

    };

}

/*
Product Name: dhtmlxTree
Version: 4.5
Edition: Standard
License: content of this file is covered by GPL. Usage outside GPL terms is prohibited. To obtain Commercial or Enterprise license contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function jsonPointer(data,parent){
    this.d=data;
    this.dp=parent;
}
jsonPointer.prototype={
    text:function(){ var afff=function(n){ var p=[]; for(var i=0; i<n.length; i++) p.push("{"+sfff(n[i])+"}"); return p.join(","); }; var sfff=function(n){ var p=[]; for (var a in n) if (typeof(n[a])=="object"){ if (a.length) p.push('"'+a+'":['+afff(n[a])+"]");  else p.push('"'+a+'":{'+sfff(n[a])+"}"); }else p.push('"'+a+'":"'+n[a]+'"'); return p.join(","); }; return "{"+sfff(this.d)+"}"; },
    get:function(name){return this.d[name]; },
    exists:function(){return !!this.d },
    content:function(){return this.d.content; },
    each:function(name,f,t){  var a=this.d[name]; var c=new jsonPointer(); if (a) for (var i=0; i<a.length; i++) { c.d=a[i]; f.apply(t,[c,i]); } },
    get_all:function(){ return this.d; },
    sub:function(name){ return new jsonPointer(this.d[name],this.d) },
    sub_exists:function(name){ return !!this.d[name]; },
    each_x:function(name,rule,f,t,i){  var a=this.d[name]; var c=new jsonPointer(0,this.d); if (a) for (i=i||0; i<a.length; i++) if (a[i][rule]) { c.d=a[i]; if(f.apply(t,[c,i])==-1) return; } },
    up:function(name){ return new jsonPointer(this.dp,this.d);  },
    set:function(name,val){ this.d[name]=val;  },
    clone:function(name){ return new jsonPointer(this.d,this.dp); },
    through:function(name,rule,v,f,t){  var a=this.d[name]; if (a.length) for (var i=0; i<a.length; i++) { if (a[i][rule]!=null && a[i][rule]!="" &&  (!v || a[i][rule]==v )) {
        var c=new jsonPointer(a[i],this.d);  f.apply(t,[c,i]); }  var w=this.d; this.d=a[i];
        if (this.sub_exists(name)) this.through(name,rule,v,f,t); this.d=w;   } }
}

/**
 *     @desc: load tree from js array file|stream
 *     @type: public
 *     @param: file - link to JSArray file
 *     @param: afterCall - function which will be called after xml loading
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.loadJSArrayFile=function(file,callback){
    if (window.console && window.console.info)
        window.console.info("loadJSArrayFile was deprecated", "http://docs.dhtmlx.com/migration__index.html#migrationfrom43to44");
    return this._loadJSArrayFile(file, callback);
};
dhtmlXTreeObject.prototype._loadJSArrayFile=function(file,callback){
    if (!this.parsCount) this.callEvent("onXLS",[this,this._ld_id]); this._ld_id=null; this.xmlstate=1;
    var that=this;

    this.XMLLoader=function(xml, callback){
        eval("var z="+xml.responseText);
        this._loadJSArray(z);
        if (callback) callback.call(this, xml);
    };

    dhx4.ajax.get(file, function(obj){
        that.XMLLoader(obj.xmlDoc, callback);
    });
};

/**
 *     @desc: load tree from csv file|stream
 *     @type: public
 *     @param: file - link to CSV file
 *     @param: afterCall - function which will be called after xml loading
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.loadCSV=function(file,callback){
    if (window.console && window.console.info)
        window.console.info("loadCSV was deprecated", "http://docs.dhtmlx.com/migration__index.html#migrationfrom43to44");
    return this._loadCSV(file, callback);
};
dhtmlXTreeObject.prototype._loadCSV=function(file,callback){
    if (!this.parsCount) this.callEvent("onXLS",[this,this._ld_id]); this._ld_id=null; this.xmlstate=1;
    var that=this;
    this.XMLLoader=function(xml, callback){
        this._loadCSVString(xml.responseText);
        if (callback) callback.call(this, xml);
    };

    dhx4.ajax.get(file, function(obj){
        that.XMLLoader(obj.xmlDoc, callback);
    });
};

/**
 *     @desc: load tree from js array object
 *     @type: public
 *     @param: ar - js array
 *     @param: afterCall - function which will be called after xml loading
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.loadJSArray=function(file,callback){
    if (window.console && window.console.info)
        window.console.info("loadJSArray was deprecated", "http://docs.dhtmlx.com/migration__index.html#migrationfrom43to44");
    return this._loadJSArray(file, callback);
};
dhtmlXTreeObject.prototype._loadJSArray=function(ar,afterCall){

    //array id,parentid,text
    var z=[];
    for (var i=0; i<ar.length; i++){
        if (!z[ar[i][1]]) z[ar[i][1]]=[];
        z[ar[i][1]].push({id:ar[i][0],text:ar[i][2]});
    }

    var top={id: this.rootId};
    var f=function(top,f){
        if (z[top.id]){
            top.item=z[top.id];
            for (var j=0; j<top.item.length; j++)
                f(top.item[j],f);
        }
    }
    f(top,f);
    this._loadJSONObject(top,afterCall);
}


/**
 *     @desc: load tree from csv string
 *     @type: public
 *     @param: csv - csv string
 *     @param: afterCall - function which will be called after xml loading
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.loadCSVString=function(file,callback){
    if (window.console && window.console.info)
        window.console.info("loadCSVString was deprecated", "http://docs.dhtmlx.com/migration__index.html#migrationfrom43to44");
    return this._loadCSVString(file, callback);
};
dhtmlXTreeObject.prototype._loadCSVString=function(csv,afterCall){
    //array id,parentid,text
    var z=[];
    var ar=csv.split("\n");
    for (var i=0; i<ar.length; i++){
        var t=ar[i].split(",");
        if (!z[t[1]]) z[t[1]]=[];
        z[t[1]].push({id:t[0],text:t[2]});
    }

    var top={id: this.rootId};
    var f=function(top,f){
        if (z[top.id]){
            top.item=z[top.id];
            for (var j=0; j<top.item.length; j++)
                f(top.item[j],f);
        }
    }
    f(top,f);
    this._loadJSONObject(top,afterCall);
}


/**
 *     @desc: load tree from json object
 *     @type: public
 *     @param: json - json object
 *     @param: afterCall - function which will be called after xml loading
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.loadJSONObject=function(file,callback){
    if (window.console && window.console.info)
        window.console.info("loadJSONObject was deprecated", "http://docs.dhtmlx.com/migration__index.html#migrationfrom43to44");
    return this._loadJSONObject(file, callback);
};
dhtmlXTreeObject.prototype._loadJSONObject=function(json,afterCall){
    if (!this.parsCount) this.callEvent("onXLS",[this,null]);this.xmlstate=1;
    var p=new jsonPointer(json);
    this._parse(p);
    this._p=p;
    if (afterCall) afterCall();
};


/**
 *     @desc: load tree from json file
 *     @type: public
 *     @param: file - link to JSON file
 *     @param: afterCall - function which will be called after xml loading
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.loadJSON=function(file,callback){
    if (window.console && window.console.info)
        window.console.info("loadJSON was deprecated", "http://docs.dhtmlx.com/migration__index.html#migrationfrom43to44");
    return this._loadJSON(file, callback);
};
dhtmlXTreeObject.prototype._loadJSON=function(file,callback){
    if (!this.parsCount) this.callEvent("onXLS",[this,this._ld_id]); this._ld_id=null; this.xmlstate=1;
    var that=this;

    this.XMLLoader=function(xml, callback){
        try {
            eval("var t="+xml.responseText);
        } catch(e){
            dhx4.callEvent("onLoadXMLerror",["Incorrect JSON",
                (xml),
                this
            ]);
            return;
        }
        var p=new jsonPointer(t);
        this._parse(p);
        this._p=p;
        if (callback) callback.call(this, xml);
    };

    dhx4.ajax.get(file, function(obj){
        that.XMLLoader(obj.xmlDoc, callback);
    });
};


/**
 *     @desc: return tree as json string
 *     @type: public
 *     @topic: 0
 */
dhtmlXTreeObject.prototype.serializeTreeToJSON=function(){
    var out=['{"id":"'+this.rootId+'", "item":['];
    var p=[];
    for (var i=0; i<this.htmlNode.childsCount; i++)
        p.push(this._serializeItemJSON(this.htmlNode.childNodes[i]));
    out.push(p.join(","));
    out.push("]}");
    return out.join("");
};
dhtmlXTreeObject.prototype._serializeItemJSON=function(itemNode){
    var out=[];
    if (itemNode.unParsed)
        return (itemNode.unParsed.text());

    if (this._selected.length)
        var lid=this._selected[0].id;
    else lid="";
    var text=itemNode.span.innerHTML;

    text=text.replace(/\"/g, "\\\"", text);

    if (!this._xfullXML)
        out.push('{ "id":"'+itemNode.id+'", '+(this._getOpenState(itemNode)==1?' "open":"1", ':'')+(lid==itemNode.id?' "select":"1",':'')+' "text":"'+text+'"'+( ((this.XMLsource)&&(itemNode.XMLload==0))?', "child":"1" ':''));
    else
        out.push('{ "id":"'+itemNode.id+'", '+(this._getOpenState(itemNode)==1?' "open":"1", ':'')+(lid==itemNode.id?' "select":"1",':'')+' "text":"'+text+'", "im0":"'+itemNode.images[0]+'", "im1":"'+itemNode.images[1]+'", "im2":"'+itemNode.images[2]+'" '+(itemNode.acolor?(', "aCol":"'+itemNode.acolor+'" '):'')+(itemNode.scolor?(', "sCol":"'+itemNode.scolor+'" '):'')+(itemNode.checkstate==1?', "checked":"1" ':(itemNode.checkstate==2?', "checked":"-1"':''))+(itemNode.closeable?', "closeable":"1" ':'')+( ((this.XMLsource)&&(itemNode.XMLload==0))?', "child":"1" ':''));

    if ((this._xuserData)&&(itemNode._userdatalist))
    {
        out.push(', "userdata":[');
        var names=itemNode._userdatalist.split(",");
        var p=[];
        for  (var i=0; i<names.length; i++)
            p.push('{ "name":"'+names[i]+'" , "content":"'+itemNode.userData["t_"+names[i]]+'" }');
        out.push(p.join(",")); out.push("]");
    }

    if (itemNode.childsCount){
        out.push(', "item":[');
        var p=[];
        for (var i=0; i<itemNode.childsCount; i++)
            p.push(this._serializeItemJSON(itemNode.childNodes[i]));
        out.push(p.join(","));
        out.push("]\n");
    }

    out.push("}\n")
    return out.join("");
}
//(c)dhtmlx ltd. www.dhtmlx.com
